
test_rtos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000645a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000024  00800060  0000645a  000064ee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000666  00800084  00800084  00006512  2**0
                  ALLOC
  3 .stab         00009210  00000000  00000000  00006514  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000054c1  00000000  00000000  0000f724  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 9a 03 	jmp	0x734	; 0x734 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e5       	ldi	r30, 0x5A	; 90
      68:	f4 e6       	ldi	r31, 0x64	; 100
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 38       	cpi	r26, 0x84	; 132
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	a4 e8       	ldi	r26, 0x84	; 132
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	aa 3e       	cpi	r26, 0xEA	; 234
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 43 31 	call	0x6286	; 0x6286 <main>
      8a:	0c 94 2b 32 	jmp	0x6456	; 0x6456 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <pvPortMalloc+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <pvPortMalloc+0x8>
      9a:	cd b7       	in	r28, 0x3d	; 61
      9c:	de b7       	in	r29, 0x3e	; 62
      9e:	9c 83       	std	Y+4, r25	; 0x04
      a0:	8b 83       	std	Y+3, r24	; 0x03
      a2:	1a 82       	std	Y+2, r1	; 0x02
      a4:	19 82       	std	Y+1, r1	; 0x01
      a6:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskSuspendAll>
      aa:	80 91 86 00 	lds	r24, 0x0086
      ae:	90 91 87 00 	lds	r25, 0x0087
      b2:	00 97       	sbiw	r24, 0x00	; 0
      b4:	31 f4       	brne	.+12     	; 0xc2 <pvPortMalloc+0x30>
      b6:	88 e8       	ldi	r24, 0x88	; 136
      b8:	90 e0       	ldi	r25, 0x00	; 0
      ba:	90 93 87 00 	sts	0x0087, r25
      be:	80 93 86 00 	sts	0x0086, r24
      c2:	8b 81       	ldd	r24, Y+3	; 0x03
      c4:	9c 81       	ldd	r25, Y+4	; 0x04
      c6:	00 97       	sbiw	r24, 0x00	; 0
      c8:	99 f1       	breq	.+102    	; 0x130 <pvPortMalloc+0x9e>
      ca:	80 91 84 00 	lds	r24, 0x0084
      ce:	90 91 85 00 	lds	r25, 0x0085
      d2:	2b 81       	ldd	r18, Y+3	; 0x03
      d4:	3c 81       	ldd	r19, Y+4	; 0x04
      d6:	82 0f       	add	r24, r18
      d8:	93 1f       	adc	r25, r19
      da:	25 e0       	ldi	r18, 0x05	; 5
      dc:	8b 3d       	cpi	r24, 0xDB	; 219
      de:	92 07       	cpc	r25, r18
      e0:	38 f5       	brcc	.+78     	; 0x130 <pvPortMalloc+0x9e>
      e2:	20 91 84 00 	lds	r18, 0x0084
      e6:	30 91 85 00 	lds	r19, 0x0085
      ea:	8b 81       	ldd	r24, Y+3	; 0x03
      ec:	9c 81       	ldd	r25, Y+4	; 0x04
      ee:	28 0f       	add	r18, r24
      f0:	39 1f       	adc	r19, r25
      f2:	80 91 84 00 	lds	r24, 0x0084
      f6:	90 91 85 00 	lds	r25, 0x0085
      fa:	82 17       	cp	r24, r18
      fc:	93 07       	cpc	r25, r19
      fe:	c0 f4       	brcc	.+48     	; 0x130 <pvPortMalloc+0x9e>
     100:	20 91 86 00 	lds	r18, 0x0086
     104:	30 91 87 00 	lds	r19, 0x0087
     108:	80 91 84 00 	lds	r24, 0x0084
     10c:	90 91 85 00 	lds	r25, 0x0085
     110:	82 0f       	add	r24, r18
     112:	93 1f       	adc	r25, r19
     114:	9a 83       	std	Y+2, r25	; 0x02
     116:	89 83       	std	Y+1, r24	; 0x01
     118:	20 91 84 00 	lds	r18, 0x0084
     11c:	30 91 85 00 	lds	r19, 0x0085
     120:	8b 81       	ldd	r24, Y+3	; 0x03
     122:	9c 81       	ldd	r25, Y+4	; 0x04
     124:	82 0f       	add	r24, r18
     126:	93 1f       	adc	r25, r19
     128:	90 93 85 00 	sts	0x0085, r25
     12c:	80 93 84 00 	sts	0x0084, r24
     130:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
     134:	89 81       	ldd	r24, Y+1	; 0x01
     136:	9a 81       	ldd	r25, Y+2	; 0x02
     138:	0f 90       	pop	r0
     13a:	0f 90       	pop	r0
     13c:	0f 90       	pop	r0
     13e:	0f 90       	pop	r0
     140:	cf 91       	pop	r28
     142:	df 91       	pop	r29
     144:	08 95       	ret

00000146 <vPortFree>:
    return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
     146:	df 93       	push	r29
     148:	cf 93       	push	r28
     14a:	00 d0       	rcall	.+0      	; 0x14c <vPortFree+0x6>
     14c:	cd b7       	in	r28, 0x3d	; 61
     14e:	de b7       	in	r29, 0x3e	; 62
     150:	9a 83       	std	Y+2, r25	; 0x02
     152:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
     154:	0f 90       	pop	r0
     156:	0f 90       	pop	r0
     158:	cf 91       	pop	r28
     15a:	df 91       	pop	r29
     15c:	08 95       	ret

0000015e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     15e:	df 93       	push	r29
     160:	cf 93       	push	r28
     162:	cd b7       	in	r28, 0x3d	; 61
     164:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
     166:	10 92 85 00 	sts	0x0085, r1
     16a:	10 92 84 00 	sts	0x0084, r1
}
     16e:	cf 91       	pop	r28
     170:	df 91       	pop	r29
     172:	08 95       	ret

00000174 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     174:	df 93       	push	r29
     176:	cf 93       	push	r28
     178:	cd b7       	in	r28, 0x3d	; 61
     17a:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     17c:	20 91 84 00 	lds	r18, 0x0084
     180:	30 91 85 00 	lds	r19, 0x0085
     184:	8b ed       	ldi	r24, 0xDB	; 219
     186:	95 e0       	ldi	r25, 0x05	; 5
     188:	82 1b       	sub	r24, r18
     18a:	93 0b       	sbc	r25, r19
}
     18c:	cf 91       	pop	r28
     18e:	df 91       	pop	r29
     190:	08 95       	ret

00000192 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     192:	df 93       	push	r29
     194:	cf 93       	push	r28
     196:	cd b7       	in	r28, 0x3d	; 61
     198:	de b7       	in	r29, 0x3e	; 62
     19a:	28 97       	sbiw	r28, 0x08	; 8
     19c:	0f b6       	in	r0, 0x3f	; 63
     19e:	f8 94       	cli
     1a0:	de bf       	out	0x3e, r29	; 62
     1a2:	0f be       	out	0x3f, r0	; 63
     1a4:	cd bf       	out	0x3d, r28	; 61
     1a6:	9c 83       	std	Y+4, r25	; 0x04
     1a8:	8b 83       	std	Y+3, r24	; 0x03
     1aa:	7e 83       	std	Y+6, r23	; 0x06
     1ac:	6d 83       	std	Y+5, r22	; 0x05
     1ae:	58 87       	std	Y+8, r21	; 0x08
     1b0:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     1b2:	eb 81       	ldd	r30, Y+3	; 0x03
     1b4:	fc 81       	ldd	r31, Y+4	; 0x04
     1b6:	81 e1       	ldi	r24, 0x11	; 17
     1b8:	80 83       	st	Z, r24
	pxTopOfStack--;
     1ba:	8b 81       	ldd	r24, Y+3	; 0x03
     1bc:	9c 81       	ldd	r25, Y+4	; 0x04
     1be:	01 97       	sbiw	r24, 0x01	; 1
     1c0:	9c 83       	std	Y+4, r25	; 0x04
     1c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     1c4:	eb 81       	ldd	r30, Y+3	; 0x03
     1c6:	fc 81       	ldd	r31, Y+4	; 0x04
     1c8:	82 e2       	ldi	r24, 0x22	; 34
     1ca:	80 83       	st	Z, r24
	pxTopOfStack--;
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	01 97       	sbiw	r24, 0x01	; 1
     1d2:	9c 83       	std	Y+4, r25	; 0x04
     1d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     1d6:	eb 81       	ldd	r30, Y+3	; 0x03
     1d8:	fc 81       	ldd	r31, Y+4	; 0x04
     1da:	83 e3       	ldi	r24, 0x33	; 51
     1dc:	80 83       	st	Z, r24
	pxTopOfStack--;
     1de:	8b 81       	ldd	r24, Y+3	; 0x03
     1e0:	9c 81       	ldd	r25, Y+4	; 0x04
     1e2:	01 97       	sbiw	r24, 0x01	; 1
     1e4:	9c 83       	std	Y+4, r25	; 0x04
     1e6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     1e8:	8d 81       	ldd	r24, Y+5	; 0x05
     1ea:	9e 81       	ldd	r25, Y+6	; 0x06
     1ec:	9a 83       	std	Y+2, r25	; 0x02
     1ee:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     1f0:	89 81       	ldd	r24, Y+1	; 0x01
     1f2:	eb 81       	ldd	r30, Y+3	; 0x03
     1f4:	fc 81       	ldd	r31, Y+4	; 0x04
     1f6:	80 83       	st	Z, r24
	pxTopOfStack--;
     1f8:	8b 81       	ldd	r24, Y+3	; 0x03
     1fa:	9c 81       	ldd	r25, Y+4	; 0x04
     1fc:	01 97       	sbiw	r24, 0x01	; 1
     1fe:	9c 83       	std	Y+4, r25	; 0x04
     200:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     202:	89 81       	ldd	r24, Y+1	; 0x01
     204:	9a 81       	ldd	r25, Y+2	; 0x02
     206:	89 2f       	mov	r24, r25
     208:	99 27       	eor	r25, r25
     20a:	9a 83       	std	Y+2, r25	; 0x02
     20c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     20e:	89 81       	ldd	r24, Y+1	; 0x01
     210:	eb 81       	ldd	r30, Y+3	; 0x03
     212:	fc 81       	ldd	r31, Y+4	; 0x04
     214:	80 83       	st	Z, r24
	pxTopOfStack--;
     216:	8b 81       	ldd	r24, Y+3	; 0x03
     218:	9c 81       	ldd	r25, Y+4	; 0x04
     21a:	01 97       	sbiw	r24, 0x01	; 1
     21c:	9c 83       	std	Y+4, r25	; 0x04
     21e:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     220:	eb 81       	ldd	r30, Y+3	; 0x03
     222:	fc 81       	ldd	r31, Y+4	; 0x04
     224:	10 82       	st	Z, r1
	pxTopOfStack--;
     226:	8b 81       	ldd	r24, Y+3	; 0x03
     228:	9c 81       	ldd	r25, Y+4	; 0x04
     22a:	01 97       	sbiw	r24, 0x01	; 1
     22c:	9c 83       	std	Y+4, r25	; 0x04
     22e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     230:	eb 81       	ldd	r30, Y+3	; 0x03
     232:	fc 81       	ldd	r31, Y+4	; 0x04
     234:	80 e8       	ldi	r24, 0x80	; 128
     236:	80 83       	st	Z, r24
	pxTopOfStack--;
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	01 97       	sbiw	r24, 0x01	; 1
     23e:	9c 83       	std	Y+4, r25	; 0x04
     240:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     242:	eb 81       	ldd	r30, Y+3	; 0x03
     244:	fc 81       	ldd	r31, Y+4	; 0x04
     246:	10 82       	st	Z, r1
	pxTopOfStack--;
     248:	8b 81       	ldd	r24, Y+3	; 0x03
     24a:	9c 81       	ldd	r25, Y+4	; 0x04
     24c:	01 97       	sbiw	r24, 0x01	; 1
     24e:	9c 83       	std	Y+4, r25	; 0x04
     250:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     252:	eb 81       	ldd	r30, Y+3	; 0x03
     254:	fc 81       	ldd	r31, Y+4	; 0x04
     256:	82 e0       	ldi	r24, 0x02	; 2
     258:	80 83       	st	Z, r24
	pxTopOfStack--;
     25a:	8b 81       	ldd	r24, Y+3	; 0x03
     25c:	9c 81       	ldd	r25, Y+4	; 0x04
     25e:	01 97       	sbiw	r24, 0x01	; 1
     260:	9c 83       	std	Y+4, r25	; 0x04
     262:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     264:	eb 81       	ldd	r30, Y+3	; 0x03
     266:	fc 81       	ldd	r31, Y+4	; 0x04
     268:	83 e0       	ldi	r24, 0x03	; 3
     26a:	80 83       	st	Z, r24
	pxTopOfStack--;
     26c:	8b 81       	ldd	r24, Y+3	; 0x03
     26e:	9c 81       	ldd	r25, Y+4	; 0x04
     270:	01 97       	sbiw	r24, 0x01	; 1
     272:	9c 83       	std	Y+4, r25	; 0x04
     274:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     276:	eb 81       	ldd	r30, Y+3	; 0x03
     278:	fc 81       	ldd	r31, Y+4	; 0x04
     27a:	84 e0       	ldi	r24, 0x04	; 4
     27c:	80 83       	st	Z, r24
	pxTopOfStack--;
     27e:	8b 81       	ldd	r24, Y+3	; 0x03
     280:	9c 81       	ldd	r25, Y+4	; 0x04
     282:	01 97       	sbiw	r24, 0x01	; 1
     284:	9c 83       	std	Y+4, r25	; 0x04
     286:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     288:	eb 81       	ldd	r30, Y+3	; 0x03
     28a:	fc 81       	ldd	r31, Y+4	; 0x04
     28c:	85 e0       	ldi	r24, 0x05	; 5
     28e:	80 83       	st	Z, r24
	pxTopOfStack--;
     290:	8b 81       	ldd	r24, Y+3	; 0x03
     292:	9c 81       	ldd	r25, Y+4	; 0x04
     294:	01 97       	sbiw	r24, 0x01	; 1
     296:	9c 83       	std	Y+4, r25	; 0x04
     298:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     29a:	eb 81       	ldd	r30, Y+3	; 0x03
     29c:	fc 81       	ldd	r31, Y+4	; 0x04
     29e:	86 e0       	ldi	r24, 0x06	; 6
     2a0:	80 83       	st	Z, r24
	pxTopOfStack--;
     2a2:	8b 81       	ldd	r24, Y+3	; 0x03
     2a4:	9c 81       	ldd	r25, Y+4	; 0x04
     2a6:	01 97       	sbiw	r24, 0x01	; 1
     2a8:	9c 83       	std	Y+4, r25	; 0x04
     2aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     2ac:	eb 81       	ldd	r30, Y+3	; 0x03
     2ae:	fc 81       	ldd	r31, Y+4	; 0x04
     2b0:	87 e0       	ldi	r24, 0x07	; 7
     2b2:	80 83       	st	Z, r24
	pxTopOfStack--;
     2b4:	8b 81       	ldd	r24, Y+3	; 0x03
     2b6:	9c 81       	ldd	r25, Y+4	; 0x04
     2b8:	01 97       	sbiw	r24, 0x01	; 1
     2ba:	9c 83       	std	Y+4, r25	; 0x04
     2bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     2be:	eb 81       	ldd	r30, Y+3	; 0x03
     2c0:	fc 81       	ldd	r31, Y+4	; 0x04
     2c2:	88 e0       	ldi	r24, 0x08	; 8
     2c4:	80 83       	st	Z, r24
	pxTopOfStack--;
     2c6:	8b 81       	ldd	r24, Y+3	; 0x03
     2c8:	9c 81       	ldd	r25, Y+4	; 0x04
     2ca:	01 97       	sbiw	r24, 0x01	; 1
     2cc:	9c 83       	std	Y+4, r25	; 0x04
     2ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     2d0:	eb 81       	ldd	r30, Y+3	; 0x03
     2d2:	fc 81       	ldd	r31, Y+4	; 0x04
     2d4:	89 e0       	ldi	r24, 0x09	; 9
     2d6:	80 83       	st	Z, r24
	pxTopOfStack--;
     2d8:	8b 81       	ldd	r24, Y+3	; 0x03
     2da:	9c 81       	ldd	r25, Y+4	; 0x04
     2dc:	01 97       	sbiw	r24, 0x01	; 1
     2de:	9c 83       	std	Y+4, r25	; 0x04
     2e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     2e2:	eb 81       	ldd	r30, Y+3	; 0x03
     2e4:	fc 81       	ldd	r31, Y+4	; 0x04
     2e6:	80 e1       	ldi	r24, 0x10	; 16
     2e8:	80 83       	st	Z, r24
	pxTopOfStack--;
     2ea:	8b 81       	ldd	r24, Y+3	; 0x03
     2ec:	9c 81       	ldd	r25, Y+4	; 0x04
     2ee:	01 97       	sbiw	r24, 0x01	; 1
     2f0:	9c 83       	std	Y+4, r25	; 0x04
     2f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     2f4:	eb 81       	ldd	r30, Y+3	; 0x03
     2f6:	fc 81       	ldd	r31, Y+4	; 0x04
     2f8:	81 e1       	ldi	r24, 0x11	; 17
     2fa:	80 83       	st	Z, r24
	pxTopOfStack--;
     2fc:	8b 81       	ldd	r24, Y+3	; 0x03
     2fe:	9c 81       	ldd	r25, Y+4	; 0x04
     300:	01 97       	sbiw	r24, 0x01	; 1
     302:	9c 83       	std	Y+4, r25	; 0x04
     304:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     306:	eb 81       	ldd	r30, Y+3	; 0x03
     308:	fc 81       	ldd	r31, Y+4	; 0x04
     30a:	82 e1       	ldi	r24, 0x12	; 18
     30c:	80 83       	st	Z, r24
	pxTopOfStack--;
     30e:	8b 81       	ldd	r24, Y+3	; 0x03
     310:	9c 81       	ldd	r25, Y+4	; 0x04
     312:	01 97       	sbiw	r24, 0x01	; 1
     314:	9c 83       	std	Y+4, r25	; 0x04
     316:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     318:	eb 81       	ldd	r30, Y+3	; 0x03
     31a:	fc 81       	ldd	r31, Y+4	; 0x04
     31c:	83 e1       	ldi	r24, 0x13	; 19
     31e:	80 83       	st	Z, r24
	pxTopOfStack--;
     320:	8b 81       	ldd	r24, Y+3	; 0x03
     322:	9c 81       	ldd	r25, Y+4	; 0x04
     324:	01 97       	sbiw	r24, 0x01	; 1
     326:	9c 83       	std	Y+4, r25	; 0x04
     328:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     32a:	eb 81       	ldd	r30, Y+3	; 0x03
     32c:	fc 81       	ldd	r31, Y+4	; 0x04
     32e:	84 e1       	ldi	r24, 0x14	; 20
     330:	80 83       	st	Z, r24
	pxTopOfStack--;
     332:	8b 81       	ldd	r24, Y+3	; 0x03
     334:	9c 81       	ldd	r25, Y+4	; 0x04
     336:	01 97       	sbiw	r24, 0x01	; 1
     338:	9c 83       	std	Y+4, r25	; 0x04
     33a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     33c:	eb 81       	ldd	r30, Y+3	; 0x03
     33e:	fc 81       	ldd	r31, Y+4	; 0x04
     340:	85 e1       	ldi	r24, 0x15	; 21
     342:	80 83       	st	Z, r24
	pxTopOfStack--;
     344:	8b 81       	ldd	r24, Y+3	; 0x03
     346:	9c 81       	ldd	r25, Y+4	; 0x04
     348:	01 97       	sbiw	r24, 0x01	; 1
     34a:	9c 83       	std	Y+4, r25	; 0x04
     34c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     34e:	eb 81       	ldd	r30, Y+3	; 0x03
     350:	fc 81       	ldd	r31, Y+4	; 0x04
     352:	86 e1       	ldi	r24, 0x16	; 22
     354:	80 83       	st	Z, r24
	pxTopOfStack--;
     356:	8b 81       	ldd	r24, Y+3	; 0x03
     358:	9c 81       	ldd	r25, Y+4	; 0x04
     35a:	01 97       	sbiw	r24, 0x01	; 1
     35c:	9c 83       	std	Y+4, r25	; 0x04
     35e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     360:	eb 81       	ldd	r30, Y+3	; 0x03
     362:	fc 81       	ldd	r31, Y+4	; 0x04
     364:	87 e1       	ldi	r24, 0x17	; 23
     366:	80 83       	st	Z, r24
	pxTopOfStack--;
     368:	8b 81       	ldd	r24, Y+3	; 0x03
     36a:	9c 81       	ldd	r25, Y+4	; 0x04
     36c:	01 97       	sbiw	r24, 0x01	; 1
     36e:	9c 83       	std	Y+4, r25	; 0x04
     370:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     372:	eb 81       	ldd	r30, Y+3	; 0x03
     374:	fc 81       	ldd	r31, Y+4	; 0x04
     376:	88 e1       	ldi	r24, 0x18	; 24
     378:	80 83       	st	Z, r24
	pxTopOfStack--;
     37a:	8b 81       	ldd	r24, Y+3	; 0x03
     37c:	9c 81       	ldd	r25, Y+4	; 0x04
     37e:	01 97       	sbiw	r24, 0x01	; 1
     380:	9c 83       	std	Y+4, r25	; 0x04
     382:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     384:	eb 81       	ldd	r30, Y+3	; 0x03
     386:	fc 81       	ldd	r31, Y+4	; 0x04
     388:	89 e1       	ldi	r24, 0x19	; 25
     38a:	80 83       	st	Z, r24
	pxTopOfStack--;
     38c:	8b 81       	ldd	r24, Y+3	; 0x03
     38e:	9c 81       	ldd	r25, Y+4	; 0x04
     390:	01 97       	sbiw	r24, 0x01	; 1
     392:	9c 83       	std	Y+4, r25	; 0x04
     394:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     396:	eb 81       	ldd	r30, Y+3	; 0x03
     398:	fc 81       	ldd	r31, Y+4	; 0x04
     39a:	80 e2       	ldi	r24, 0x20	; 32
     39c:	80 83       	st	Z, r24
	pxTopOfStack--;
     39e:	8b 81       	ldd	r24, Y+3	; 0x03
     3a0:	9c 81       	ldd	r25, Y+4	; 0x04
     3a2:	01 97       	sbiw	r24, 0x01	; 1
     3a4:	9c 83       	std	Y+4, r25	; 0x04
     3a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     3a8:	eb 81       	ldd	r30, Y+3	; 0x03
     3aa:	fc 81       	ldd	r31, Y+4	; 0x04
     3ac:	81 e2       	ldi	r24, 0x21	; 33
     3ae:	80 83       	st	Z, r24
	pxTopOfStack--;
     3b0:	8b 81       	ldd	r24, Y+3	; 0x03
     3b2:	9c 81       	ldd	r25, Y+4	; 0x04
     3b4:	01 97       	sbiw	r24, 0x01	; 1
     3b6:	9c 83       	std	Y+4, r25	; 0x04
     3b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     3ba:	eb 81       	ldd	r30, Y+3	; 0x03
     3bc:	fc 81       	ldd	r31, Y+4	; 0x04
     3be:	82 e2       	ldi	r24, 0x22	; 34
     3c0:	80 83       	st	Z, r24
	pxTopOfStack--;
     3c2:	8b 81       	ldd	r24, Y+3	; 0x03
     3c4:	9c 81       	ldd	r25, Y+4	; 0x04
     3c6:	01 97       	sbiw	r24, 0x01	; 1
     3c8:	9c 83       	std	Y+4, r25	; 0x04
     3ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     3cc:	eb 81       	ldd	r30, Y+3	; 0x03
     3ce:	fc 81       	ldd	r31, Y+4	; 0x04
     3d0:	83 e2       	ldi	r24, 0x23	; 35
     3d2:	80 83       	st	Z, r24
	pxTopOfStack--;
     3d4:	8b 81       	ldd	r24, Y+3	; 0x03
     3d6:	9c 81       	ldd	r25, Y+4	; 0x04
     3d8:	01 97       	sbiw	r24, 0x01	; 1
     3da:	9c 83       	std	Y+4, r25	; 0x04
     3dc:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     3de:	8f 81       	ldd	r24, Y+7	; 0x07
     3e0:	98 85       	ldd	r25, Y+8	; 0x08
     3e2:	9a 83       	std	Y+2, r25	; 0x02
     3e4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     3e6:	89 81       	ldd	r24, Y+1	; 0x01
     3e8:	eb 81       	ldd	r30, Y+3	; 0x03
     3ea:	fc 81       	ldd	r31, Y+4	; 0x04
     3ec:	80 83       	st	Z, r24
	pxTopOfStack--;
     3ee:	8b 81       	ldd	r24, Y+3	; 0x03
     3f0:	9c 81       	ldd	r25, Y+4	; 0x04
     3f2:	01 97       	sbiw	r24, 0x01	; 1
     3f4:	9c 83       	std	Y+4, r25	; 0x04
     3f6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     3f8:	89 81       	ldd	r24, Y+1	; 0x01
     3fa:	9a 81       	ldd	r25, Y+2	; 0x02
     3fc:	89 2f       	mov	r24, r25
     3fe:	99 27       	eor	r25, r25
     400:	9a 83       	std	Y+2, r25	; 0x02
     402:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     404:	89 81       	ldd	r24, Y+1	; 0x01
     406:	eb 81       	ldd	r30, Y+3	; 0x03
     408:	fc 81       	ldd	r31, Y+4	; 0x04
     40a:	80 83       	st	Z, r24
	pxTopOfStack--;
     40c:	8b 81       	ldd	r24, Y+3	; 0x03
     40e:	9c 81       	ldd	r25, Y+4	; 0x04
     410:	01 97       	sbiw	r24, 0x01	; 1
     412:	9c 83       	std	Y+4, r25	; 0x04
     414:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     416:	eb 81       	ldd	r30, Y+3	; 0x03
     418:	fc 81       	ldd	r31, Y+4	; 0x04
     41a:	86 e2       	ldi	r24, 0x26	; 38
     41c:	80 83       	st	Z, r24
	pxTopOfStack--;
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	9c 81       	ldd	r25, Y+4	; 0x04
     422:	01 97       	sbiw	r24, 0x01	; 1
     424:	9c 83       	std	Y+4, r25	; 0x04
     426:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     428:	eb 81       	ldd	r30, Y+3	; 0x03
     42a:	fc 81       	ldd	r31, Y+4	; 0x04
     42c:	87 e2       	ldi	r24, 0x27	; 39
     42e:	80 83       	st	Z, r24
	pxTopOfStack--;
     430:	8b 81       	ldd	r24, Y+3	; 0x03
     432:	9c 81       	ldd	r25, Y+4	; 0x04
     434:	01 97       	sbiw	r24, 0x01	; 1
     436:	9c 83       	std	Y+4, r25	; 0x04
     438:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     43a:	eb 81       	ldd	r30, Y+3	; 0x03
     43c:	fc 81       	ldd	r31, Y+4	; 0x04
     43e:	88 e2       	ldi	r24, 0x28	; 40
     440:	80 83       	st	Z, r24
	pxTopOfStack--;
     442:	8b 81       	ldd	r24, Y+3	; 0x03
     444:	9c 81       	ldd	r25, Y+4	; 0x04
     446:	01 97       	sbiw	r24, 0x01	; 1
     448:	9c 83       	std	Y+4, r25	; 0x04
     44a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     44c:	eb 81       	ldd	r30, Y+3	; 0x03
     44e:	fc 81       	ldd	r31, Y+4	; 0x04
     450:	89 e2       	ldi	r24, 0x29	; 41
     452:	80 83       	st	Z, r24
	pxTopOfStack--;
     454:	8b 81       	ldd	r24, Y+3	; 0x03
     456:	9c 81       	ldd	r25, Y+4	; 0x04
     458:	01 97       	sbiw	r24, 0x01	; 1
     45a:	9c 83       	std	Y+4, r25	; 0x04
     45c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     45e:	eb 81       	ldd	r30, Y+3	; 0x03
     460:	fc 81       	ldd	r31, Y+4	; 0x04
     462:	80 e3       	ldi	r24, 0x30	; 48
     464:	80 83       	st	Z, r24
	pxTopOfStack--;
     466:	8b 81       	ldd	r24, Y+3	; 0x03
     468:	9c 81       	ldd	r25, Y+4	; 0x04
     46a:	01 97       	sbiw	r24, 0x01	; 1
     46c:	9c 83       	std	Y+4, r25	; 0x04
     46e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     470:	eb 81       	ldd	r30, Y+3	; 0x03
     472:	fc 81       	ldd	r31, Y+4	; 0x04
     474:	81 e3       	ldi	r24, 0x31	; 49
     476:	80 83       	st	Z, r24
	pxTopOfStack--;
     478:	8b 81       	ldd	r24, Y+3	; 0x03
     47a:	9c 81       	ldd	r25, Y+4	; 0x04
     47c:	01 97       	sbiw	r24, 0x01	; 1
     47e:	9c 83       	std	Y+4, r25	; 0x04
     480:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     482:	8b 81       	ldd	r24, Y+3	; 0x03
     484:	9c 81       	ldd	r25, Y+4	; 0x04
}
     486:	28 96       	adiw	r28, 0x08	; 8
     488:	0f b6       	in	r0, 0x3f	; 63
     48a:	f8 94       	cli
     48c:	de bf       	out	0x3e, r29	; 62
     48e:	0f be       	out	0x3f, r0	; 63
     490:	cd bf       	out	0x3d, r28	; 61
     492:	cf 91       	pop	r28
     494:	df 91       	pop	r29
     496:	08 95       	ret

00000498 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     498:	df 93       	push	r29
     49a:	cf 93       	push	r28
     49c:	cd b7       	in	r28, 0x3d	; 61
     49e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     4a0:	0e 94 3e 03 	call	0x67c	; 0x67c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     4a4:	a0 91 64 06 	lds	r26, 0x0664
     4a8:	b0 91 65 06 	lds	r27, 0x0665
     4ac:	cd 91       	ld	r28, X+
     4ae:	cd bf       	out	0x3d, r28	; 61
     4b0:	dd 91       	ld	r29, X+
     4b2:	de bf       	out	0x3e, r29	; 62
     4b4:	ff 91       	pop	r31
     4b6:	ef 91       	pop	r30
     4b8:	df 91       	pop	r29
     4ba:	cf 91       	pop	r28
     4bc:	bf 91       	pop	r27
     4be:	af 91       	pop	r26
     4c0:	9f 91       	pop	r25
     4c2:	8f 91       	pop	r24
     4c4:	7f 91       	pop	r23
     4c6:	6f 91       	pop	r22
     4c8:	5f 91       	pop	r21
     4ca:	4f 91       	pop	r20
     4cc:	3f 91       	pop	r19
     4ce:	2f 91       	pop	r18
     4d0:	1f 91       	pop	r17
     4d2:	0f 91       	pop	r16
     4d4:	ff 90       	pop	r15
     4d6:	ef 90       	pop	r14
     4d8:	df 90       	pop	r13
     4da:	cf 90       	pop	r12
     4dc:	bf 90       	pop	r11
     4de:	af 90       	pop	r10
     4e0:	9f 90       	pop	r9
     4e2:	8f 90       	pop	r8
     4e4:	7f 90       	pop	r7
     4e6:	6f 90       	pop	r6
     4e8:	5f 90       	pop	r5
     4ea:	4f 90       	pop	r4
     4ec:	3f 90       	pop	r3
     4ee:	2f 90       	pop	r2
     4f0:	1f 90       	pop	r1
     4f2:	0f 90       	pop	r0
     4f4:	0f be       	out	0x3f, r0	; 63
     4f6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     4f8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     4fa:	81 e0       	ldi	r24, 0x01	; 1
}
     4fc:	cf 91       	pop	r28
     4fe:	df 91       	pop	r29
     500:	08 95       	ret

00000502 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     502:	df 93       	push	r29
     504:	cf 93       	push	r28
     506:	cd b7       	in	r28, 0x3d	; 61
     508:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     50a:	cf 91       	pop	r28
     50c:	df 91       	pop	r29
     50e:	08 95       	ret

00000510 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     510:	0f 92       	push	r0
     512:	0f b6       	in	r0, 0x3f	; 63
     514:	f8 94       	cli
     516:	0f 92       	push	r0
     518:	1f 92       	push	r1
     51a:	11 24       	eor	r1, r1
     51c:	2f 92       	push	r2
     51e:	3f 92       	push	r3
     520:	4f 92       	push	r4
     522:	5f 92       	push	r5
     524:	6f 92       	push	r6
     526:	7f 92       	push	r7
     528:	8f 92       	push	r8
     52a:	9f 92       	push	r9
     52c:	af 92       	push	r10
     52e:	bf 92       	push	r11
     530:	cf 92       	push	r12
     532:	df 92       	push	r13
     534:	ef 92       	push	r14
     536:	ff 92       	push	r15
     538:	0f 93       	push	r16
     53a:	1f 93       	push	r17
     53c:	2f 93       	push	r18
     53e:	3f 93       	push	r19
     540:	4f 93       	push	r20
     542:	5f 93       	push	r21
     544:	6f 93       	push	r22
     546:	7f 93       	push	r23
     548:	8f 93       	push	r24
     54a:	9f 93       	push	r25
     54c:	af 93       	push	r26
     54e:	bf 93       	push	r27
     550:	cf 93       	push	r28
     552:	df 93       	push	r29
     554:	ef 93       	push	r30
     556:	ff 93       	push	r31
     558:	a0 91 64 06 	lds	r26, 0x0664
     55c:	b0 91 65 06 	lds	r27, 0x0665
     560:	0d b6       	in	r0, 0x3d	; 61
     562:	0d 92       	st	X+, r0
     564:	0e b6       	in	r0, 0x3e	; 62
     566:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     568:	0e 94 96 1e 	call	0x3d2c	; 0x3d2c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     56c:	a0 91 64 06 	lds	r26, 0x0664
     570:	b0 91 65 06 	lds	r27, 0x0665
     574:	cd 91       	ld	r28, X+
     576:	cd bf       	out	0x3d, r28	; 61
     578:	dd 91       	ld	r29, X+
     57a:	de bf       	out	0x3e, r29	; 62
     57c:	ff 91       	pop	r31
     57e:	ef 91       	pop	r30
     580:	df 91       	pop	r29
     582:	cf 91       	pop	r28
     584:	bf 91       	pop	r27
     586:	af 91       	pop	r26
     588:	9f 91       	pop	r25
     58a:	8f 91       	pop	r24
     58c:	7f 91       	pop	r23
     58e:	6f 91       	pop	r22
     590:	5f 91       	pop	r21
     592:	4f 91       	pop	r20
     594:	3f 91       	pop	r19
     596:	2f 91       	pop	r18
     598:	1f 91       	pop	r17
     59a:	0f 91       	pop	r16
     59c:	ff 90       	pop	r15
     59e:	ef 90       	pop	r14
     5a0:	df 90       	pop	r13
     5a2:	cf 90       	pop	r12
     5a4:	bf 90       	pop	r11
     5a6:	af 90       	pop	r10
     5a8:	9f 90       	pop	r9
     5aa:	8f 90       	pop	r8
     5ac:	7f 90       	pop	r7
     5ae:	6f 90       	pop	r6
     5b0:	5f 90       	pop	r5
     5b2:	4f 90       	pop	r4
     5b4:	3f 90       	pop	r3
     5b6:	2f 90       	pop	r2
     5b8:	1f 90       	pop	r1
     5ba:	0f 90       	pop	r0
     5bc:	0f be       	out	0x3f, r0	; 63
     5be:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5c0:	08 95       	ret

000005c2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     5c2:	0f 92       	push	r0
     5c4:	0f b6       	in	r0, 0x3f	; 63
     5c6:	f8 94       	cli
     5c8:	0f 92       	push	r0
     5ca:	1f 92       	push	r1
     5cc:	11 24       	eor	r1, r1
     5ce:	2f 92       	push	r2
     5d0:	3f 92       	push	r3
     5d2:	4f 92       	push	r4
     5d4:	5f 92       	push	r5
     5d6:	6f 92       	push	r6
     5d8:	7f 92       	push	r7
     5da:	8f 92       	push	r8
     5dc:	9f 92       	push	r9
     5de:	af 92       	push	r10
     5e0:	bf 92       	push	r11
     5e2:	cf 92       	push	r12
     5e4:	df 92       	push	r13
     5e6:	ef 92       	push	r14
     5e8:	ff 92       	push	r15
     5ea:	0f 93       	push	r16
     5ec:	1f 93       	push	r17
     5ee:	2f 93       	push	r18
     5f0:	3f 93       	push	r19
     5f2:	4f 93       	push	r20
     5f4:	5f 93       	push	r21
     5f6:	6f 93       	push	r22
     5f8:	7f 93       	push	r23
     5fa:	8f 93       	push	r24
     5fc:	9f 93       	push	r25
     5fe:	af 93       	push	r26
     600:	bf 93       	push	r27
     602:	cf 93       	push	r28
     604:	df 93       	push	r29
     606:	ef 93       	push	r30
     608:	ff 93       	push	r31
     60a:	a0 91 64 06 	lds	r26, 0x0664
     60e:	b0 91 65 06 	lds	r27, 0x0665
     612:	0d b6       	in	r0, 0x3d	; 61
     614:	0d 92       	st	X+, r0
     616:	0e b6       	in	r0, 0x3e	; 62
     618:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     61a:	0e 94 ff 1c 	call	0x39fe	; 0x39fe <xTaskIncrementTick>
     61e:	88 23       	and	r24, r24
     620:	11 f0       	breq	.+4      	; 0x626 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     622:	0e 94 96 1e 	call	0x3d2c	; 0x3d2c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     626:	a0 91 64 06 	lds	r26, 0x0664
     62a:	b0 91 65 06 	lds	r27, 0x0665
     62e:	cd 91       	ld	r28, X+
     630:	cd bf       	out	0x3d, r28	; 61
     632:	dd 91       	ld	r29, X+
     634:	de bf       	out	0x3e, r29	; 62
     636:	ff 91       	pop	r31
     638:	ef 91       	pop	r30
     63a:	df 91       	pop	r29
     63c:	cf 91       	pop	r28
     63e:	bf 91       	pop	r27
     640:	af 91       	pop	r26
     642:	9f 91       	pop	r25
     644:	8f 91       	pop	r24
     646:	7f 91       	pop	r23
     648:	6f 91       	pop	r22
     64a:	5f 91       	pop	r21
     64c:	4f 91       	pop	r20
     64e:	3f 91       	pop	r19
     650:	2f 91       	pop	r18
     652:	1f 91       	pop	r17
     654:	0f 91       	pop	r16
     656:	ff 90       	pop	r15
     658:	ef 90       	pop	r14
     65a:	df 90       	pop	r13
     65c:	cf 90       	pop	r12
     65e:	bf 90       	pop	r11
     660:	af 90       	pop	r10
     662:	9f 90       	pop	r9
     664:	8f 90       	pop	r8
     666:	7f 90       	pop	r7
     668:	6f 90       	pop	r6
     66a:	5f 90       	pop	r5
     66c:	4f 90       	pop	r4
     66e:	3f 90       	pop	r3
     670:	2f 90       	pop	r2
     672:	1f 90       	pop	r1
     674:	0f 90       	pop	r0
     676:	0f be       	out	0x3f, r0	; 63
     678:	0f 90       	pop	r0

	asm volatile ( "ret" );
     67a:	08 95       	ret

0000067c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     67c:	df 93       	push	r29
     67e:	cf 93       	push	r28
     680:	00 d0       	rcall	.+0      	; 0x682 <prvSetupTimerInterrupt+0x6>
     682:	00 d0       	rcall	.+0      	; 0x684 <prvSetupTimerInterrupt+0x8>
     684:	00 d0       	rcall	.+0      	; 0x686 <prvSetupTimerInterrupt+0xa>
     686:	cd b7       	in	r28, 0x3d	; 61
     688:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     68a:	80 e4       	ldi	r24, 0x40	; 64
     68c:	9f e1       	ldi	r25, 0x1F	; 31
     68e:	a0 e0       	ldi	r26, 0x00	; 0
     690:	b0 e0       	ldi	r27, 0x00	; 0
     692:	8b 83       	std	Y+3, r24	; 0x03
     694:	9c 83       	std	Y+4, r25	; 0x04
     696:	ad 83       	std	Y+5, r26	; 0x05
     698:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     69a:	8b 81       	ldd	r24, Y+3	; 0x03
     69c:	9c 81       	ldd	r25, Y+4	; 0x04
     69e:	ad 81       	ldd	r26, Y+5	; 0x05
     6a0:	be 81       	ldd	r27, Y+6	; 0x06
     6a2:	68 94       	set
     6a4:	15 f8       	bld	r1, 5
     6a6:	b6 95       	lsr	r27
     6a8:	a7 95       	ror	r26
     6aa:	97 95       	ror	r25
     6ac:	87 95       	ror	r24
     6ae:	16 94       	lsr	r1
     6b0:	d1 f7       	brne	.-12     	; 0x6a6 <prvSetupTimerInterrupt+0x2a>
     6b2:	8b 83       	std	Y+3, r24	; 0x03
     6b4:	9c 83       	std	Y+4, r25	; 0x04
     6b6:	ad 83       	std	Y+5, r26	; 0x05
     6b8:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     6ba:	8b 81       	ldd	r24, Y+3	; 0x03
     6bc:	9c 81       	ldd	r25, Y+4	; 0x04
     6be:	ad 81       	ldd	r26, Y+5	; 0x05
     6c0:	be 81       	ldd	r27, Y+6	; 0x06
     6c2:	01 97       	sbiw	r24, 0x01	; 1
     6c4:	a1 09       	sbc	r26, r1
     6c6:	b1 09       	sbc	r27, r1
     6c8:	8b 83       	std	Y+3, r24	; 0x03
     6ca:	9c 83       	std	Y+4, r25	; 0x04
     6cc:	ad 83       	std	Y+5, r26	; 0x05
     6ce:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     6d0:	8b 81       	ldd	r24, Y+3	; 0x03
     6d2:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     6d4:	8b 81       	ldd	r24, Y+3	; 0x03
     6d6:	9c 81       	ldd	r25, Y+4	; 0x04
     6d8:	ad 81       	ldd	r26, Y+5	; 0x05
     6da:	be 81       	ldd	r27, Y+6	; 0x06
     6dc:	89 2f       	mov	r24, r25
     6de:	9a 2f       	mov	r25, r26
     6e0:	ab 2f       	mov	r26, r27
     6e2:	bb 27       	eor	r27, r27
     6e4:	8b 83       	std	Y+3, r24	; 0x03
     6e6:	9c 83       	std	Y+4, r25	; 0x04
     6e8:	ad 83       	std	Y+5, r26	; 0x05
     6ea:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     6ec:	8b 81       	ldd	r24, Y+3	; 0x03
     6ee:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     6f0:	eb e4       	ldi	r30, 0x4B	; 75
     6f2:	f0 e0       	ldi	r31, 0x00	; 0
     6f4:	8a 81       	ldd	r24, Y+2	; 0x02
     6f6:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     6f8:	ea e4       	ldi	r30, 0x4A	; 74
     6fa:	f0 e0       	ldi	r31, 0x00	; 0
     6fc:	89 81       	ldd	r24, Y+1	; 0x01
     6fe:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     700:	8b e0       	ldi	r24, 0x0B	; 11
     702:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     704:	ee e4       	ldi	r30, 0x4E	; 78
     706:	f0 e0       	ldi	r31, 0x00	; 0
     708:	89 81       	ldd	r24, Y+1	; 0x01
     70a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     70c:	e9 e5       	ldi	r30, 0x59	; 89
     70e:	f0 e0       	ldi	r31, 0x00	; 0
     710:	80 81       	ld	r24, Z
     712:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     714:	89 81       	ldd	r24, Y+1	; 0x01
     716:	80 61       	ori	r24, 0x10	; 16
     718:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     71a:	e9 e5       	ldi	r30, 0x59	; 89
     71c:	f0 e0       	ldi	r31, 0x00	; 0
     71e:	89 81       	ldd	r24, Y+1	; 0x01
     720:	80 83       	st	Z, r24
}
     722:	26 96       	adiw	r28, 0x06	; 6
     724:	0f b6       	in	r0, 0x3f	; 63
     726:	f8 94       	cli
     728:	de bf       	out	0x3e, r29	; 62
     72a:	0f be       	out	0x3f, r0	; 63
     72c:	cd bf       	out	0x3d, r28	; 61
     72e:	cf 91       	pop	r28
     730:	df 91       	pop	r29
     732:	08 95       	ret

00000734 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     734:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vPortYieldFromTick>
		asm volatile ( "reti" );
     738:	18 95       	reti

0000073a <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
     73a:	df 93       	push	r29
     73c:	cf 93       	push	r28
     73e:	00 d0       	rcall	.+0      	; 0x740 <xEventGroupCreate+0x6>
     740:	cd b7       	in	r28, 0x3d	; 61
     742:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     744:	8b e0       	ldi	r24, 0x0B	; 11
     746:	90 e0       	ldi	r25, 0x00	; 0
     748:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     74c:	9a 83       	std	Y+2, r25	; 0x02
     74e:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
     750:	89 81       	ldd	r24, Y+1	; 0x01
     752:	9a 81       	ldd	r25, Y+2	; 0x02
     754:	00 97       	sbiw	r24, 0x00	; 0
     756:	49 f0       	breq	.+18     	; 0x76a <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
     758:	e9 81       	ldd	r30, Y+1	; 0x01
     75a:	fa 81       	ldd	r31, Y+2	; 0x02
     75c:	11 82       	std	Z+1, r1	; 0x01
     75e:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     760:	89 81       	ldd	r24, Y+1	; 0x01
     762:	9a 81       	ldd	r25, Y+2	; 0x02
     764:	02 96       	adiw	r24, 0x02	; 2
     766:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
     76a:	89 81       	ldd	r24, Y+1	; 0x01
     76c:	9a 81       	ldd	r25, Y+2	; 0x02
    }
     76e:	0f 90       	pop	r0
     770:	0f 90       	pop	r0
     772:	cf 91       	pop	r28
     774:	df 91       	pop	r29
     776:	08 95       	ret

00000778 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
     778:	df 93       	push	r29
     77a:	cf 93       	push	r28
     77c:	cd b7       	in	r28, 0x3d	; 61
     77e:	de b7       	in	r29, 0x3e	; 62
     780:	60 97       	sbiw	r28, 0x10	; 16
     782:	0f b6       	in	r0, 0x3f	; 63
     784:	f8 94       	cli
     786:	de bf       	out	0x3e, r29	; 62
     788:	0f be       	out	0x3f, r0	; 63
     78a:	cd bf       	out	0x3d, r28	; 61
     78c:	9a 87       	std	Y+10, r25	; 0x0a
     78e:	89 87       	std	Y+9, r24	; 0x09
     790:	7c 87       	std	Y+12, r23	; 0x0c
     792:	6b 87       	std	Y+11, r22	; 0x0b
     794:	5e 87       	std	Y+14, r21	; 0x0e
     796:	4d 87       	std	Y+13, r20	; 0x0d
     798:	38 8b       	std	Y+16, r19	; 0x10
     79a:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
     79c:	89 85       	ldd	r24, Y+9	; 0x09
     79e:	9a 85       	ldd	r25, Y+10	; 0x0a
     7a0:	9c 83       	std	Y+4, r25	; 0x04
     7a2:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
     7a4:	19 82       	std	Y+1, r1	; 0x01
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
     7a6:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
     7aa:	eb 81       	ldd	r30, Y+3	; 0x03
     7ac:	fc 81       	ldd	r31, Y+4	; 0x04
     7ae:	80 81       	ld	r24, Z
     7b0:	91 81       	ldd	r25, Z+1	; 0x01
     7b2:	98 87       	std	Y+8, r25	; 0x08
     7b4:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     7b6:	89 85       	ldd	r24, Y+9	; 0x09
     7b8:	9a 85       	ldd	r25, Y+10	; 0x0a
     7ba:	2b 85       	ldd	r18, Y+11	; 0x0b
     7bc:	3c 85       	ldd	r19, Y+12	; 0x0c
     7be:	b9 01       	movw	r22, r18
     7c0:	0e 94 93 05 	call	0xb26	; 0xb26 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     7c4:	2f 81       	ldd	r18, Y+7	; 0x07
     7c6:	38 85       	ldd	r19, Y+8	; 0x08
     7c8:	8b 85       	ldd	r24, Y+11	; 0x0b
     7ca:	9c 85       	ldd	r25, Y+12	; 0x0c
     7cc:	28 2b       	or	r18, r24
     7ce:	39 2b       	or	r19, r25
     7d0:	8d 85       	ldd	r24, Y+13	; 0x0d
     7d2:	9e 85       	ldd	r25, Y+14	; 0x0e
     7d4:	28 23       	and	r18, r24
     7d6:	39 23       	and	r19, r25
     7d8:	8d 85       	ldd	r24, Y+13	; 0x0d
     7da:	9e 85       	ldd	r25, Y+14	; 0x0e
     7dc:	28 17       	cp	r18, r24
     7de:	39 07       	cpc	r19, r25
     7e0:	c9 f4       	brne	.+50     	; 0x814 <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     7e2:	2f 81       	ldd	r18, Y+7	; 0x07
     7e4:	38 85       	ldd	r19, Y+8	; 0x08
     7e6:	8b 85       	ldd	r24, Y+11	; 0x0b
     7e8:	9c 85       	ldd	r25, Y+12	; 0x0c
     7ea:	82 2b       	or	r24, r18
     7ec:	93 2b       	or	r25, r19
     7ee:	9e 83       	std	Y+6, r25	; 0x06
     7f0:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     7f2:	eb 81       	ldd	r30, Y+3	; 0x03
     7f4:	fc 81       	ldd	r31, Y+4	; 0x04
     7f6:	20 81       	ld	r18, Z
     7f8:	31 81       	ldd	r19, Z+1	; 0x01
     7fa:	8d 85       	ldd	r24, Y+13	; 0x0d
     7fc:	9e 85       	ldd	r25, Y+14	; 0x0e
     7fe:	80 95       	com	r24
     800:	90 95       	com	r25
     802:	82 23       	and	r24, r18
     804:	93 23       	and	r25, r19
     806:	eb 81       	ldd	r30, Y+3	; 0x03
     808:	fc 81       	ldd	r31, Y+4	; 0x04
     80a:	91 83       	std	Z+1, r25	; 0x01
     80c:	80 83       	st	Z, r24

            xTicksToWait = 0;
     80e:	18 8a       	std	Y+16, r1	; 0x10
     810:	1f 86       	std	Y+15, r1	; 0x0f
     812:	1e c0       	rjmp	.+60     	; 0x850 <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
     814:	8f 85       	ldd	r24, Y+15	; 0x0f
     816:	98 89       	ldd	r25, Y+16	; 0x10
     818:	00 97       	sbiw	r24, 0x00	; 0
     81a:	91 f0       	breq	.+36     	; 0x840 <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     81c:	8b 81       	ldd	r24, Y+3	; 0x03
     81e:	9c 81       	ldd	r25, Y+4	; 0x04
     820:	bc 01       	movw	r22, r24
     822:	6e 5f       	subi	r22, 0xFE	; 254
     824:	7f 4f       	sbci	r23, 0xFF	; 255
     826:	8d 85       	ldd	r24, Y+13	; 0x0d
     828:	9e 85       	ldd	r25, Y+14	; 0x0e
     82a:	9c 01       	movw	r18, r24
     82c:	35 60       	ori	r19, 0x05	; 5
     82e:	4f 85       	ldd	r20, Y+15	; 0x0f
     830:	58 89       	ldd	r21, Y+16	; 0x10
     832:	cb 01       	movw	r24, r22
     834:	b9 01       	movw	r22, r18
     836:	0e 94 25 1f 	call	0x3e4a	; 0x3e4a <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
     83a:	1e 82       	std	Y+6, r1	; 0x06
     83c:	1d 82       	std	Y+5, r1	; 0x05
     83e:	08 c0       	rjmp	.+16     	; 0x850 <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
     840:	eb 81       	ldd	r30, Y+3	; 0x03
     842:	fc 81       	ldd	r31, Y+4	; 0x04
     844:	80 81       	ld	r24, Z
     846:	91 81       	ldd	r25, Z+1	; 0x01
     848:	9e 83       	std	Y+6, r25	; 0x06
     84a:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
     84c:	81 e0       	ldi	r24, 0x01	; 1
     84e:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
     850:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
     854:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
     856:	8f 85       	ldd	r24, Y+15	; 0x0f
     858:	98 89       	ldd	r25, Y+16	; 0x10
     85a:	00 97       	sbiw	r24, 0x00	; 0
     85c:	09 f4       	brne	.+2      	; 0x860 <__stack+0x1>
     85e:	3a c0       	rjmp	.+116    	; 0x8d4 <__stack+0x75>
    {
        if( xAlreadyYielded == pdFALSE )
     860:	8a 81       	ldd	r24, Y+2	; 0x02
     862:	88 23       	and	r24, r24
     864:	11 f4       	brne	.+4      	; 0x86a <__stack+0xb>
        {
            portYIELD_WITHIN_API();
     866:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
     86a:	0e 94 c5 23 	call	0x478a	; 0x478a <uxTaskResetEventItemValue>
     86e:	9e 83       	std	Y+6, r25	; 0x06
     870:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     872:	8d 81       	ldd	r24, Y+5	; 0x05
     874:	9e 81       	ldd	r25, Y+6	; 0x06
     876:	80 70       	andi	r24, 0x00	; 0
     878:	92 70       	andi	r25, 0x02	; 2
     87a:	00 97       	sbiw	r24, 0x00	; 0
     87c:	31 f5       	brne	.+76     	; 0x8ca <__stack+0x6b>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
     87e:	0f b6       	in	r0, 0x3f	; 63
     880:	f8 94       	cli
     882:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
     884:	eb 81       	ldd	r30, Y+3	; 0x03
     886:	fc 81       	ldd	r31, Y+4	; 0x04
     888:	80 81       	ld	r24, Z
     88a:	91 81       	ldd	r25, Z+1	; 0x01
     88c:	9e 83       	std	Y+6, r25	; 0x06
     88e:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     890:	2d 81       	ldd	r18, Y+5	; 0x05
     892:	3e 81       	ldd	r19, Y+6	; 0x06
     894:	8d 85       	ldd	r24, Y+13	; 0x0d
     896:	9e 85       	ldd	r25, Y+14	; 0x0e
     898:	28 23       	and	r18, r24
     89a:	39 23       	and	r19, r25
     89c:	8d 85       	ldd	r24, Y+13	; 0x0d
     89e:	9e 85       	ldd	r25, Y+14	; 0x0e
     8a0:	28 17       	cp	r18, r24
     8a2:	39 07       	cpc	r19, r25
     8a4:	71 f4       	brne	.+28     	; 0x8c2 <__stack+0x63>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     8a6:	eb 81       	ldd	r30, Y+3	; 0x03
     8a8:	fc 81       	ldd	r31, Y+4	; 0x04
     8aa:	20 81       	ld	r18, Z
     8ac:	31 81       	ldd	r19, Z+1	; 0x01
     8ae:	8d 85       	ldd	r24, Y+13	; 0x0d
     8b0:	9e 85       	ldd	r25, Y+14	; 0x0e
     8b2:	80 95       	com	r24
     8b4:	90 95       	com	r25
     8b6:	82 23       	and	r24, r18
     8b8:	93 23       	and	r25, r19
     8ba:	eb 81       	ldd	r30, Y+3	; 0x03
     8bc:	fc 81       	ldd	r31, Y+4	; 0x04
     8be:	91 83       	std	Z+1, r25	; 0x01
     8c0:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
     8c2:	0f 90       	pop	r0
     8c4:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
     8c6:	81 e0       	ldi	r24, 0x01	; 1
     8c8:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     8ca:	8d 81       	ldd	r24, Y+5	; 0x05
     8cc:	9e 81       	ldd	r25, Y+6	; 0x06
     8ce:	90 70       	andi	r25, 0x00	; 0
     8d0:	9e 83       	std	Y+6, r25	; 0x06
     8d2:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
     8d4:	8d 81       	ldd	r24, Y+5	; 0x05
     8d6:	9e 81       	ldd	r25, Y+6	; 0x06
}
     8d8:	60 96       	adiw	r28, 0x10	; 16
     8da:	0f b6       	in	r0, 0x3f	; 63
     8dc:	f8 94       	cli
     8de:	de bf       	out	0x3e, r29	; 62
     8e0:	0f be       	out	0x3f, r0	; 63
     8e2:	cd bf       	out	0x3d, r28	; 61
     8e4:	cf 91       	pop	r28
     8e6:	df 91       	pop	r29
     8e8:	08 95       	ret

000008ea <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
     8ea:	0f 93       	push	r16
     8ec:	1f 93       	push	r17
     8ee:	df 93       	push	r29
     8f0:	cf 93       	push	r28
     8f2:	cd b7       	in	r28, 0x3d	; 61
     8f4:	de b7       	in	r29, 0x3e	; 62
     8f6:	63 97       	sbiw	r28, 0x13	; 19
     8f8:	0f b6       	in	r0, 0x3f	; 63
     8fa:	f8 94       	cli
     8fc:	de bf       	out	0x3e, r29	; 62
     8fe:	0f be       	out	0x3f, r0	; 63
     900:	cd bf       	out	0x3d, r28	; 61
     902:	9d 87       	std	Y+13, r25	; 0x0d
     904:	8c 87       	std	Y+12, r24	; 0x0c
     906:	7f 87       	std	Y+15, r23	; 0x0f
     908:	6e 87       	std	Y+14, r22	; 0x0e
     90a:	48 8b       	std	Y+16, r20	; 0x10
     90c:	29 8b       	std	Y+17, r18	; 0x11
     90e:	1b 8b       	std	Y+19, r17	; 0x13
     910:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
     912:	8c 85       	ldd	r24, Y+12	; 0x0c
     914:	9d 85       	ldd	r25, Y+13	; 0x0d
     916:	9b 87       	std	Y+11, r25	; 0x0b
     918:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
     91a:	1f 82       	std	Y+7, r1	; 0x07
     91c:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
     91e:	1b 82       	std	Y+3, r1	; 0x03
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
     920:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     924:	ea 85       	ldd	r30, Y+10	; 0x0a
     926:	fb 85       	ldd	r31, Y+11	; 0x0b
     928:	80 81       	ld	r24, Z
     92a:	91 81       	ldd	r25, Z+1	; 0x01
     92c:	9a 83       	std	Y+2, r25	; 0x02
     92e:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     930:	89 81       	ldd	r24, Y+1	; 0x01
     932:	9a 81       	ldd	r25, Y+2	; 0x02
     934:	2e 85       	ldd	r18, Y+14	; 0x0e
     936:	3f 85       	ldd	r19, Y+15	; 0x0f
     938:	b9 01       	movw	r22, r18
     93a:	49 89       	ldd	r20, Y+17	; 0x11
     93c:	0e 94 b0 06 	call	0xd60	; 0xd60 <prvTestWaitCondition>
     940:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
     942:	8d 81       	ldd	r24, Y+5	; 0x05
     944:	88 23       	and	r24, r24
     946:	c1 f0       	breq	.+48     	; 0x978 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
     948:	89 81       	ldd	r24, Y+1	; 0x01
     94a:	9a 81       	ldd	r25, Y+2	; 0x02
     94c:	99 87       	std	Y+9, r25	; 0x09
     94e:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
     950:	1b 8a       	std	Y+19, r1	; 0x13
     952:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
     954:	88 89       	ldd	r24, Y+16	; 0x10
     956:	88 23       	and	r24, r24
     958:	e9 f1       	breq	.+122    	; 0x9d4 <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     95a:	ea 85       	ldd	r30, Y+10	; 0x0a
     95c:	fb 85       	ldd	r31, Y+11	; 0x0b
     95e:	20 81       	ld	r18, Z
     960:	31 81       	ldd	r19, Z+1	; 0x01
     962:	8e 85       	ldd	r24, Y+14	; 0x0e
     964:	9f 85       	ldd	r25, Y+15	; 0x0f
     966:	80 95       	com	r24
     968:	90 95       	com	r25
     96a:	82 23       	and	r24, r18
     96c:	93 23       	and	r25, r19
     96e:	ea 85       	ldd	r30, Y+10	; 0x0a
     970:	fb 85       	ldd	r31, Y+11	; 0x0b
     972:	91 83       	std	Z+1, r25	; 0x01
     974:	80 83       	st	Z, r24
     976:	2e c0       	rjmp	.+92     	; 0x9d4 <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
     978:	8a 89       	ldd	r24, Y+18	; 0x12
     97a:	9b 89       	ldd	r25, Y+19	; 0x13
     97c:	00 97       	sbiw	r24, 0x00	; 0
     97e:	39 f4       	brne	.+14     	; 0x98e <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
     980:	89 81       	ldd	r24, Y+1	; 0x01
     982:	9a 81       	ldd	r25, Y+2	; 0x02
     984:	99 87       	std	Y+9, r25	; 0x09
     986:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
     988:	81 e0       	ldi	r24, 0x01	; 1
     98a:	8b 83       	std	Y+3, r24	; 0x03
     98c:	23 c0       	rjmp	.+70     	; 0x9d4 <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
     98e:	88 89       	ldd	r24, Y+16	; 0x10
     990:	88 23       	and	r24, r24
     992:	29 f0       	breq	.+10     	; 0x99e <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     994:	8e 81       	ldd	r24, Y+6	; 0x06
     996:	9f 81       	ldd	r25, Y+7	; 0x07
     998:	91 60       	ori	r25, 0x01	; 1
     99a:	9f 83       	std	Y+7, r25	; 0x07
     99c:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
     99e:	89 89       	ldd	r24, Y+17	; 0x11
     9a0:	88 23       	and	r24, r24
     9a2:	29 f0       	breq	.+10     	; 0x9ae <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
     9a4:	8e 81       	ldd	r24, Y+6	; 0x06
     9a6:	9f 81       	ldd	r25, Y+7	; 0x07
     9a8:	94 60       	ori	r25, 0x04	; 4
     9aa:	9f 83       	std	Y+7, r25	; 0x07
     9ac:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     9ae:	8a 85       	ldd	r24, Y+10	; 0x0a
     9b0:	9b 85       	ldd	r25, Y+11	; 0x0b
     9b2:	bc 01       	movw	r22, r24
     9b4:	6e 5f       	subi	r22, 0xFE	; 254
     9b6:	7f 4f       	sbci	r23, 0xFF	; 255
     9b8:	2e 85       	ldd	r18, Y+14	; 0x0e
     9ba:	3f 85       	ldd	r19, Y+15	; 0x0f
     9bc:	8e 81       	ldd	r24, Y+6	; 0x06
     9be:	9f 81       	ldd	r25, Y+7	; 0x07
     9c0:	28 2b       	or	r18, r24
     9c2:	39 2b       	or	r19, r25
     9c4:	4a 89       	ldd	r20, Y+18	; 0x12
     9c6:	5b 89       	ldd	r21, Y+19	; 0x13
     9c8:	cb 01       	movw	r24, r22
     9ca:	b9 01       	movw	r22, r18
     9cc:	0e 94 25 1f 	call	0x3e4a	; 0x3e4a <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
     9d0:	19 86       	std	Y+9, r1	; 0x09
     9d2:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
     9d4:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
     9d8:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
     9da:	8a 89       	ldd	r24, Y+18	; 0x12
     9dc:	9b 89       	ldd	r25, Y+19	; 0x13
     9de:	00 97       	sbiw	r24, 0x00	; 0
     9e0:	09 f4       	brne	.+2      	; 0x9e4 <xEventGroupWaitBits+0xfa>
     9e2:	3c c0       	rjmp	.+120    	; 0xa5c <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
     9e4:	8c 81       	ldd	r24, Y+4	; 0x04
     9e6:	88 23       	and	r24, r24
     9e8:	11 f4       	brne	.+4      	; 0x9ee <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
     9ea:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
     9ee:	0e 94 c5 23 	call	0x478a	; 0x478a <uxTaskResetEventItemValue>
     9f2:	99 87       	std	Y+9, r25	; 0x09
     9f4:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     9f6:	88 85       	ldd	r24, Y+8	; 0x08
     9f8:	99 85       	ldd	r25, Y+9	; 0x09
     9fa:	80 70       	andi	r24, 0x00	; 0
     9fc:	92 70       	andi	r25, 0x02	; 2
     9fe:	00 97       	sbiw	r24, 0x00	; 0
     a00:	41 f5       	brne	.+80     	; 0xa52 <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
     a02:	0f b6       	in	r0, 0x3f	; 63
     a04:	f8 94       	cli
     a06:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
     a08:	ea 85       	ldd	r30, Y+10	; 0x0a
     a0a:	fb 85       	ldd	r31, Y+11	; 0x0b
     a0c:	80 81       	ld	r24, Z
     a0e:	91 81       	ldd	r25, Z+1	; 0x01
     a10:	99 87       	std	Y+9, r25	; 0x09
     a12:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     a14:	88 85       	ldd	r24, Y+8	; 0x08
     a16:	99 85       	ldd	r25, Y+9	; 0x09
     a18:	2e 85       	ldd	r18, Y+14	; 0x0e
     a1a:	3f 85       	ldd	r19, Y+15	; 0x0f
     a1c:	b9 01       	movw	r22, r18
     a1e:	49 89       	ldd	r20, Y+17	; 0x11
     a20:	0e 94 b0 06 	call	0xd60	; 0xd60 <prvTestWaitCondition>
     a24:	88 23       	and	r24, r24
     a26:	89 f0       	breq	.+34     	; 0xa4a <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
     a28:	88 89       	ldd	r24, Y+16	; 0x10
     a2a:	88 23       	and	r24, r24
     a2c:	71 f0       	breq	.+28     	; 0xa4a <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     a2e:	ea 85       	ldd	r30, Y+10	; 0x0a
     a30:	fb 85       	ldd	r31, Y+11	; 0x0b
     a32:	20 81       	ld	r18, Z
     a34:	31 81       	ldd	r19, Z+1	; 0x01
     a36:	8e 85       	ldd	r24, Y+14	; 0x0e
     a38:	9f 85       	ldd	r25, Y+15	; 0x0f
     a3a:	80 95       	com	r24
     a3c:	90 95       	com	r25
     a3e:	82 23       	and	r24, r18
     a40:	93 23       	and	r25, r19
     a42:	ea 85       	ldd	r30, Y+10	; 0x0a
     a44:	fb 85       	ldd	r31, Y+11	; 0x0b
     a46:	91 83       	std	Z+1, r25	; 0x01
     a48:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
     a4a:	81 e0       	ldi	r24, 0x01	; 1
     a4c:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
     a4e:	0f 90       	pop	r0
     a50:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     a52:	88 85       	ldd	r24, Y+8	; 0x08
     a54:	99 85       	ldd	r25, Y+9	; 0x09
     a56:	90 70       	andi	r25, 0x00	; 0
     a58:	99 87       	std	Y+9, r25	; 0x09
     a5a:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
     a5c:	88 85       	ldd	r24, Y+8	; 0x08
     a5e:	99 85       	ldd	r25, Y+9	; 0x09
}
     a60:	63 96       	adiw	r28, 0x13	; 19
     a62:	0f b6       	in	r0, 0x3f	; 63
     a64:	f8 94       	cli
     a66:	de bf       	out	0x3e, r29	; 62
     a68:	0f be       	out	0x3f, r0	; 63
     a6a:	cd bf       	out	0x3d, r28	; 61
     a6c:	cf 91       	pop	r28
     a6e:	df 91       	pop	r29
     a70:	1f 91       	pop	r17
     a72:	0f 91       	pop	r16
     a74:	08 95       	ret

00000a76 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
     a76:	df 93       	push	r29
     a78:	cf 93       	push	r28
     a7a:	cd b7       	in	r28, 0x3d	; 61
     a7c:	de b7       	in	r29, 0x3e	; 62
     a7e:	28 97       	sbiw	r28, 0x08	; 8
     a80:	0f b6       	in	r0, 0x3f	; 63
     a82:	f8 94       	cli
     a84:	de bf       	out	0x3e, r29	; 62
     a86:	0f be       	out	0x3f, r0	; 63
     a88:	cd bf       	out	0x3d, r28	; 61
     a8a:	9e 83       	std	Y+6, r25	; 0x06
     a8c:	8d 83       	std	Y+5, r24	; 0x05
     a8e:	78 87       	std	Y+8, r23	; 0x08
     a90:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
     a92:	8d 81       	ldd	r24, Y+5	; 0x05
     a94:	9e 81       	ldd	r25, Y+6	; 0x06
     a96:	9c 83       	std	Y+4, r25	; 0x04
     a98:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
     a9a:	0f b6       	in	r0, 0x3f	; 63
     a9c:	f8 94       	cli
     a9e:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
     aa0:	eb 81       	ldd	r30, Y+3	; 0x03
     aa2:	fc 81       	ldd	r31, Y+4	; 0x04
     aa4:	80 81       	ld	r24, Z
     aa6:	91 81       	ldd	r25, Z+1	; 0x01
     aa8:	9a 83       	std	Y+2, r25	; 0x02
     aaa:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
     aac:	eb 81       	ldd	r30, Y+3	; 0x03
     aae:	fc 81       	ldd	r31, Y+4	; 0x04
     ab0:	20 81       	ld	r18, Z
     ab2:	31 81       	ldd	r19, Z+1	; 0x01
     ab4:	8f 81       	ldd	r24, Y+7	; 0x07
     ab6:	98 85       	ldd	r25, Y+8	; 0x08
     ab8:	80 95       	com	r24
     aba:	90 95       	com	r25
     abc:	82 23       	and	r24, r18
     abe:	93 23       	and	r25, r19
     ac0:	eb 81       	ldd	r30, Y+3	; 0x03
     ac2:	fc 81       	ldd	r31, Y+4	; 0x04
     ac4:	91 83       	std	Z+1, r25	; 0x01
     ac6:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
     ac8:	0f 90       	pop	r0
     aca:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
     acc:	89 81       	ldd	r24, Y+1	; 0x01
     ace:	9a 81       	ldd	r25, Y+2	; 0x02
}
     ad0:	28 96       	adiw	r28, 0x08	; 8
     ad2:	0f b6       	in	r0, 0x3f	; 63
     ad4:	f8 94       	cli
     ad6:	de bf       	out	0x3e, r29	; 62
     ad8:	0f be       	out	0x3f, r0	; 63
     ada:	cd bf       	out	0x3d, r28	; 61
     adc:	cf 91       	pop	r28
     ade:	df 91       	pop	r29
     ae0:	08 95       	ret

00000ae2 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     ae2:	df 93       	push	r29
     ae4:	cf 93       	push	r28
     ae6:	cd b7       	in	r28, 0x3d	; 61
     ae8:	de b7       	in	r29, 0x3e	; 62
     aea:	27 97       	sbiw	r28, 0x07	; 7
     aec:	0f b6       	in	r0, 0x3f	; 63
     aee:	f8 94       	cli
     af0:	de bf       	out	0x3e, r29	; 62
     af2:	0f be       	out	0x3f, r0	; 63
     af4:	cd bf       	out	0x3d, r28	; 61
     af6:	9f 83       	std	Y+7, r25	; 0x07
     af8:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
     afa:	8e 81       	ldd	r24, Y+6	; 0x06
     afc:	9f 81       	ldd	r25, Y+7	; 0x07
     afe:	9c 83       	std	Y+4, r25	; 0x04
     b00:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     b02:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
     b04:	eb 81       	ldd	r30, Y+3	; 0x03
     b06:	fc 81       	ldd	r31, Y+4	; 0x04
     b08:	80 81       	ld	r24, Z
     b0a:	91 81       	ldd	r25, Z+1	; 0x01
     b0c:	9a 83       	std	Y+2, r25	; 0x02
     b0e:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
     b10:	89 81       	ldd	r24, Y+1	; 0x01
     b12:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     b14:	27 96       	adiw	r28, 0x07	; 7
     b16:	0f b6       	in	r0, 0x3f	; 63
     b18:	f8 94       	cli
     b1a:	de bf       	out	0x3e, r29	; 62
     b1c:	0f be       	out	0x3f, r0	; 63
     b1e:	cd bf       	out	0x3d, r28	; 61
     b20:	cf 91       	pop	r28
     b22:	df 91       	pop	r29
     b24:	08 95       	ret

00000b26 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
     b26:	df 93       	push	r29
     b28:	cf 93       	push	r28
     b2a:	cd b7       	in	r28, 0x3d	; 61
     b2c:	de b7       	in	r29, 0x3e	; 62
     b2e:	65 97       	sbiw	r28, 0x15	; 21
     b30:	0f b6       	in	r0, 0x3f	; 63
     b32:	f8 94       	cli
     b34:	de bf       	out	0x3e, r29	; 62
     b36:	0f be       	out	0x3f, r0	; 63
     b38:	cd bf       	out	0x3d, r28	; 61
     b3a:	9b 8b       	std	Y+19, r25	; 0x13
     b3c:	8a 8b       	std	Y+18, r24	; 0x12
     b3e:	7d 8b       	std	Y+21, r23	; 0x15
     b40:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem;
    ListItem_t * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     b42:	19 86       	std	Y+9, r1	; 0x09
     b44:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
     b46:	8a 89       	ldd	r24, Y+18	; 0x12
     b48:	9b 89       	ldd	r25, Y+19	; 0x13
     b4a:	9b 83       	std	Y+3, r25	; 0x03
     b4c:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
     b4e:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
     b50:	8a 81       	ldd	r24, Y+2	; 0x02
     b52:	9b 81       	ldd	r25, Y+3	; 0x03
     b54:	02 96       	adiw	r24, 0x02	; 2
     b56:	9b 87       	std	Y+11, r25	; 0x0b
     b58:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b5a:	8a 85       	ldd	r24, Y+10	; 0x0a
     b5c:	9b 85       	ldd	r25, Y+11	; 0x0b
     b5e:	03 96       	adiw	r24, 0x03	; 3
     b60:	9d 87       	std	Y+13, r25	; 0x0d
     b62:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
     b64:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
     b68:	ea 85       	ldd	r30, Y+10	; 0x0a
     b6a:	fb 85       	ldd	r31, Y+11	; 0x0b
     b6c:	85 81       	ldd	r24, Z+5	; 0x05
     b6e:	96 81       	ldd	r25, Z+6	; 0x06
     b70:	99 8b       	std	Y+17, r25	; 0x11
     b72:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
     b74:	ea 81       	ldd	r30, Y+2	; 0x02
     b76:	fb 81       	ldd	r31, Y+3	; 0x03
     b78:	20 81       	ld	r18, Z
     b7a:	31 81       	ldd	r19, Z+1	; 0x01
     b7c:	8c 89       	ldd	r24, Y+20	; 0x14
     b7e:	9d 89       	ldd	r25, Y+21	; 0x15
     b80:	82 2b       	or	r24, r18
     b82:	93 2b       	or	r25, r19
     b84:	ea 81       	ldd	r30, Y+2	; 0x02
     b86:	fb 81       	ldd	r31, Y+3	; 0x03
     b88:	91 83       	std	Z+1, r25	; 0x01
     b8a:	80 83       	st	Z, r24
     b8c:	59 c0       	rjmp	.+178    	; 0xc40 <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
     b8e:	e8 89       	ldd	r30, Y+16	; 0x10
     b90:	f9 89       	ldd	r31, Y+17	; 0x11
     b92:	82 81       	ldd	r24, Z+2	; 0x02
     b94:	93 81       	ldd	r25, Z+3	; 0x03
     b96:	9f 87       	std	Y+15, r25	; 0x0f
     b98:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     b9a:	e8 89       	ldd	r30, Y+16	; 0x10
     b9c:	f9 89       	ldd	r31, Y+17	; 0x11
     b9e:	80 81       	ld	r24, Z
     ba0:	91 81       	ldd	r25, Z+1	; 0x01
     ba2:	9f 83       	std	Y+7, r25	; 0x07
     ba4:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
     ba6:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     ba8:	8e 81       	ldd	r24, Y+6	; 0x06
     baa:	9f 81       	ldd	r25, Y+7	; 0x07
     bac:	80 70       	andi	r24, 0x00	; 0
     bae:	9d 83       	std	Y+5, r25	; 0x05
     bb0:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     bb2:	8e 81       	ldd	r24, Y+6	; 0x06
     bb4:	9f 81       	ldd	r25, Y+7	; 0x07
     bb6:	90 70       	andi	r25, 0x00	; 0
     bb8:	9f 83       	std	Y+7, r25	; 0x07
     bba:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     bbc:	8c 81       	ldd	r24, Y+4	; 0x04
     bbe:	9d 81       	ldd	r25, Y+5	; 0x05
     bc0:	80 70       	andi	r24, 0x00	; 0
     bc2:	94 70       	andi	r25, 0x04	; 4
     bc4:	00 97       	sbiw	r24, 0x00	; 0
     bc6:	69 f4       	brne	.+26     	; 0xbe2 <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     bc8:	ea 81       	ldd	r30, Y+2	; 0x02
     bca:	fb 81       	ldd	r31, Y+3	; 0x03
     bcc:	20 81       	ld	r18, Z
     bce:	31 81       	ldd	r19, Z+1	; 0x01
     bd0:	8e 81       	ldd	r24, Y+6	; 0x06
     bd2:	9f 81       	ldd	r25, Y+7	; 0x07
     bd4:	82 23       	and	r24, r18
     bd6:	93 23       	and	r25, r19
     bd8:	00 97       	sbiw	r24, 0x00	; 0
     bda:	91 f0       	breq	.+36     	; 0xc00 <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
     bdc:	81 e0       	ldi	r24, 0x01	; 1
     bde:	89 83       	std	Y+1, r24	; 0x01
     be0:	0f c0       	rjmp	.+30     	; 0xc00 <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     be2:	ea 81       	ldd	r30, Y+2	; 0x02
     be4:	fb 81       	ldd	r31, Y+3	; 0x03
     be6:	20 81       	ld	r18, Z
     be8:	31 81       	ldd	r19, Z+1	; 0x01
     bea:	8e 81       	ldd	r24, Y+6	; 0x06
     bec:	9f 81       	ldd	r25, Y+7	; 0x07
     bee:	28 23       	and	r18, r24
     bf0:	39 23       	and	r19, r25
     bf2:	8e 81       	ldd	r24, Y+6	; 0x06
     bf4:	9f 81       	ldd	r25, Y+7	; 0x07
     bf6:	28 17       	cp	r18, r24
     bf8:	39 07       	cpc	r19, r25
     bfa:	11 f4       	brne	.+4      	; 0xc00 <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
     bfc:	81 e0       	ldi	r24, 0x01	; 1
     bfe:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
     c00:	89 81       	ldd	r24, Y+1	; 0x01
     c02:	88 23       	and	r24, r24
     c04:	c9 f0       	breq	.+50     	; 0xc38 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     c06:	8c 81       	ldd	r24, Y+4	; 0x04
     c08:	9d 81       	ldd	r25, Y+5	; 0x05
     c0a:	80 70       	andi	r24, 0x00	; 0
     c0c:	91 70       	andi	r25, 0x01	; 1
     c0e:	00 97       	sbiw	r24, 0x00	; 0
     c10:	41 f0       	breq	.+16     	; 0xc22 <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
     c12:	88 85       	ldd	r24, Y+8	; 0x08
     c14:	99 85       	ldd	r25, Y+9	; 0x09
     c16:	2e 81       	ldd	r18, Y+6	; 0x06
     c18:	3f 81       	ldd	r19, Y+7	; 0x07
     c1a:	82 2b       	or	r24, r18
     c1c:	93 2b       	or	r25, r19
     c1e:	99 87       	std	Y+9, r25	; 0x09
     c20:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     c22:	ea 81       	ldd	r30, Y+2	; 0x02
     c24:	fb 81       	ldd	r31, Y+3	; 0x03
     c26:	80 81       	ld	r24, Z
     c28:	91 81       	ldd	r25, Z+1	; 0x01
     c2a:	9c 01       	movw	r18, r24
     c2c:	32 60       	ori	r19, 0x02	; 2
     c2e:	88 89       	ldd	r24, Y+16	; 0x10
     c30:	99 89       	ldd	r25, Y+17	; 0x11
     c32:	b9 01       	movw	r22, r18
     c34:	0e 94 30 21 	call	0x4260	; 0x4260 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
     c38:	8e 85       	ldd	r24, Y+14	; 0x0e
     c3a:	9f 85       	ldd	r25, Y+15	; 0x0f
     c3c:	99 8b       	std	Y+17, r25	; 0x11
     c3e:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
     c40:	28 89       	ldd	r18, Y+16	; 0x10
     c42:	39 89       	ldd	r19, Y+17	; 0x11
     c44:	8c 85       	ldd	r24, Y+12	; 0x0c
     c46:	9d 85       	ldd	r25, Y+13	; 0x0d
     c48:	28 17       	cp	r18, r24
     c4a:	39 07       	cpc	r19, r25
     c4c:	09 f0       	breq	.+2      	; 0xc50 <xEventGroupSetBits+0x12a>
     c4e:	9f cf       	rjmp	.-194    	; 0xb8e <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
     c50:	ea 81       	ldd	r30, Y+2	; 0x02
     c52:	fb 81       	ldd	r31, Y+3	; 0x03
     c54:	20 81       	ld	r18, Z
     c56:	31 81       	ldd	r19, Z+1	; 0x01
     c58:	88 85       	ldd	r24, Y+8	; 0x08
     c5a:	99 85       	ldd	r25, Y+9	; 0x09
     c5c:	80 95       	com	r24
     c5e:	90 95       	com	r25
     c60:	82 23       	and	r24, r18
     c62:	93 23       	and	r25, r19
     c64:	ea 81       	ldd	r30, Y+2	; 0x02
     c66:	fb 81       	ldd	r31, Y+3	; 0x03
     c68:	91 83       	std	Z+1, r25	; 0x01
     c6a:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
     c6c:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>

    return pxEventBits->uxEventBits;
     c70:	ea 81       	ldd	r30, Y+2	; 0x02
     c72:	fb 81       	ldd	r31, Y+3	; 0x03
     c74:	80 81       	ld	r24, Z
     c76:	91 81       	ldd	r25, Z+1	; 0x01
}
     c78:	65 96       	adiw	r28, 0x15	; 21
     c7a:	0f b6       	in	r0, 0x3f	; 63
     c7c:	f8 94       	cli
     c7e:	de bf       	out	0x3e, r29	; 62
     c80:	0f be       	out	0x3f, r0	; 63
     c82:	cd bf       	out	0x3d, r28	; 61
     c84:	cf 91       	pop	r28
     c86:	df 91       	pop	r29
     c88:	08 95       	ret

00000c8a <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     c8a:	df 93       	push	r29
     c8c:	cf 93       	push	r28
     c8e:	00 d0       	rcall	.+0      	; 0xc90 <vEventGroupDelete+0x6>
     c90:	00 d0       	rcall	.+0      	; 0xc92 <vEventGroupDelete+0x8>
     c92:	00 d0       	rcall	.+0      	; 0xc94 <vEventGroupDelete+0xa>
     c94:	cd b7       	in	r28, 0x3d	; 61
     c96:	de b7       	in	r29, 0x3e	; 62
     c98:	9e 83       	std	Y+6, r25	; 0x06
     c9a:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
     c9c:	8d 81       	ldd	r24, Y+5	; 0x05
     c9e:	9e 81       	ldd	r25, Y+6	; 0x06
     ca0:	9c 83       	std	Y+4, r25	; 0x04
     ca2:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     ca4:	8b 81       	ldd	r24, Y+3	; 0x03
     ca6:	9c 81       	ldd	r25, Y+4	; 0x04
     ca8:	02 96       	adiw	r24, 0x02	; 2
     caa:	9a 83       	std	Y+2, r25	; 0x02
     cac:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
     cae:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskSuspendAll>
     cb2:	08 c0       	rjmp	.+16     	; 0xcc4 <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     cb4:	e9 81       	ldd	r30, Y+1	; 0x01
     cb6:	fa 81       	ldd	r31, Y+2	; 0x02
     cb8:	85 81       	ldd	r24, Z+5	; 0x05
     cba:	96 81       	ldd	r25, Z+6	; 0x06
     cbc:	60 e0       	ldi	r22, 0x00	; 0
     cbe:	72 e0       	ldi	r23, 0x02	; 2
     cc0:	0e 94 30 21 	call	0x4260	; 0x4260 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     cc4:	e9 81       	ldd	r30, Y+1	; 0x01
     cc6:	fa 81       	ldd	r31, Y+2	; 0x02
     cc8:	80 81       	ld	r24, Z
     cca:	88 23       	and	r24, r24
     ccc:	99 f7       	brne	.-26     	; 0xcb4 <vEventGroupDelete+0x2a>
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
        }
    }
    ( void ) xTaskResumeAll();
     cce:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The event group can only have been allocated dynamically - free
         * it again. */
        vPortFree( pxEventBits );
     cd2:	8b 81       	ldd	r24, Y+3	; 0x03
     cd4:	9c 81       	ldd	r25, Y+4	; 0x04
     cd6:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
     cda:	26 96       	adiw	r28, 0x06	; 6
     cdc:	0f b6       	in	r0, 0x3f	; 63
     cde:	f8 94       	cli
     ce0:	de bf       	out	0x3e, r29	; 62
     ce2:	0f be       	out	0x3f, r0	; 63
     ce4:	cd bf       	out	0x3d, r28	; 61
     ce6:	cf 91       	pop	r28
     ce8:	df 91       	pop	r29
     cea:	08 95       	ret

00000cec <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
     cec:	df 93       	push	r29
     cee:	cf 93       	push	r28
     cf0:	00 d0       	rcall	.+0      	; 0xcf2 <vEventGroupSetBitsCallback+0x6>
     cf2:	00 d0       	rcall	.+0      	; 0xcf4 <vEventGroupSetBitsCallback+0x8>
     cf4:	00 d0       	rcall	.+0      	; 0xcf6 <vEventGroupSetBitsCallback+0xa>
     cf6:	cd b7       	in	r28, 0x3d	; 61
     cf8:	de b7       	in	r29, 0x3e	; 62
     cfa:	9a 83       	std	Y+2, r25	; 0x02
     cfc:	89 83       	std	Y+1, r24	; 0x01
     cfe:	4b 83       	std	Y+3, r20	; 0x03
     d00:	5c 83       	std	Y+4, r21	; 0x04
     d02:	6d 83       	std	Y+5, r22	; 0x05
     d04:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     d06:	89 81       	ldd	r24, Y+1	; 0x01
     d08:	9a 81       	ldd	r25, Y+2	; 0x02
     d0a:	2b 81       	ldd	r18, Y+3	; 0x03
     d0c:	3c 81       	ldd	r19, Y+4	; 0x04
     d0e:	b9 01       	movw	r22, r18
     d10:	0e 94 93 05 	call	0xb26	; 0xb26 <xEventGroupSetBits>
}
     d14:	26 96       	adiw	r28, 0x06	; 6
     d16:	0f b6       	in	r0, 0x3f	; 63
     d18:	f8 94       	cli
     d1a:	de bf       	out	0x3e, r29	; 62
     d1c:	0f be       	out	0x3f, r0	; 63
     d1e:	cd bf       	out	0x3d, r28	; 61
     d20:	cf 91       	pop	r28
     d22:	df 91       	pop	r29
     d24:	08 95       	ret

00000d26 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
     d26:	df 93       	push	r29
     d28:	cf 93       	push	r28
     d2a:	00 d0       	rcall	.+0      	; 0xd2c <vEventGroupClearBitsCallback+0x6>
     d2c:	00 d0       	rcall	.+0      	; 0xd2e <vEventGroupClearBitsCallback+0x8>
     d2e:	00 d0       	rcall	.+0      	; 0xd30 <vEventGroupClearBitsCallback+0xa>
     d30:	cd b7       	in	r28, 0x3d	; 61
     d32:	de b7       	in	r29, 0x3e	; 62
     d34:	9a 83       	std	Y+2, r25	; 0x02
     d36:	89 83       	std	Y+1, r24	; 0x01
     d38:	4b 83       	std	Y+3, r20	; 0x03
     d3a:	5c 83       	std	Y+4, r21	; 0x04
     d3c:	6d 83       	std	Y+5, r22	; 0x05
     d3e:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     d40:	89 81       	ldd	r24, Y+1	; 0x01
     d42:	9a 81       	ldd	r25, Y+2	; 0x02
     d44:	2b 81       	ldd	r18, Y+3	; 0x03
     d46:	3c 81       	ldd	r19, Y+4	; 0x04
     d48:	b9 01       	movw	r22, r18
     d4a:	0e 94 3b 05 	call	0xa76	; 0xa76 <xEventGroupClearBits>
}
     d4e:	26 96       	adiw	r28, 0x06	; 6
     d50:	0f b6       	in	r0, 0x3f	; 63
     d52:	f8 94       	cli
     d54:	de bf       	out	0x3e, r29	; 62
     d56:	0f be       	out	0x3f, r0	; 63
     d58:	cd bf       	out	0x3d, r28	; 61
     d5a:	cf 91       	pop	r28
     d5c:	df 91       	pop	r29
     d5e:	08 95       	ret

00000d60 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
     d60:	df 93       	push	r29
     d62:	cf 93       	push	r28
     d64:	00 d0       	rcall	.+0      	; 0xd66 <prvTestWaitCondition+0x6>
     d66:	00 d0       	rcall	.+0      	; 0xd68 <prvTestWaitCondition+0x8>
     d68:	00 d0       	rcall	.+0      	; 0xd6a <prvTestWaitCondition+0xa>
     d6a:	cd b7       	in	r28, 0x3d	; 61
     d6c:	de b7       	in	r29, 0x3e	; 62
     d6e:	9b 83       	std	Y+3, r25	; 0x03
     d70:	8a 83       	std	Y+2, r24	; 0x02
     d72:	7d 83       	std	Y+5, r23	; 0x05
     d74:	6c 83       	std	Y+4, r22	; 0x04
     d76:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
     d78:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
     d7a:	8e 81       	ldd	r24, Y+6	; 0x06
     d7c:	88 23       	and	r24, r24
     d7e:	59 f4       	brne	.+22     	; 0xd96 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     d80:	8a 81       	ldd	r24, Y+2	; 0x02
     d82:	9b 81       	ldd	r25, Y+3	; 0x03
     d84:	2c 81       	ldd	r18, Y+4	; 0x04
     d86:	3d 81       	ldd	r19, Y+5	; 0x05
     d88:	82 23       	and	r24, r18
     d8a:	93 23       	and	r25, r19
     d8c:	00 97       	sbiw	r24, 0x00	; 0
     d8e:	81 f0       	breq	.+32     	; 0xdb0 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
     d90:	81 e0       	ldi	r24, 0x01	; 1
     d92:	89 83       	std	Y+1, r24	; 0x01
     d94:	0d c0       	rjmp	.+26     	; 0xdb0 <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     d96:	2a 81       	ldd	r18, Y+2	; 0x02
     d98:	3b 81       	ldd	r19, Y+3	; 0x03
     d9a:	8c 81       	ldd	r24, Y+4	; 0x04
     d9c:	9d 81       	ldd	r25, Y+5	; 0x05
     d9e:	28 23       	and	r18, r24
     da0:	39 23       	and	r19, r25
     da2:	8c 81       	ldd	r24, Y+4	; 0x04
     da4:	9d 81       	ldd	r25, Y+5	; 0x05
     da6:	28 17       	cp	r18, r24
     da8:	39 07       	cpc	r19, r25
     daa:	11 f4       	brne	.+4      	; 0xdb0 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
     dac:	81 e0       	ldi	r24, 0x01	; 1
     dae:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
     db0:	89 81       	ldd	r24, Y+1	; 0x01
}
     db2:	26 96       	adiw	r28, 0x06	; 6
     db4:	0f b6       	in	r0, 0x3f	; 63
     db6:	f8 94       	cli
     db8:	de bf       	out	0x3e, r29	; 62
     dba:	0f be       	out	0x3f, r0	; 63
     dbc:	cd bf       	out	0x3d, r28	; 61
     dbe:	cf 91       	pop	r28
     dc0:	df 91       	pop	r29
     dc2:	08 95       	ret

00000dc4 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     dc4:	df 93       	push	r29
     dc6:	cf 93       	push	r28
     dc8:	00 d0       	rcall	.+0      	; 0xdca <vListInitialise+0x6>
     dca:	cd b7       	in	r28, 0x3d	; 61
     dcc:	de b7       	in	r29, 0x3e	; 62
     dce:	9a 83       	std	Y+2, r25	; 0x02
     dd0:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     dd2:	89 81       	ldd	r24, Y+1	; 0x01
     dd4:	9a 81       	ldd	r25, Y+2	; 0x02
     dd6:	03 96       	adiw	r24, 0x03	; 3
     dd8:	e9 81       	ldd	r30, Y+1	; 0x01
     dda:	fa 81       	ldd	r31, Y+2	; 0x02
     ddc:	92 83       	std	Z+2, r25	; 0x02
     dde:	81 83       	std	Z+1, r24	; 0x01

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
     de0:	e9 81       	ldd	r30, Y+1	; 0x01
     de2:	fa 81       	ldd	r31, Y+2	; 0x02
     de4:	8f ef       	ldi	r24, 0xFF	; 255
     de6:	9f ef       	ldi	r25, 0xFF	; 255
     de8:	94 83       	std	Z+4, r25	; 0x04
     dea:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     dec:	89 81       	ldd	r24, Y+1	; 0x01
     dee:	9a 81       	ldd	r25, Y+2	; 0x02
     df0:	03 96       	adiw	r24, 0x03	; 3
     df2:	e9 81       	ldd	r30, Y+1	; 0x01
     df4:	fa 81       	ldd	r31, Y+2	; 0x02
     df6:	96 83       	std	Z+6, r25	; 0x06
     df8:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     dfa:	89 81       	ldd	r24, Y+1	; 0x01
     dfc:	9a 81       	ldd	r25, Y+2	; 0x02
     dfe:	03 96       	adiw	r24, 0x03	; 3
     e00:	e9 81       	ldd	r30, Y+1	; 0x01
     e02:	fa 81       	ldd	r31, Y+2	; 0x02
     e04:	90 87       	std	Z+8, r25	; 0x08
     e06:	87 83       	std	Z+7, r24	; 0x07
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     e08:	e9 81       	ldd	r30, Y+1	; 0x01
     e0a:	fa 81       	ldd	r31, Y+2	; 0x02
     e0c:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     e0e:	0f 90       	pop	r0
     e10:	0f 90       	pop	r0
     e12:	cf 91       	pop	r28
     e14:	df 91       	pop	r29
     e16:	08 95       	ret

00000e18 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     e18:	df 93       	push	r29
     e1a:	cf 93       	push	r28
     e1c:	00 d0       	rcall	.+0      	; 0xe1e <vListInitialiseItem+0x6>
     e1e:	cd b7       	in	r28, 0x3d	; 61
     e20:	de b7       	in	r29, 0x3e	; 62
     e22:	9a 83       	std	Y+2, r25	; 0x02
     e24:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
     e26:	e9 81       	ldd	r30, Y+1	; 0x01
     e28:	fa 81       	ldd	r31, Y+2	; 0x02
     e2a:	11 86       	std	Z+9, r1	; 0x09
     e2c:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     e2e:	0f 90       	pop	r0
     e30:	0f 90       	pop	r0
     e32:	cf 91       	pop	r28
     e34:	df 91       	pop	r29
     e36:	08 95       	ret

00000e38 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
     e38:	df 93       	push	r29
     e3a:	cf 93       	push	r28
     e3c:	00 d0       	rcall	.+0      	; 0xe3e <vListInsertEnd+0x6>
     e3e:	00 d0       	rcall	.+0      	; 0xe40 <vListInsertEnd+0x8>
     e40:	00 d0       	rcall	.+0      	; 0xe42 <vListInsertEnd+0xa>
     e42:	cd b7       	in	r28, 0x3d	; 61
     e44:	de b7       	in	r29, 0x3e	; 62
     e46:	9c 83       	std	Y+4, r25	; 0x04
     e48:	8b 83       	std	Y+3, r24	; 0x03
     e4a:	7e 83       	std	Y+6, r23	; 0x06
     e4c:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
     e4e:	eb 81       	ldd	r30, Y+3	; 0x03
     e50:	fc 81       	ldd	r31, Y+4	; 0x04
     e52:	81 81       	ldd	r24, Z+1	; 0x01
     e54:	92 81       	ldd	r25, Z+2	; 0x02
     e56:	9a 83       	std	Y+2, r25	; 0x02
     e58:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
     e5a:	ed 81       	ldd	r30, Y+5	; 0x05
     e5c:	fe 81       	ldd	r31, Y+6	; 0x06
     e5e:	89 81       	ldd	r24, Y+1	; 0x01
     e60:	9a 81       	ldd	r25, Y+2	; 0x02
     e62:	93 83       	std	Z+3, r25	; 0x03
     e64:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     e66:	e9 81       	ldd	r30, Y+1	; 0x01
     e68:	fa 81       	ldd	r31, Y+2	; 0x02
     e6a:	84 81       	ldd	r24, Z+4	; 0x04
     e6c:	95 81       	ldd	r25, Z+5	; 0x05
     e6e:	ed 81       	ldd	r30, Y+5	; 0x05
     e70:	fe 81       	ldd	r31, Y+6	; 0x06
     e72:	95 83       	std	Z+5, r25	; 0x05
     e74:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
     e76:	e9 81       	ldd	r30, Y+1	; 0x01
     e78:	fa 81       	ldd	r31, Y+2	; 0x02
     e7a:	04 80       	ldd	r0, Z+4	; 0x04
     e7c:	f5 81       	ldd	r31, Z+5	; 0x05
     e7e:	e0 2d       	mov	r30, r0
     e80:	8d 81       	ldd	r24, Y+5	; 0x05
     e82:	9e 81       	ldd	r25, Y+6	; 0x06
     e84:	93 83       	std	Z+3, r25	; 0x03
     e86:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
     e88:	e9 81       	ldd	r30, Y+1	; 0x01
     e8a:	fa 81       	ldd	r31, Y+2	; 0x02
     e8c:	8d 81       	ldd	r24, Y+5	; 0x05
     e8e:	9e 81       	ldd	r25, Y+6	; 0x06
     e90:	95 83       	std	Z+5, r25	; 0x05
     e92:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
     e94:	ed 81       	ldd	r30, Y+5	; 0x05
     e96:	fe 81       	ldd	r31, Y+6	; 0x06
     e98:	8b 81       	ldd	r24, Y+3	; 0x03
     e9a:	9c 81       	ldd	r25, Y+4	; 0x04
     e9c:	91 87       	std	Z+9, r25	; 0x09
     e9e:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
     ea0:	eb 81       	ldd	r30, Y+3	; 0x03
     ea2:	fc 81       	ldd	r31, Y+4	; 0x04
     ea4:	80 81       	ld	r24, Z
     ea6:	8f 5f       	subi	r24, 0xFF	; 255
     ea8:	eb 81       	ldd	r30, Y+3	; 0x03
     eaa:	fc 81       	ldd	r31, Y+4	; 0x04
     eac:	80 83       	st	Z, r24
}
     eae:	26 96       	adiw	r28, 0x06	; 6
     eb0:	0f b6       	in	r0, 0x3f	; 63
     eb2:	f8 94       	cli
     eb4:	de bf       	out	0x3e, r29	; 62
     eb6:	0f be       	out	0x3f, r0	; 63
     eb8:	cd bf       	out	0x3d, r28	; 61
     eba:	cf 91       	pop	r28
     ebc:	df 91       	pop	r29
     ebe:	08 95       	ret

00000ec0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
     ec0:	df 93       	push	r29
     ec2:	cf 93       	push	r28
     ec4:	cd b7       	in	r28, 0x3d	; 61
     ec6:	de b7       	in	r29, 0x3e	; 62
     ec8:	28 97       	sbiw	r28, 0x08	; 8
     eca:	0f b6       	in	r0, 0x3f	; 63
     ecc:	f8 94       	cli
     ece:	de bf       	out	0x3e, r29	; 62
     ed0:	0f be       	out	0x3f, r0	; 63
     ed2:	cd bf       	out	0x3d, r28	; 61
     ed4:	9e 83       	std	Y+6, r25	; 0x06
     ed6:	8d 83       	std	Y+5, r24	; 0x05
     ed8:	78 87       	std	Y+8, r23	; 0x08
     eda:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     edc:	ef 81       	ldd	r30, Y+7	; 0x07
     ede:	f8 85       	ldd	r31, Y+8	; 0x08
     ee0:	80 81       	ld	r24, Z
     ee2:	91 81       	ldd	r25, Z+1	; 0x01
     ee4:	9a 83       	std	Y+2, r25	; 0x02
     ee6:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
     ee8:	89 81       	ldd	r24, Y+1	; 0x01
     eea:	9a 81       	ldd	r25, Y+2	; 0x02
     eec:	2f ef       	ldi	r18, 0xFF	; 255
     eee:	8f 3f       	cpi	r24, 0xFF	; 255
     ef0:	92 07       	cpc	r25, r18
     ef2:	39 f4       	brne	.+14     	; 0xf02 <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
     ef4:	ed 81       	ldd	r30, Y+5	; 0x05
     ef6:	fe 81       	ldd	r31, Y+6	; 0x06
     ef8:	87 81       	ldd	r24, Z+7	; 0x07
     efa:	90 85       	ldd	r25, Z+8	; 0x08
     efc:	9c 83       	std	Y+4, r25	; 0x04
     efe:	8b 83       	std	Y+3, r24	; 0x03
     f00:	18 c0       	rjmp	.+48     	; 0xf32 <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     f02:	8d 81       	ldd	r24, Y+5	; 0x05
     f04:	9e 81       	ldd	r25, Y+6	; 0x06
     f06:	03 96       	adiw	r24, 0x03	; 3
     f08:	9c 83       	std	Y+4, r25	; 0x04
     f0a:	8b 83       	std	Y+3, r24	; 0x03
     f0c:	06 c0       	rjmp	.+12     	; 0xf1a <vListInsert+0x5a>
     f0e:	eb 81       	ldd	r30, Y+3	; 0x03
     f10:	fc 81       	ldd	r31, Y+4	; 0x04
     f12:	82 81       	ldd	r24, Z+2	; 0x02
     f14:	93 81       	ldd	r25, Z+3	; 0x03
     f16:	9c 83       	std	Y+4, r25	; 0x04
     f18:	8b 83       	std	Y+3, r24	; 0x03
     f1a:	eb 81       	ldd	r30, Y+3	; 0x03
     f1c:	fc 81       	ldd	r31, Y+4	; 0x04
     f1e:	02 80       	ldd	r0, Z+2	; 0x02
     f20:	f3 81       	ldd	r31, Z+3	; 0x03
     f22:	e0 2d       	mov	r30, r0
     f24:	20 81       	ld	r18, Z
     f26:	31 81       	ldd	r19, Z+1	; 0x01
     f28:	89 81       	ldd	r24, Y+1	; 0x01
     f2a:	9a 81       	ldd	r25, Y+2	; 0x02
     f2c:	82 17       	cp	r24, r18
     f2e:	93 07       	cpc	r25, r19
     f30:	70 f7       	brcc	.-36     	; 0xf0e <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
     f32:	eb 81       	ldd	r30, Y+3	; 0x03
     f34:	fc 81       	ldd	r31, Y+4	; 0x04
     f36:	82 81       	ldd	r24, Z+2	; 0x02
     f38:	93 81       	ldd	r25, Z+3	; 0x03
     f3a:	ef 81       	ldd	r30, Y+7	; 0x07
     f3c:	f8 85       	ldd	r31, Y+8	; 0x08
     f3e:	93 83       	std	Z+3, r25	; 0x03
     f40:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     f42:	ef 81       	ldd	r30, Y+7	; 0x07
     f44:	f8 85       	ldd	r31, Y+8	; 0x08
     f46:	02 80       	ldd	r0, Z+2	; 0x02
     f48:	f3 81       	ldd	r31, Z+3	; 0x03
     f4a:	e0 2d       	mov	r30, r0
     f4c:	8f 81       	ldd	r24, Y+7	; 0x07
     f4e:	98 85       	ldd	r25, Y+8	; 0x08
     f50:	95 83       	std	Z+5, r25	; 0x05
     f52:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
     f54:	ef 81       	ldd	r30, Y+7	; 0x07
     f56:	f8 85       	ldd	r31, Y+8	; 0x08
     f58:	8b 81       	ldd	r24, Y+3	; 0x03
     f5a:	9c 81       	ldd	r25, Y+4	; 0x04
     f5c:	95 83       	std	Z+5, r25	; 0x05
     f5e:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
     f60:	eb 81       	ldd	r30, Y+3	; 0x03
     f62:	fc 81       	ldd	r31, Y+4	; 0x04
     f64:	8f 81       	ldd	r24, Y+7	; 0x07
     f66:	98 85       	ldd	r25, Y+8	; 0x08
     f68:	93 83       	std	Z+3, r25	; 0x03
     f6a:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
     f6c:	ef 81       	ldd	r30, Y+7	; 0x07
     f6e:	f8 85       	ldd	r31, Y+8	; 0x08
     f70:	8d 81       	ldd	r24, Y+5	; 0x05
     f72:	9e 81       	ldd	r25, Y+6	; 0x06
     f74:	91 87       	std	Z+9, r25	; 0x09
     f76:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
     f78:	ed 81       	ldd	r30, Y+5	; 0x05
     f7a:	fe 81       	ldd	r31, Y+6	; 0x06
     f7c:	80 81       	ld	r24, Z
     f7e:	8f 5f       	subi	r24, 0xFF	; 255
     f80:	ed 81       	ldd	r30, Y+5	; 0x05
     f82:	fe 81       	ldd	r31, Y+6	; 0x06
     f84:	80 83       	st	Z, r24
}
     f86:	28 96       	adiw	r28, 0x08	; 8
     f88:	0f b6       	in	r0, 0x3f	; 63
     f8a:	f8 94       	cli
     f8c:	de bf       	out	0x3e, r29	; 62
     f8e:	0f be       	out	0x3f, r0	; 63
     f90:	cd bf       	out	0x3d, r28	; 61
     f92:	cf 91       	pop	r28
     f94:	df 91       	pop	r29
     f96:	08 95       	ret

00000f98 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     f98:	df 93       	push	r29
     f9a:	cf 93       	push	r28
     f9c:	00 d0       	rcall	.+0      	; 0xf9e <uxListRemove+0x6>
     f9e:	00 d0       	rcall	.+0      	; 0xfa0 <uxListRemove+0x8>
     fa0:	cd b7       	in	r28, 0x3d	; 61
     fa2:	de b7       	in	r29, 0x3e	; 62
     fa4:	9c 83       	std	Y+4, r25	; 0x04
     fa6:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
     fa8:	eb 81       	ldd	r30, Y+3	; 0x03
     faa:	fc 81       	ldd	r31, Y+4	; 0x04
     fac:	80 85       	ldd	r24, Z+8	; 0x08
     fae:	91 85       	ldd	r25, Z+9	; 0x09
     fb0:	9a 83       	std	Y+2, r25	; 0x02
     fb2:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     fb4:	eb 81       	ldd	r30, Y+3	; 0x03
     fb6:	fc 81       	ldd	r31, Y+4	; 0x04
     fb8:	a2 81       	ldd	r26, Z+2	; 0x02
     fba:	b3 81       	ldd	r27, Z+3	; 0x03
     fbc:	eb 81       	ldd	r30, Y+3	; 0x03
     fbe:	fc 81       	ldd	r31, Y+4	; 0x04
     fc0:	84 81       	ldd	r24, Z+4	; 0x04
     fc2:	95 81       	ldd	r25, Z+5	; 0x05
     fc4:	15 96       	adiw	r26, 0x05	; 5
     fc6:	9c 93       	st	X, r25
     fc8:	8e 93       	st	-X, r24
     fca:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     fcc:	eb 81       	ldd	r30, Y+3	; 0x03
     fce:	fc 81       	ldd	r31, Y+4	; 0x04
     fd0:	a4 81       	ldd	r26, Z+4	; 0x04
     fd2:	b5 81       	ldd	r27, Z+5	; 0x05
     fd4:	eb 81       	ldd	r30, Y+3	; 0x03
     fd6:	fc 81       	ldd	r31, Y+4	; 0x04
     fd8:	82 81       	ldd	r24, Z+2	; 0x02
     fda:	93 81       	ldd	r25, Z+3	; 0x03
     fdc:	13 96       	adiw	r26, 0x03	; 3
     fde:	9c 93       	st	X, r25
     fe0:	8e 93       	st	-X, r24
     fe2:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
     fe4:	e9 81       	ldd	r30, Y+1	; 0x01
     fe6:	fa 81       	ldd	r31, Y+2	; 0x02
     fe8:	21 81       	ldd	r18, Z+1	; 0x01
     fea:	32 81       	ldd	r19, Z+2	; 0x02
     fec:	8b 81       	ldd	r24, Y+3	; 0x03
     fee:	9c 81       	ldd	r25, Y+4	; 0x04
     ff0:	28 17       	cp	r18, r24
     ff2:	39 07       	cpc	r19, r25
     ff4:	41 f4       	brne	.+16     	; 0x1006 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
     ff6:	eb 81       	ldd	r30, Y+3	; 0x03
     ff8:	fc 81       	ldd	r31, Y+4	; 0x04
     ffa:	84 81       	ldd	r24, Z+4	; 0x04
     ffc:	95 81       	ldd	r25, Z+5	; 0x05
     ffe:	e9 81       	ldd	r30, Y+1	; 0x01
    1000:	fa 81       	ldd	r31, Y+2	; 0x02
    1002:	92 83       	std	Z+2, r25	; 0x02
    1004:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    1006:	eb 81       	ldd	r30, Y+3	; 0x03
    1008:	fc 81       	ldd	r31, Y+4	; 0x04
    100a:	11 86       	std	Z+9, r1	; 0x09
    100c:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    100e:	e9 81       	ldd	r30, Y+1	; 0x01
    1010:	fa 81       	ldd	r31, Y+2	; 0x02
    1012:	80 81       	ld	r24, Z
    1014:	81 50       	subi	r24, 0x01	; 1
    1016:	e9 81       	ldd	r30, Y+1	; 0x01
    1018:	fa 81       	ldd	r31, Y+2	; 0x02
    101a:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    101c:	e9 81       	ldd	r30, Y+1	; 0x01
    101e:	fa 81       	ldd	r31, Y+2	; 0x02
    1020:	80 81       	ld	r24, Z
}
    1022:	0f 90       	pop	r0
    1024:	0f 90       	pop	r0
    1026:	0f 90       	pop	r0
    1028:	0f 90       	pop	r0
    102a:	cf 91       	pop	r28
    102c:	df 91       	pop	r29
    102e:	08 95       	ret

00001030 <xQueueGenericReset>:
    }
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    1030:	df 93       	push	r29
    1032:	cf 93       	push	r28
    1034:	00 d0       	rcall	.+0      	; 0x1036 <xQueueGenericReset+0x6>
    1036:	00 d0       	rcall	.+0      	; 0x1038 <xQueueGenericReset+0x8>
    1038:	00 d0       	rcall	.+0      	; 0x103a <xQueueGenericReset+0xa>
    103a:	cd b7       	in	r28, 0x3d	; 61
    103c:	de b7       	in	r29, 0x3e	; 62
    103e:	9d 83       	std	Y+5, r25	; 0x05
    1040:	8c 83       	std	Y+4, r24	; 0x04
    1042:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    1044:	81 e0       	ldi	r24, 0x01	; 1
    1046:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    1048:	8c 81       	ldd	r24, Y+4	; 0x04
    104a:	9d 81       	ldd	r25, Y+5	; 0x05
    104c:	9a 83       	std	Y+2, r25	; 0x02
    104e:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    1050:	89 81       	ldd	r24, Y+1	; 0x01
    1052:	9a 81       	ldd	r25, Y+2	; 0x02
    1054:	00 97       	sbiw	r24, 0x00	; 0
    1056:	09 f4       	brne	.+2      	; 0x105a <xQueueGenericReset+0x2a>
    1058:	8b c0       	rjmp	.+278    	; 0x1170 <xQueueGenericReset+0x140>
    105a:	e9 81       	ldd	r30, Y+1	; 0x01
    105c:	fa 81       	ldd	r31, Y+2	; 0x02
    105e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1060:	88 23       	and	r24, r24
    1062:	09 f4       	brne	.+2      	; 0x1066 <xQueueGenericReset+0x36>
    1064:	85 c0       	rjmp	.+266    	; 0x1170 <xQueueGenericReset+0x140>
    1066:	e9 81       	ldd	r30, Y+1	; 0x01
    1068:	fa 81       	ldd	r31, Y+2	; 0x02
    106a:	83 8d       	ldd	r24, Z+27	; 0x1b
    106c:	28 2f       	mov	r18, r24
    106e:	30 e0       	ldi	r19, 0x00	; 0
    1070:	8f ef       	ldi	r24, 0xFF	; 255
    1072:	9f e7       	ldi	r25, 0x7F	; 127
    1074:	b9 01       	movw	r22, r18
    1076:	0e 94 07 32 	call	0x640e	; 0x640e <__udivmodhi4>
    107a:	cb 01       	movw	r24, r22
    107c:	9c 01       	movw	r18, r24
    107e:	e9 81       	ldd	r30, Y+1	; 0x01
    1080:	fa 81       	ldd	r31, Y+2	; 0x02
    1082:	84 8d       	ldd	r24, Z+28	; 0x1c
    1084:	88 2f       	mov	r24, r24
    1086:	90 e0       	ldi	r25, 0x00	; 0
    1088:	28 17       	cp	r18, r24
    108a:	39 07       	cpc	r19, r25
    108c:	08 f4       	brcc	.+2      	; 0x1090 <xQueueGenericReset+0x60>
    108e:	70 c0       	rjmp	.+224    	; 0x1170 <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    1090:	0f b6       	in	r0, 0x3f	; 63
    1092:	f8 94       	cli
    1094:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1096:	e9 81       	ldd	r30, Y+1	; 0x01
    1098:	fa 81       	ldd	r31, Y+2	; 0x02
    109a:	40 81       	ld	r20, Z
    109c:	51 81       	ldd	r21, Z+1	; 0x01
    109e:	e9 81       	ldd	r30, Y+1	; 0x01
    10a0:	fa 81       	ldd	r31, Y+2	; 0x02
    10a2:	83 8d       	ldd	r24, Z+27	; 0x1b
    10a4:	28 2f       	mov	r18, r24
    10a6:	30 e0       	ldi	r19, 0x00	; 0
    10a8:	e9 81       	ldd	r30, Y+1	; 0x01
    10aa:	fa 81       	ldd	r31, Y+2	; 0x02
    10ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    10ae:	88 2f       	mov	r24, r24
    10b0:	90 e0       	ldi	r25, 0x00	; 0
    10b2:	bc 01       	movw	r22, r24
    10b4:	26 9f       	mul	r18, r22
    10b6:	c0 01       	movw	r24, r0
    10b8:	27 9f       	mul	r18, r23
    10ba:	90 0d       	add	r25, r0
    10bc:	36 9f       	mul	r19, r22
    10be:	90 0d       	add	r25, r0
    10c0:	11 24       	eor	r1, r1
    10c2:	84 0f       	add	r24, r20
    10c4:	95 1f       	adc	r25, r21
    10c6:	e9 81       	ldd	r30, Y+1	; 0x01
    10c8:	fa 81       	ldd	r31, Y+2	; 0x02
    10ca:	95 83       	std	Z+5, r25	; 0x05
    10cc:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    10ce:	e9 81       	ldd	r30, Y+1	; 0x01
    10d0:	fa 81       	ldd	r31, Y+2	; 0x02
    10d2:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    10d4:	e9 81       	ldd	r30, Y+1	; 0x01
    10d6:	fa 81       	ldd	r31, Y+2	; 0x02
    10d8:	80 81       	ld	r24, Z
    10da:	91 81       	ldd	r25, Z+1	; 0x01
    10dc:	e9 81       	ldd	r30, Y+1	; 0x01
    10de:	fa 81       	ldd	r31, Y+2	; 0x02
    10e0:	93 83       	std	Z+3, r25	; 0x03
    10e2:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    10e4:	e9 81       	ldd	r30, Y+1	; 0x01
    10e6:	fa 81       	ldd	r31, Y+2	; 0x02
    10e8:	40 81       	ld	r20, Z
    10ea:	51 81       	ldd	r21, Z+1	; 0x01
    10ec:	e9 81       	ldd	r30, Y+1	; 0x01
    10ee:	fa 81       	ldd	r31, Y+2	; 0x02
    10f0:	83 8d       	ldd	r24, Z+27	; 0x1b
    10f2:	88 2f       	mov	r24, r24
    10f4:	90 e0       	ldi	r25, 0x00	; 0
    10f6:	9c 01       	movw	r18, r24
    10f8:	21 50       	subi	r18, 0x01	; 1
    10fa:	30 40       	sbci	r19, 0x00	; 0
    10fc:	e9 81       	ldd	r30, Y+1	; 0x01
    10fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1100:	84 8d       	ldd	r24, Z+28	; 0x1c
    1102:	88 2f       	mov	r24, r24
    1104:	90 e0       	ldi	r25, 0x00	; 0
    1106:	bc 01       	movw	r22, r24
    1108:	26 9f       	mul	r18, r22
    110a:	c0 01       	movw	r24, r0
    110c:	27 9f       	mul	r18, r23
    110e:	90 0d       	add	r25, r0
    1110:	36 9f       	mul	r19, r22
    1112:	90 0d       	add	r25, r0
    1114:	11 24       	eor	r1, r1
    1116:	84 0f       	add	r24, r20
    1118:	95 1f       	adc	r25, r21
    111a:	e9 81       	ldd	r30, Y+1	; 0x01
    111c:	fa 81       	ldd	r31, Y+2	; 0x02
    111e:	97 83       	std	Z+7, r25	; 0x07
    1120:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    1122:	e9 81       	ldd	r30, Y+1	; 0x01
    1124:	fa 81       	ldd	r31, Y+2	; 0x02
    1126:	8f ef       	ldi	r24, 0xFF	; 255
    1128:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    112a:	e9 81       	ldd	r30, Y+1	; 0x01
    112c:	fa 81       	ldd	r31, Y+2	; 0x02
    112e:	8f ef       	ldi	r24, 0xFF	; 255
    1130:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    1132:	8e 81       	ldd	r24, Y+6	; 0x06
    1134:	88 23       	and	r24, r24
    1136:	79 f4       	brne	.+30     	; 0x1156 <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1138:	e9 81       	ldd	r30, Y+1	; 0x01
    113a:	fa 81       	ldd	r31, Y+2	; 0x02
    113c:	80 85       	ldd	r24, Z+8	; 0x08
    113e:	88 23       	and	r24, r24
    1140:	a1 f0       	breq	.+40     	; 0x116a <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1142:	89 81       	ldd	r24, Y+1	; 0x01
    1144:	9a 81       	ldd	r25, Y+2	; 0x02
    1146:	08 96       	adiw	r24, 0x08	; 8
    1148:	0e 94 ec 1f 	call	0x3fd8	; 0x3fd8 <xTaskRemoveFromEventList>
    114c:	88 23       	and	r24, r24
    114e:	69 f0       	breq	.+26     	; 0x116a <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1150:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    1154:	0a c0       	rjmp	.+20     	; 0x116a <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1156:	89 81       	ldd	r24, Y+1	; 0x01
    1158:	9a 81       	ldd	r25, Y+2	; 0x02
    115a:	08 96       	adiw	r24, 0x08	; 8
    115c:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1160:	89 81       	ldd	r24, Y+1	; 0x01
    1162:	9a 81       	ldd	r25, Y+2	; 0x02
    1164:	41 96       	adiw	r24, 0x11	; 17
    1166:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    116a:	0f 90       	pop	r0
    116c:	0f be       	out	0x3f, r0	; 63
    116e:	01 c0       	rjmp	.+2      	; 0x1172 <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    1170:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    1172:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1174:	26 96       	adiw	r28, 0x06	; 6
    1176:	0f b6       	in	r0, 0x3f	; 63
    1178:	f8 94       	cli
    117a:	de bf       	out	0x3e, r29	; 62
    117c:	0f be       	out	0x3f, r0	; 63
    117e:	cd bf       	out	0x3d, r28	; 61
    1180:	cf 91       	pop	r28
    1182:	df 91       	pop	r29
    1184:	08 95       	ret

00001186 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    1186:	0f 93       	push	r16
    1188:	1f 93       	push	r17
    118a:	df 93       	push	r29
    118c:	cf 93       	push	r28
    118e:	cd b7       	in	r28, 0x3d	; 61
    1190:	de b7       	in	r29, 0x3e	; 62
    1192:	29 97       	sbiw	r28, 0x09	; 9
    1194:	0f b6       	in	r0, 0x3f	; 63
    1196:	f8 94       	cli
    1198:	de bf       	out	0x3e, r29	; 62
    119a:	0f be       	out	0x3f, r0	; 63
    119c:	cd bf       	out	0x3d, r28	; 61
    119e:	8f 83       	std	Y+7, r24	; 0x07
    11a0:	68 87       	std	Y+8, r22	; 0x08
    11a2:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    11a4:	1e 82       	std	Y+6, r1	; 0x06
    11a6:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    11a8:	8f 81       	ldd	r24, Y+7	; 0x07
    11aa:	88 23       	and	r24, r24
    11ac:	09 f4       	brne	.+2      	; 0x11b0 <xQueueGenericCreate+0x2a>
    11ae:	52 c0       	rjmp	.+164    	; 0x1254 <xQueueGenericCreate+0xce>
    11b0:	8f 81       	ldd	r24, Y+7	; 0x07
    11b2:	28 2f       	mov	r18, r24
    11b4:	30 e0       	ldi	r19, 0x00	; 0
    11b6:	8f ef       	ldi	r24, 0xFF	; 255
    11b8:	9f e7       	ldi	r25, 0x7F	; 127
    11ba:	b9 01       	movw	r22, r18
    11bc:	0e 94 07 32 	call	0x640e	; 0x640e <__udivmodhi4>
    11c0:	cb 01       	movw	r24, r22
    11c2:	9c 01       	movw	r18, r24
    11c4:	88 85       	ldd	r24, Y+8	; 0x08
    11c6:	88 2f       	mov	r24, r24
    11c8:	90 e0       	ldi	r25, 0x00	; 0
    11ca:	28 17       	cp	r18, r24
    11cc:	39 07       	cpc	r19, r25
    11ce:	08 f4       	brcc	.+2      	; 0x11d2 <xQueueGenericCreate+0x4c>
    11d0:	41 c0       	rjmp	.+130    	; 0x1254 <xQueueGenericCreate+0xce>
    11d2:	8f 81       	ldd	r24, Y+7	; 0x07
    11d4:	28 2f       	mov	r18, r24
    11d6:	30 e0       	ldi	r19, 0x00	; 0
    11d8:	88 85       	ldd	r24, Y+8	; 0x08
    11da:	88 2f       	mov	r24, r24
    11dc:	90 e0       	ldi	r25, 0x00	; 0
    11de:	ac 01       	movw	r20, r24
    11e0:	24 9f       	mul	r18, r20
    11e2:	c0 01       	movw	r24, r0
    11e4:	25 9f       	mul	r18, r21
    11e6:	90 0d       	add	r25, r0
    11e8:	34 9f       	mul	r19, r20
    11ea:	90 0d       	add	r25, r0
    11ec:	11 24       	eor	r1, r1
    11ee:	5f e7       	ldi	r21, 0x7F	; 127
    11f0:	81 3e       	cpi	r24, 0xE1	; 225
    11f2:	95 07       	cpc	r25, r21
    11f4:	78 f5       	brcc	.+94     	; 0x1254 <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    11f6:	8f 81       	ldd	r24, Y+7	; 0x07
    11f8:	28 2f       	mov	r18, r24
    11fa:	30 e0       	ldi	r19, 0x00	; 0
    11fc:	88 85       	ldd	r24, Y+8	; 0x08
    11fe:	88 2f       	mov	r24, r24
    1200:	90 e0       	ldi	r25, 0x00	; 0
    1202:	ac 01       	movw	r20, r24
    1204:	24 9f       	mul	r18, r20
    1206:	c0 01       	movw	r24, r0
    1208:	25 9f       	mul	r18, r21
    120a:	90 0d       	add	r25, r0
    120c:	34 9f       	mul	r19, r20
    120e:	90 0d       	add	r25, r0
    1210:	11 24       	eor	r1, r1
    1212:	9c 83       	std	Y+4, r25	; 0x04
    1214:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1216:	8b 81       	ldd	r24, Y+3	; 0x03
    1218:	9c 81       	ldd	r25, Y+4	; 0x04
    121a:	4f 96       	adiw	r24, 0x1f	; 31
    121c:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    1220:	9e 83       	std	Y+6, r25	; 0x06
    1222:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    1224:	8d 81       	ldd	r24, Y+5	; 0x05
    1226:	9e 81       	ldd	r25, Y+6	; 0x06
    1228:	00 97       	sbiw	r24, 0x00	; 0
    122a:	a1 f0       	breq	.+40     	; 0x1254 <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    122c:	8d 81       	ldd	r24, Y+5	; 0x05
    122e:	9e 81       	ldd	r25, Y+6	; 0x06
    1230:	9a 83       	std	Y+2, r25	; 0x02
    1232:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1234:	89 81       	ldd	r24, Y+1	; 0x01
    1236:	9a 81       	ldd	r25, Y+2	; 0x02
    1238:	4f 96       	adiw	r24, 0x1f	; 31
    123a:	9a 83       	std	Y+2, r25	; 0x02
    123c:	89 83       	std	Y+1, r24	; 0x01
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    123e:	29 81       	ldd	r18, Y+1	; 0x01
    1240:	3a 81       	ldd	r19, Y+2	; 0x02
    1242:	ed 81       	ldd	r30, Y+5	; 0x05
    1244:	fe 81       	ldd	r31, Y+6	; 0x06
    1246:	8f 81       	ldd	r24, Y+7	; 0x07
    1248:	68 85       	ldd	r22, Y+8	; 0x08
    124a:	a9 01       	movw	r20, r18
    124c:	29 85       	ldd	r18, Y+9	; 0x09
    124e:	8f 01       	movw	r16, r30
    1250:	0e 94 37 09 	call	0x126e	; 0x126e <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    1254:	8d 81       	ldd	r24, Y+5	; 0x05
    1256:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    1258:	29 96       	adiw	r28, 0x09	; 9
    125a:	0f b6       	in	r0, 0x3f	; 63
    125c:	f8 94       	cli
    125e:	de bf       	out	0x3e, r29	; 62
    1260:	0f be       	out	0x3f, r0	; 63
    1262:	cd bf       	out	0x3d, r28	; 61
    1264:	cf 91       	pop	r28
    1266:	df 91       	pop	r29
    1268:	1f 91       	pop	r17
    126a:	0f 91       	pop	r16
    126c:	08 95       	ret

0000126e <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    126e:	0f 93       	push	r16
    1270:	1f 93       	push	r17
    1272:	df 93       	push	r29
    1274:	cf 93       	push	r28
    1276:	cd b7       	in	r28, 0x3d	; 61
    1278:	de b7       	in	r29, 0x3e	; 62
    127a:	27 97       	sbiw	r28, 0x07	; 7
    127c:	0f b6       	in	r0, 0x3f	; 63
    127e:	f8 94       	cli
    1280:	de bf       	out	0x3e, r29	; 62
    1282:	0f be       	out	0x3f, r0	; 63
    1284:	cd bf       	out	0x3d, r28	; 61
    1286:	89 83       	std	Y+1, r24	; 0x01
    1288:	6a 83       	std	Y+2, r22	; 0x02
    128a:	5c 83       	std	Y+4, r21	; 0x04
    128c:	4b 83       	std	Y+3, r20	; 0x03
    128e:	2d 83       	std	Y+5, r18	; 0x05
    1290:	1f 83       	std	Y+7, r17	; 0x07
    1292:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    1294:	8a 81       	ldd	r24, Y+2	; 0x02
    1296:	88 23       	and	r24, r24
    1298:	39 f4       	brne	.+14     	; 0x12a8 <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    129a:	8e 81       	ldd	r24, Y+6	; 0x06
    129c:	9f 81       	ldd	r25, Y+7	; 0x07
    129e:	ee 81       	ldd	r30, Y+6	; 0x06
    12a0:	ff 81       	ldd	r31, Y+7	; 0x07
    12a2:	91 83       	std	Z+1, r25	; 0x01
    12a4:	80 83       	st	Z, r24
    12a6:	06 c0       	rjmp	.+12     	; 0x12b4 <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    12a8:	8b 81       	ldd	r24, Y+3	; 0x03
    12aa:	9c 81       	ldd	r25, Y+4	; 0x04
    12ac:	ee 81       	ldd	r30, Y+6	; 0x06
    12ae:	ff 81       	ldd	r31, Y+7	; 0x07
    12b0:	91 83       	std	Z+1, r25	; 0x01
    12b2:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    12b4:	ee 81       	ldd	r30, Y+6	; 0x06
    12b6:	ff 81       	ldd	r31, Y+7	; 0x07
    12b8:	89 81       	ldd	r24, Y+1	; 0x01
    12ba:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    12bc:	ee 81       	ldd	r30, Y+6	; 0x06
    12be:	ff 81       	ldd	r31, Y+7	; 0x07
    12c0:	8a 81       	ldd	r24, Y+2	; 0x02
    12c2:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    12c4:	8e 81       	ldd	r24, Y+6	; 0x06
    12c6:	9f 81       	ldd	r25, Y+7	; 0x07
    12c8:	61 e0       	ldi	r22, 0x01	; 1
    12ca:	0e 94 18 08 	call	0x1030	; 0x1030 <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
    }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    12ce:	27 96       	adiw	r28, 0x07	; 7
    12d0:	0f b6       	in	r0, 0x3f	; 63
    12d2:	f8 94       	cli
    12d4:	de bf       	out	0x3e, r29	; 62
    12d6:	0f be       	out	0x3f, r0	; 63
    12d8:	cd bf       	out	0x3d, r28	; 61
    12da:	cf 91       	pop	r28
    12dc:	df 91       	pop	r29
    12de:	1f 91       	pop	r17
    12e0:	0f 91       	pop	r16
    12e2:	08 95       	ret

000012e4 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    12e4:	df 93       	push	r29
    12e6:	cf 93       	push	r28
    12e8:	cd b7       	in	r28, 0x3d	; 61
    12ea:	de b7       	in	r29, 0x3e	; 62
    12ec:	2f 97       	sbiw	r28, 0x0f	; 15
    12ee:	0f b6       	in	r0, 0x3f	; 63
    12f0:	f8 94       	cli
    12f2:	de bf       	out	0x3e, r29	; 62
    12f4:	0f be       	out	0x3f, r0	; 63
    12f6:	cd bf       	out	0x3d, r28	; 61
    12f8:	99 87       	std	Y+9, r25	; 0x09
    12fa:	88 87       	std	Y+8, r24	; 0x08
    12fc:	7b 87       	std	Y+11, r23	; 0x0b
    12fe:	6a 87       	std	Y+10, r22	; 0x0a
    1300:	5d 87       	std	Y+13, r21	; 0x0d
    1302:	4c 87       	std	Y+12, r20	; 0x0c
    1304:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1306:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    1308:	88 85       	ldd	r24, Y+8	; 0x08
    130a:	99 85       	ldd	r25, Y+9	; 0x09
    130c:	9a 83       	std	Y+2, r25	; 0x02
    130e:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1310:	0f b6       	in	r0, 0x3f	; 63
    1312:	f8 94       	cli
    1314:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1316:	e9 81       	ldd	r30, Y+1	; 0x01
    1318:	fa 81       	ldd	r31, Y+2	; 0x02
    131a:	92 8d       	ldd	r25, Z+26	; 0x1a
    131c:	e9 81       	ldd	r30, Y+1	; 0x01
    131e:	fa 81       	ldd	r31, Y+2	; 0x02
    1320:	83 8d       	ldd	r24, Z+27	; 0x1b
    1322:	98 17       	cp	r25, r24
    1324:	18 f0       	brcs	.+6      	; 0x132c <xQueueGenericSend+0x48>
    1326:	8e 85       	ldd	r24, Y+14	; 0x0e
    1328:	82 30       	cpi	r24, 0x02	; 2
    132a:	11 f5       	brne	.+68     	; 0x1370 <xQueueGenericSend+0x8c>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    132c:	89 81       	ldd	r24, Y+1	; 0x01
    132e:	9a 81       	ldd	r25, Y+2	; 0x02
    1330:	2a 85       	ldd	r18, Y+10	; 0x0a
    1332:	3b 85       	ldd	r19, Y+11	; 0x0b
    1334:	b9 01       	movw	r22, r18
    1336:	4e 85       	ldd	r20, Y+14	; 0x0e
    1338:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <prvCopyDataToQueue>
    133c:	8b 83       	std	Y+3, r24	; 0x03

                    /* If there was a task waiting for data to arrive on the
                     * queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    133e:	e9 81       	ldd	r30, Y+1	; 0x01
    1340:	fa 81       	ldd	r31, Y+2	; 0x02
    1342:	81 89       	ldd	r24, Z+17	; 0x11
    1344:	88 23       	and	r24, r24
    1346:	51 f0       	breq	.+20     	; 0x135c <xQueueGenericSend+0x78>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1348:	89 81       	ldd	r24, Y+1	; 0x01
    134a:	9a 81       	ldd	r25, Y+2	; 0x02
    134c:	41 96       	adiw	r24, 0x11	; 17
    134e:	0e 94 ec 1f 	call	0x3fd8	; 0x3fd8 <xTaskRemoveFromEventList>
    1352:	88 23       	and	r24, r24
    1354:	41 f0       	breq	.+16     	; 0x1366 <xQueueGenericSend+0x82>
                        {
                            /* The unblocked task has a priority higher than
                             * our own so yield immediately.  Yes it is ok to do
                             * this from within the critical section - the kernel
                             * takes care of that. */
                            queueYIELD_IF_USING_PREEMPTION();
    1356:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    135a:	05 c0       	rjmp	.+10     	; 0x1366 <xQueueGenericSend+0x82>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
    135c:	8b 81       	ldd	r24, Y+3	; 0x03
    135e:	88 23       	and	r24, r24
    1360:	11 f0       	breq	.+4      	; 0x1366 <xQueueGenericSend+0x82>
                    {
                        /* This path is a special case that will only get
                         * executed if the task was holding multiple mutexes and
                         * the mutexes were given back in an order that is
                         * different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
    1362:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    1366:	0f 90       	pop	r0
    1368:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    136a:	81 e0       	ldi	r24, 0x01	; 1
    136c:	8f 87       	std	Y+15, r24	; 0x0f
    136e:	5c c0       	rjmp	.+184    	; 0x1428 <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1370:	8c 85       	ldd	r24, Y+12	; 0x0c
    1372:	9d 85       	ldd	r25, Y+13	; 0x0d
    1374:	00 97       	sbiw	r24, 0x00	; 0
    1376:	21 f4       	brne	.+8      	; 0x1380 <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1378:	0f 90       	pop	r0
    137a:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    137c:	1f 86       	std	Y+15, r1	; 0x0f
    137e:	54 c0       	rjmp	.+168    	; 0x1428 <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    1380:	8c 81       	ldd	r24, Y+4	; 0x04
    1382:	88 23       	and	r24, r24
    1384:	31 f4       	brne	.+12     	; 0x1392 <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1386:	ce 01       	movw	r24, r28
    1388:	05 96       	adiw	r24, 0x05	; 5
    138a:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    138e:	81 e0       	ldi	r24, 0x01	; 1
    1390:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1392:	0f 90       	pop	r0
    1394:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1396:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    139a:	0f b6       	in	r0, 0x3f	; 63
    139c:	f8 94       	cli
    139e:	0f 92       	push	r0
    13a0:	e9 81       	ldd	r30, Y+1	; 0x01
    13a2:	fa 81       	ldd	r31, Y+2	; 0x02
    13a4:	85 8d       	ldd	r24, Z+29	; 0x1d
    13a6:	8f 3f       	cpi	r24, 0xFF	; 255
    13a8:	19 f4       	brne	.+6      	; 0x13b0 <xQueueGenericSend+0xcc>
    13aa:	e9 81       	ldd	r30, Y+1	; 0x01
    13ac:	fa 81       	ldd	r31, Y+2	; 0x02
    13ae:	15 8e       	std	Z+29, r1	; 0x1d
    13b0:	e9 81       	ldd	r30, Y+1	; 0x01
    13b2:	fa 81       	ldd	r31, Y+2	; 0x02
    13b4:	86 8d       	ldd	r24, Z+30	; 0x1e
    13b6:	8f 3f       	cpi	r24, 0xFF	; 255
    13b8:	19 f4       	brne	.+6      	; 0x13c0 <xQueueGenericSend+0xdc>
    13ba:	e9 81       	ldd	r30, Y+1	; 0x01
    13bc:	fa 81       	ldd	r31, Y+2	; 0x02
    13be:	16 8e       	std	Z+30, r1	; 0x1e
    13c0:	0f 90       	pop	r0
    13c2:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    13c4:	ce 01       	movw	r24, r28
    13c6:	05 96       	adiw	r24, 0x05	; 5
    13c8:	9e 01       	movw	r18, r28
    13ca:	24 5f       	subi	r18, 0xF4	; 244
    13cc:	3f 4f       	sbci	r19, 0xFF	; 255
    13ce:	b9 01       	movw	r22, r18
    13d0:	0e 94 75 22 	call	0x44ea	; 0x44ea <xTaskCheckForTimeOut>
    13d4:	88 23       	and	r24, r24
    13d6:	09 f5       	brne	.+66     	; 0x141a <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    13d8:	89 81       	ldd	r24, Y+1	; 0x01
    13da:	9a 81       	ldd	r25, Y+2	; 0x02
    13dc:	0e 94 59 0f 	call	0x1eb2	; 0x1eb2 <prvIsQueueFull>
    13e0:	88 23       	and	r24, r24
    13e2:	a1 f0       	breq	.+40     	; 0x140c <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    13e4:	89 81       	ldd	r24, Y+1	; 0x01
    13e6:	9a 81       	ldd	r25, Y+2	; 0x02
    13e8:	08 96       	adiw	r24, 0x08	; 8
    13ea:	2c 85       	ldd	r18, Y+12	; 0x0c
    13ec:	3d 85       	ldd	r19, Y+13	; 0x0d
    13ee:	b9 01       	movw	r22, r18
    13f0:	0e 94 03 1f 	call	0x3e06	; 0x3e06 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    13f4:	89 81       	ldd	r24, Y+1	; 0x01
    13f6:	9a 81       	ldd	r25, Y+2	; 0x02
    13f8:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    13fc:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
    1400:	88 23       	and	r24, r24
    1402:	09 f0       	breq	.+2      	; 0x1406 <xQueueGenericSend+0x122>
    1404:	85 cf       	rjmp	.-246    	; 0x1310 <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    1406:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    140a:	82 cf       	rjmp	.-252    	; 0x1310 <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    140c:	89 81       	ldd	r24, Y+1	; 0x01
    140e:	9a 81       	ldd	r25, Y+2	; 0x02
    1410:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1414:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
    1418:	7b cf       	rjmp	.-266    	; 0x1310 <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    141a:	89 81       	ldd	r24, Y+1	; 0x01
    141c:	9a 81       	ldd	r25, Y+2	; 0x02
    141e:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1422:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    1426:	1f 86       	std	Y+15, r1	; 0x0f
    1428:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    142a:	2f 96       	adiw	r28, 0x0f	; 15
    142c:	0f b6       	in	r0, 0x3f	; 63
    142e:	f8 94       	cli
    1430:	de bf       	out	0x3e, r29	; 62
    1432:	0f be       	out	0x3f, r0	; 63
    1434:	cd bf       	out	0x3d, r28	; 61
    1436:	cf 91       	pop	r28
    1438:	df 91       	pop	r29
    143a:	08 95       	ret

0000143c <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    143c:	df 93       	push	r29
    143e:	cf 93       	push	r28
    1440:	cd b7       	in	r28, 0x3d	; 61
    1442:	de b7       	in	r29, 0x3e	; 62
    1444:	2e 97       	sbiw	r28, 0x0e	; 14
    1446:	0f b6       	in	r0, 0x3f	; 63
    1448:	f8 94       	cli
    144a:	de bf       	out	0x3e, r29	; 62
    144c:	0f be       	out	0x3f, r0	; 63
    144e:	cd bf       	out	0x3d, r28	; 61
    1450:	99 87       	std	Y+9, r25	; 0x09
    1452:	88 87       	std	Y+8, r24	; 0x08
    1454:	7b 87       	std	Y+11, r23	; 0x0b
    1456:	6a 87       	std	Y+10, r22	; 0x0a
    1458:	5d 87       	std	Y+13, r21	; 0x0d
    145a:	4c 87       	std	Y+12, r20	; 0x0c
    145c:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    145e:	88 85       	ldd	r24, Y+8	; 0x08
    1460:	99 85       	ldd	r25, Y+9	; 0x09
    1462:	9d 83       	std	Y+5, r25	; 0x05
    1464:	8c 83       	std	Y+4, r24	; 0x04
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1466:	1e 82       	std	Y+6, r1	; 0x06
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1468:	ec 81       	ldd	r30, Y+4	; 0x04
    146a:	fd 81       	ldd	r31, Y+5	; 0x05
    146c:	92 8d       	ldd	r25, Z+26	; 0x1a
    146e:	ec 81       	ldd	r30, Y+4	; 0x04
    1470:	fd 81       	ldd	r31, Y+5	; 0x05
    1472:	83 8d       	ldd	r24, Z+27	; 0x1b
    1474:	98 17       	cp	r25, r24
    1476:	18 f0       	brcs	.+6      	; 0x147e <xQueueGenericSendFromISR+0x42>
    1478:	8e 85       	ldd	r24, Y+14	; 0x0e
    147a:	82 30       	cpi	r24, 0x02	; 2
    147c:	b9 f5       	brne	.+110    	; 0x14ec <xQueueGenericSendFromISR+0xb0>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    147e:	ec 81       	ldd	r30, Y+4	; 0x04
    1480:	fd 81       	ldd	r31, Y+5	; 0x05
    1482:	86 8d       	ldd	r24, Z+30	; 0x1e
    1484:	8b 83       	std	Y+3, r24	; 0x03
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    1486:	ec 81       	ldd	r30, Y+4	; 0x04
    1488:	fd 81       	ldd	r31, Y+5	; 0x05
    148a:	82 8d       	ldd	r24, Z+26	; 0x1a
    148c:	8a 83       	std	Y+2, r24	; 0x02
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    148e:	8c 81       	ldd	r24, Y+4	; 0x04
    1490:	9d 81       	ldd	r25, Y+5	; 0x05
    1492:	2a 85       	ldd	r18, Y+10	; 0x0a
    1494:	3b 85       	ldd	r19, Y+11	; 0x0b
    1496:	b9 01       	movw	r22, r18
    1498:	4e 85       	ldd	r20, Y+14	; 0x0e
    149a:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    149e:	8b 81       	ldd	r24, Y+3	; 0x03
    14a0:	8f 3f       	cpi	r24, 0xFF	; 255
    14a2:	a9 f4       	brne	.+42     	; 0x14ce <xQueueGenericSendFromISR+0x92>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14a4:	ec 81       	ldd	r30, Y+4	; 0x04
    14a6:	fd 81       	ldd	r31, Y+5	; 0x05
    14a8:	81 89       	ldd	r24, Z+17	; 0x11
    14aa:	88 23       	and	r24, r24
    14ac:	e1 f0       	breq	.+56     	; 0x14e6 <xQueueGenericSendFromISR+0xaa>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14ae:	8c 81       	ldd	r24, Y+4	; 0x04
    14b0:	9d 81       	ldd	r25, Y+5	; 0x05
    14b2:	41 96       	adiw	r24, 0x11	; 17
    14b4:	0e 94 ec 1f 	call	0x3fd8	; 0x3fd8 <xTaskRemoveFromEventList>
    14b8:	88 23       	and	r24, r24
    14ba:	a9 f0       	breq	.+42     	; 0x14e6 <xQueueGenericSendFromISR+0xaa>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    14bc:	8c 85       	ldd	r24, Y+12	; 0x0c
    14be:	9d 85       	ldd	r25, Y+13	; 0x0d
    14c0:	00 97       	sbiw	r24, 0x00	; 0
    14c2:	89 f0       	breq	.+34     	; 0x14e6 <xQueueGenericSendFromISR+0xaa>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    14c4:	ec 85       	ldd	r30, Y+12	; 0x0c
    14c6:	fd 85       	ldd	r31, Y+13	; 0x0d
    14c8:	81 e0       	ldi	r24, 0x01	; 1
    14ca:	80 83       	st	Z, r24
    14cc:	0c c0       	rjmp	.+24     	; 0x14e6 <xQueueGenericSendFromISR+0xaa>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    14ce:	0e 94 a9 1c 	call	0x3952	; 0x3952 <uxTaskGetNumberOfTasks>
    14d2:	89 83       	std	Y+1, r24	; 0x01
    14d4:	9b 81       	ldd	r25, Y+3	; 0x03
    14d6:	89 81       	ldd	r24, Y+1	; 0x01
    14d8:	98 17       	cp	r25, r24
    14da:	28 f4       	brcc	.+10     	; 0x14e6 <xQueueGenericSendFromISR+0xaa>
    14dc:	8b 81       	ldd	r24, Y+3	; 0x03
    14de:	8f 5f       	subi	r24, 0xFF	; 255
    14e0:	ec 81       	ldd	r30, Y+4	; 0x04
    14e2:	fd 81       	ldd	r31, Y+5	; 0x05
    14e4:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    14e6:	81 e0       	ldi	r24, 0x01	; 1
    14e8:	8f 83       	std	Y+7, r24	; 0x07
    14ea:	01 c0       	rjmp	.+2      	; 0x14ee <xQueueGenericSendFromISR+0xb2>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    14ec:	1f 82       	std	Y+7, r1	; 0x07
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    14ee:	8f 81       	ldd	r24, Y+7	; 0x07
}
    14f0:	2e 96       	adiw	r28, 0x0e	; 14
    14f2:	0f b6       	in	r0, 0x3f	; 63
    14f4:	f8 94       	cli
    14f6:	de bf       	out	0x3e, r29	; 62
    14f8:	0f be       	out	0x3f, r0	; 63
    14fa:	cd bf       	out	0x3d, r28	; 61
    14fc:	cf 91       	pop	r28
    14fe:	df 91       	pop	r29
    1500:	08 95       	ret

00001502 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    1502:	df 93       	push	r29
    1504:	cf 93       	push	r28
    1506:	cd b7       	in	r28, 0x3d	; 61
    1508:	de b7       	in	r29, 0x3e	; 62
    150a:	2b 97       	sbiw	r28, 0x0b	; 11
    150c:	0f b6       	in	r0, 0x3f	; 63
    150e:	f8 94       	cli
    1510:	de bf       	out	0x3e, r29	; 62
    1512:	0f be       	out	0x3f, r0	; 63
    1514:	cd bf       	out	0x3d, r28	; 61
    1516:	99 87       	std	Y+9, r25	; 0x09
    1518:	88 87       	std	Y+8, r24	; 0x08
    151a:	7b 87       	std	Y+11, r23	; 0x0b
    151c:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    151e:	88 85       	ldd	r24, Y+8	; 0x08
    1520:	99 85       	ldd	r25, Y+9	; 0x09
    1522:	9d 83       	std	Y+5, r25	; 0x05
    1524:	8c 83       	std	Y+4, r24	; 0x04
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1526:	1e 82       	std	Y+6, r1	; 0x06
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1528:	ec 81       	ldd	r30, Y+4	; 0x04
    152a:	fd 81       	ldd	r31, Y+5	; 0x05
    152c:	82 8d       	ldd	r24, Z+26	; 0x1a
    152e:	8b 83       	std	Y+3, r24	; 0x03

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    1530:	ec 81       	ldd	r30, Y+4	; 0x04
    1532:	fd 81       	ldd	r31, Y+5	; 0x05
    1534:	93 8d       	ldd	r25, Z+27	; 0x1b
    1536:	8b 81       	ldd	r24, Y+3	; 0x03
    1538:	89 17       	cp	r24, r25
    153a:	80 f5       	brcc	.+96     	; 0x159c <xQueueGiveFromISR+0x9a>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    153c:	ec 81       	ldd	r30, Y+4	; 0x04
    153e:	fd 81       	ldd	r31, Y+5	; 0x05
    1540:	86 8d       	ldd	r24, Z+30	; 0x1e
    1542:	8a 83       	std	Y+2, r24	; 0x02
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1544:	8b 81       	ldd	r24, Y+3	; 0x03
    1546:	8f 5f       	subi	r24, 0xFF	; 255
    1548:	ec 81       	ldd	r30, Y+4	; 0x04
    154a:	fd 81       	ldd	r31, Y+5	; 0x05
    154c:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    154e:	8a 81       	ldd	r24, Y+2	; 0x02
    1550:	8f 3f       	cpi	r24, 0xFF	; 255
    1552:	a9 f4       	brne	.+42     	; 0x157e <xQueueGiveFromISR+0x7c>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1554:	ec 81       	ldd	r30, Y+4	; 0x04
    1556:	fd 81       	ldd	r31, Y+5	; 0x05
    1558:	81 89       	ldd	r24, Z+17	; 0x11
    155a:	88 23       	and	r24, r24
    155c:	e1 f0       	breq	.+56     	; 0x1596 <xQueueGiveFromISR+0x94>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    155e:	8c 81       	ldd	r24, Y+4	; 0x04
    1560:	9d 81       	ldd	r25, Y+5	; 0x05
    1562:	41 96       	adiw	r24, 0x11	; 17
    1564:	0e 94 ec 1f 	call	0x3fd8	; 0x3fd8 <xTaskRemoveFromEventList>
    1568:	88 23       	and	r24, r24
    156a:	a9 f0       	breq	.+42     	; 0x1596 <xQueueGiveFromISR+0x94>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    156c:	8a 85       	ldd	r24, Y+10	; 0x0a
    156e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1570:	00 97       	sbiw	r24, 0x00	; 0
    1572:	89 f0       	breq	.+34     	; 0x1596 <xQueueGiveFromISR+0x94>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    1574:	ea 85       	ldd	r30, Y+10	; 0x0a
    1576:	fb 85       	ldd	r31, Y+11	; 0x0b
    1578:	81 e0       	ldi	r24, 0x01	; 1
    157a:	80 83       	st	Z, r24
    157c:	0c c0       	rjmp	.+24     	; 0x1596 <xQueueGiveFromISR+0x94>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    157e:	0e 94 a9 1c 	call	0x3952	; 0x3952 <uxTaskGetNumberOfTasks>
    1582:	89 83       	std	Y+1, r24	; 0x01
    1584:	9a 81       	ldd	r25, Y+2	; 0x02
    1586:	89 81       	ldd	r24, Y+1	; 0x01
    1588:	98 17       	cp	r25, r24
    158a:	28 f4       	brcc	.+10     	; 0x1596 <xQueueGiveFromISR+0x94>
    158c:	8a 81       	ldd	r24, Y+2	; 0x02
    158e:	8f 5f       	subi	r24, 0xFF	; 255
    1590:	ec 81       	ldd	r30, Y+4	; 0x04
    1592:	fd 81       	ldd	r31, Y+5	; 0x05
    1594:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    1596:	81 e0       	ldi	r24, 0x01	; 1
    1598:	8f 83       	std	Y+7, r24	; 0x07
    159a:	01 c0       	rjmp	.+2      	; 0x159e <xQueueGiveFromISR+0x9c>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    159c:	1f 82       	std	Y+7, r1	; 0x07
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    159e:	8f 81       	ldd	r24, Y+7	; 0x07
}
    15a0:	2b 96       	adiw	r28, 0x0b	; 11
    15a2:	0f b6       	in	r0, 0x3f	; 63
    15a4:	f8 94       	cli
    15a6:	de bf       	out	0x3e, r29	; 62
    15a8:	0f be       	out	0x3f, r0	; 63
    15aa:	cd bf       	out	0x3d, r28	; 61
    15ac:	cf 91       	pop	r28
    15ae:	df 91       	pop	r29
    15b0:	08 95       	ret

000015b2 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    15b2:	df 93       	push	r29
    15b4:	cf 93       	push	r28
    15b6:	cd b7       	in	r28, 0x3d	; 61
    15b8:	de b7       	in	r29, 0x3e	; 62
    15ba:	2e 97       	sbiw	r28, 0x0e	; 14
    15bc:	0f b6       	in	r0, 0x3f	; 63
    15be:	f8 94       	cli
    15c0:	de bf       	out	0x3e, r29	; 62
    15c2:	0f be       	out	0x3f, r0	; 63
    15c4:	cd bf       	out	0x3d, r28	; 61
    15c6:	99 87       	std	Y+9, r25	; 0x09
    15c8:	88 87       	std	Y+8, r24	; 0x08
    15ca:	7b 87       	std	Y+11, r23	; 0x0b
    15cc:	6a 87       	std	Y+10, r22	; 0x0a
    15ce:	5d 87       	std	Y+13, r21	; 0x0d
    15d0:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    15d2:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    15d4:	88 85       	ldd	r24, Y+8	; 0x08
    15d6:	99 85       	ldd	r25, Y+9	; 0x09
    15d8:	9b 83       	std	Y+3, r25	; 0x03
    15da:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    15dc:	0f b6       	in	r0, 0x3f	; 63
    15de:	f8 94       	cli
    15e0:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    15e2:	ea 81       	ldd	r30, Y+2	; 0x02
    15e4:	fb 81       	ldd	r31, Y+3	; 0x03
    15e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    15e8:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    15ea:	89 81       	ldd	r24, Y+1	; 0x01
    15ec:	88 23       	and	r24, r24
    15ee:	f9 f0       	breq	.+62     	; 0x162e <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    15f0:	8a 81       	ldd	r24, Y+2	; 0x02
    15f2:	9b 81       	ldd	r25, Y+3	; 0x03
    15f4:	2a 85       	ldd	r18, Y+10	; 0x0a
    15f6:	3b 85       	ldd	r19, Y+11	; 0x0b
    15f8:	b9 01       	movw	r22, r18
    15fa:	0e 94 83 0e 	call	0x1d06	; 0x1d06 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    15fe:	89 81       	ldd	r24, Y+1	; 0x01
    1600:	81 50       	subi	r24, 0x01	; 1
    1602:	ea 81       	ldd	r30, Y+2	; 0x02
    1604:	fb 81       	ldd	r31, Y+3	; 0x03
    1606:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1608:	ea 81       	ldd	r30, Y+2	; 0x02
    160a:	fb 81       	ldd	r31, Y+3	; 0x03
    160c:	80 85       	ldd	r24, Z+8	; 0x08
    160e:	88 23       	and	r24, r24
    1610:	49 f0       	breq	.+18     	; 0x1624 <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1612:	8a 81       	ldd	r24, Y+2	; 0x02
    1614:	9b 81       	ldd	r25, Y+3	; 0x03
    1616:	08 96       	adiw	r24, 0x08	; 8
    1618:	0e 94 ec 1f 	call	0x3fd8	; 0x3fd8 <xTaskRemoveFromEventList>
    161c:	88 23       	and	r24, r24
    161e:	11 f0       	breq	.+4      	; 0x1624 <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1620:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1624:	0f 90       	pop	r0
    1626:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    1628:	81 e0       	ldi	r24, 0x01	; 1
    162a:	8e 87       	std	Y+14, r24	; 0x0e
    162c:	63 c0       	rjmp	.+198    	; 0x16f4 <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    162e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1630:	9d 85       	ldd	r25, Y+13	; 0x0d
    1632:	00 97       	sbiw	r24, 0x00	; 0
    1634:	21 f4       	brne	.+8      	; 0x163e <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1636:	0f 90       	pop	r0
    1638:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    163a:	1e 86       	std	Y+14, r1	; 0x0e
    163c:	5b c0       	rjmp	.+182    	; 0x16f4 <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    163e:	8c 81       	ldd	r24, Y+4	; 0x04
    1640:	88 23       	and	r24, r24
    1642:	31 f4       	brne	.+12     	; 0x1650 <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1644:	ce 01       	movw	r24, r28
    1646:	05 96       	adiw	r24, 0x05	; 5
    1648:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    164c:	81 e0       	ldi	r24, 0x01	; 1
    164e:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1650:	0f 90       	pop	r0
    1652:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1654:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1658:	0f b6       	in	r0, 0x3f	; 63
    165a:	f8 94       	cli
    165c:	0f 92       	push	r0
    165e:	ea 81       	ldd	r30, Y+2	; 0x02
    1660:	fb 81       	ldd	r31, Y+3	; 0x03
    1662:	85 8d       	ldd	r24, Z+29	; 0x1d
    1664:	8f 3f       	cpi	r24, 0xFF	; 255
    1666:	19 f4       	brne	.+6      	; 0x166e <xQueueReceive+0xbc>
    1668:	ea 81       	ldd	r30, Y+2	; 0x02
    166a:	fb 81       	ldd	r31, Y+3	; 0x03
    166c:	15 8e       	std	Z+29, r1	; 0x1d
    166e:	ea 81       	ldd	r30, Y+2	; 0x02
    1670:	fb 81       	ldd	r31, Y+3	; 0x03
    1672:	86 8d       	ldd	r24, Z+30	; 0x1e
    1674:	8f 3f       	cpi	r24, 0xFF	; 255
    1676:	19 f4       	brne	.+6      	; 0x167e <xQueueReceive+0xcc>
    1678:	ea 81       	ldd	r30, Y+2	; 0x02
    167a:	fb 81       	ldd	r31, Y+3	; 0x03
    167c:	16 8e       	std	Z+30, r1	; 0x1e
    167e:	0f 90       	pop	r0
    1680:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1682:	ce 01       	movw	r24, r28
    1684:	05 96       	adiw	r24, 0x05	; 5
    1686:	9e 01       	movw	r18, r28
    1688:	24 5f       	subi	r18, 0xF4	; 244
    168a:	3f 4f       	sbci	r19, 0xFF	; 255
    168c:	b9 01       	movw	r22, r18
    168e:	0e 94 75 22 	call	0x44ea	; 0x44ea <xTaskCheckForTimeOut>
    1692:	88 23       	and	r24, r24
    1694:	09 f5       	brne	.+66     	; 0x16d8 <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1696:	8a 81       	ldd	r24, Y+2	; 0x02
    1698:	9b 81       	ldd	r25, Y+3	; 0x03
    169a:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvIsQueueEmpty>
    169e:	88 23       	and	r24, r24
    16a0:	a1 f0       	breq	.+40     	; 0x16ca <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    16a2:	8a 81       	ldd	r24, Y+2	; 0x02
    16a4:	9b 81       	ldd	r25, Y+3	; 0x03
    16a6:	41 96       	adiw	r24, 0x11	; 17
    16a8:	2c 85       	ldd	r18, Y+12	; 0x0c
    16aa:	3d 85       	ldd	r19, Y+13	; 0x0d
    16ac:	b9 01       	movw	r22, r18
    16ae:	0e 94 03 1f 	call	0x3e06	; 0x3e06 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    16b2:	8a 81       	ldd	r24, Y+2	; 0x02
    16b4:	9b 81       	ldd	r25, Y+3	; 0x03
    16b6:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    16ba:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
    16be:	88 23       	and	r24, r24
    16c0:	09 f0       	breq	.+2      	; 0x16c4 <xQueueReceive+0x112>
    16c2:	8c cf       	rjmp	.-232    	; 0x15dc <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    16c4:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    16c8:	89 cf       	rjmp	.-238    	; 0x15dc <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    16ca:	8a 81       	ldd	r24, Y+2	; 0x02
    16cc:	9b 81       	ldd	r25, Y+3	; 0x03
    16ce:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    16d2:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
    16d6:	82 cf       	rjmp	.-252    	; 0x15dc <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    16d8:	8a 81       	ldd	r24, Y+2	; 0x02
    16da:	9b 81       	ldd	r25, Y+3	; 0x03
    16dc:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    16e0:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    16e4:	8a 81       	ldd	r24, Y+2	; 0x02
    16e6:	9b 81       	ldd	r25, Y+3	; 0x03
    16e8:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvIsQueueEmpty>
    16ec:	88 23       	and	r24, r24
    16ee:	09 f4       	brne	.+2      	; 0x16f2 <xQueueReceive+0x140>
    16f0:	75 cf       	rjmp	.-278    	; 0x15dc <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    16f2:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    16f4:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    16f6:	2e 96       	adiw	r28, 0x0e	; 14
    16f8:	0f b6       	in	r0, 0x3f	; 63
    16fa:	f8 94       	cli
    16fc:	de bf       	out	0x3e, r29	; 62
    16fe:	0f be       	out	0x3f, r0	; 63
    1700:	cd bf       	out	0x3d, r28	; 61
    1702:	cf 91       	pop	r28
    1704:	df 91       	pop	r29
    1706:	08 95       	ret

00001708 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    1708:	df 93       	push	r29
    170a:	cf 93       	push	r28
    170c:	cd b7       	in	r28, 0x3d	; 61
    170e:	de b7       	in	r29, 0x3e	; 62
    1710:	2c 97       	sbiw	r28, 0x0c	; 12
    1712:	0f b6       	in	r0, 0x3f	; 63
    1714:	f8 94       	cli
    1716:	de bf       	out	0x3e, r29	; 62
    1718:	0f be       	out	0x3f, r0	; 63
    171a:	cd bf       	out	0x3d, r28	; 61
    171c:	99 87       	std	Y+9, r25	; 0x09
    171e:	88 87       	std	Y+8, r24	; 0x08
    1720:	7b 87       	std	Y+11, r23	; 0x0b
    1722:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    1724:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    1726:	88 85       	ldd	r24, Y+8	; 0x08
    1728:	99 85       	ldd	r25, Y+9	; 0x09
    172a:	9b 83       	std	Y+3, r25	; 0x03
    172c:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    172e:	0f b6       	in	r0, 0x3f	; 63
    1730:	f8 94       	cli
    1732:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1734:	ea 81       	ldd	r30, Y+2	; 0x02
    1736:	fb 81       	ldd	r31, Y+3	; 0x03
    1738:	82 8d       	ldd	r24, Z+26	; 0x1a
    173a:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    173c:	89 81       	ldd	r24, Y+1	; 0x01
    173e:	88 23       	and	r24, r24
    1740:	c1 f0       	breq	.+48     	; 0x1772 <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1742:	89 81       	ldd	r24, Y+1	; 0x01
    1744:	81 50       	subi	r24, 0x01	; 1
    1746:	ea 81       	ldd	r30, Y+2	; 0x02
    1748:	fb 81       	ldd	r31, Y+3	; 0x03
    174a:	82 8f       	std	Z+26, r24	; 0x1a
                }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    174c:	ea 81       	ldd	r30, Y+2	; 0x02
    174e:	fb 81       	ldd	r31, Y+3	; 0x03
    1750:	80 85       	ldd	r24, Z+8	; 0x08
    1752:	88 23       	and	r24, r24
    1754:	49 f0       	breq	.+18     	; 0x1768 <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1756:	8a 81       	ldd	r24, Y+2	; 0x02
    1758:	9b 81       	ldd	r25, Y+3	; 0x03
    175a:	08 96       	adiw	r24, 0x08	; 8
    175c:	0e 94 ec 1f 	call	0x3fd8	; 0x3fd8 <xTaskRemoveFromEventList>
    1760:	88 23       	and	r24, r24
    1762:	11 f0       	breq	.+4      	; 0x1768 <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1764:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1768:	0f 90       	pop	r0
    176a:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    176c:	81 e0       	ldi	r24, 0x01	; 1
    176e:	8c 87       	std	Y+12, r24	; 0x0c
    1770:	63 c0       	rjmp	.+198    	; 0x1838 <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1772:	8a 85       	ldd	r24, Y+10	; 0x0a
    1774:	9b 85       	ldd	r25, Y+11	; 0x0b
    1776:	00 97       	sbiw	r24, 0x00	; 0
    1778:	21 f4       	brne	.+8      	; 0x1782 <xQueueSemaphoreTake+0x7a>
                {
                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    177a:	0f 90       	pop	r0
    177c:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    177e:	1c 86       	std	Y+12, r1	; 0x0c
    1780:	5b c0       	rjmp	.+182    	; 0x1838 <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    1782:	8c 81       	ldd	r24, Y+4	; 0x04
    1784:	88 23       	and	r24, r24
    1786:	31 f4       	brne	.+12     	; 0x1794 <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1788:	ce 01       	movw	r24, r28
    178a:	05 96       	adiw	r24, 0x05	; 5
    178c:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    1790:	81 e0       	ldi	r24, 0x01	; 1
    1792:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1794:	0f 90       	pop	r0
    1796:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1798:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    179c:	0f b6       	in	r0, 0x3f	; 63
    179e:	f8 94       	cli
    17a0:	0f 92       	push	r0
    17a2:	ea 81       	ldd	r30, Y+2	; 0x02
    17a4:	fb 81       	ldd	r31, Y+3	; 0x03
    17a6:	85 8d       	ldd	r24, Z+29	; 0x1d
    17a8:	8f 3f       	cpi	r24, 0xFF	; 255
    17aa:	19 f4       	brne	.+6      	; 0x17b2 <xQueueSemaphoreTake+0xaa>
    17ac:	ea 81       	ldd	r30, Y+2	; 0x02
    17ae:	fb 81       	ldd	r31, Y+3	; 0x03
    17b0:	15 8e       	std	Z+29, r1	; 0x1d
    17b2:	ea 81       	ldd	r30, Y+2	; 0x02
    17b4:	fb 81       	ldd	r31, Y+3	; 0x03
    17b6:	86 8d       	ldd	r24, Z+30	; 0x1e
    17b8:	8f 3f       	cpi	r24, 0xFF	; 255
    17ba:	19 f4       	brne	.+6      	; 0x17c2 <xQueueSemaphoreTake+0xba>
    17bc:	ea 81       	ldd	r30, Y+2	; 0x02
    17be:	fb 81       	ldd	r31, Y+3	; 0x03
    17c0:	16 8e       	std	Z+30, r1	; 0x1e
    17c2:	0f 90       	pop	r0
    17c4:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    17c6:	ce 01       	movw	r24, r28
    17c8:	05 96       	adiw	r24, 0x05	; 5
    17ca:	9e 01       	movw	r18, r28
    17cc:	26 5f       	subi	r18, 0xF6	; 246
    17ce:	3f 4f       	sbci	r19, 0xFF	; 255
    17d0:	b9 01       	movw	r22, r18
    17d2:	0e 94 75 22 	call	0x44ea	; 0x44ea <xTaskCheckForTimeOut>
    17d6:	88 23       	and	r24, r24
    17d8:	09 f5       	brne	.+66     	; 0x181c <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17da:	8a 81       	ldd	r24, Y+2	; 0x02
    17dc:	9b 81       	ldd	r25, Y+3	; 0x03
    17de:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvIsQueueEmpty>
    17e2:	88 23       	and	r24, r24
    17e4:	a1 f0       	breq	.+40     	; 0x180e <xQueueSemaphoreTake+0x106>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17e6:	8a 81       	ldd	r24, Y+2	; 0x02
    17e8:	9b 81       	ldd	r25, Y+3	; 0x03
    17ea:	41 96       	adiw	r24, 0x11	; 17
    17ec:	2a 85       	ldd	r18, Y+10	; 0x0a
    17ee:	3b 85       	ldd	r19, Y+11	; 0x0b
    17f0:	b9 01       	movw	r22, r18
    17f2:	0e 94 03 1f 	call	0x3e06	; 0x3e06 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    17f6:	8a 81       	ldd	r24, Y+2	; 0x02
    17f8:	9b 81       	ldd	r25, Y+3	; 0x03
    17fa:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    17fe:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
    1802:	88 23       	and	r24, r24
    1804:	09 f0       	breq	.+2      	; 0x1808 <xQueueSemaphoreTake+0x100>
    1806:	93 cf       	rjmp	.-218    	; 0x172e <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    1808:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    180c:	90 cf       	rjmp	.-224    	; 0x172e <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    180e:	8a 81       	ldd	r24, Y+2	; 0x02
    1810:	9b 81       	ldd	r25, Y+3	; 0x03
    1812:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1816:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
    181a:	89 cf       	rjmp	.-238    	; 0x172e <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    181c:	8a 81       	ldd	r24, Y+2	; 0x02
    181e:	9b 81       	ldd	r25, Y+3	; 0x03
    1820:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1824:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1828:	8a 81       	ldd	r24, Y+2	; 0x02
    182a:	9b 81       	ldd	r25, Y+3	; 0x03
    182c:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvIsQueueEmpty>
    1830:	88 23       	and	r24, r24
    1832:	09 f4       	brne	.+2      	; 0x1836 <xQueueSemaphoreTake+0x12e>
    1834:	7c cf       	rjmp	.-264    	; 0x172e <xQueueSemaphoreTake+0x26>
                    }
                }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    1836:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    1838:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    183a:	2c 96       	adiw	r28, 0x0c	; 12
    183c:	0f b6       	in	r0, 0x3f	; 63
    183e:	f8 94       	cli
    1840:	de bf       	out	0x3e, r29	; 62
    1842:	0f be       	out	0x3f, r0	; 63
    1844:	cd bf       	out	0x3d, r28	; 61
    1846:	cf 91       	pop	r28
    1848:	df 91       	pop	r29
    184a:	08 95       	ret

0000184c <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    184c:	df 93       	push	r29
    184e:	cf 93       	push	r28
    1850:	cd b7       	in	r28, 0x3d	; 61
    1852:	de b7       	in	r29, 0x3e	; 62
    1854:	60 97       	sbiw	r28, 0x10	; 16
    1856:	0f b6       	in	r0, 0x3f	; 63
    1858:	f8 94       	cli
    185a:	de bf       	out	0x3e, r29	; 62
    185c:	0f be       	out	0x3f, r0	; 63
    185e:	cd bf       	out	0x3d, r28	; 61
    1860:	9b 87       	std	Y+11, r25	; 0x0b
    1862:	8a 87       	std	Y+10, r24	; 0x0a
    1864:	7d 87       	std	Y+13, r23	; 0x0d
    1866:	6c 87       	std	Y+12, r22	; 0x0c
    1868:	5f 87       	std	Y+15, r21	; 0x0f
    186a:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    186c:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    186e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1870:	9b 85       	ldd	r25, Y+11	; 0x0b
    1872:	9b 83       	std	Y+3, r25	; 0x03
    1874:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1876:	0f b6       	in	r0, 0x3f	; 63
    1878:	f8 94       	cli
    187a:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    187c:	ea 81       	ldd	r30, Y+2	; 0x02
    187e:	fb 81       	ldd	r31, Y+3	; 0x03
    1880:	82 8d       	ldd	r24, Z+26	; 0x1a
    1882:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1884:	89 81       	ldd	r24, Y+1	; 0x01
    1886:	88 23       	and	r24, r24
    1888:	31 f1       	breq	.+76     	; 0x18d6 <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    188a:	ea 81       	ldd	r30, Y+2	; 0x02
    188c:	fb 81       	ldd	r31, Y+3	; 0x03
    188e:	86 81       	ldd	r24, Z+6	; 0x06
    1890:	97 81       	ldd	r25, Z+7	; 0x07
    1892:	9d 83       	std	Y+5, r25	; 0x05
    1894:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    1896:	8a 81       	ldd	r24, Y+2	; 0x02
    1898:	9b 81       	ldd	r25, Y+3	; 0x03
    189a:	2c 85       	ldd	r18, Y+12	; 0x0c
    189c:	3d 85       	ldd	r19, Y+13	; 0x0d
    189e:	b9 01       	movw	r22, r18
    18a0:	0e 94 83 0e 	call	0x1d06	; 0x1d06 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    18a4:	ea 81       	ldd	r30, Y+2	; 0x02
    18a6:	fb 81       	ldd	r31, Y+3	; 0x03
    18a8:	8c 81       	ldd	r24, Y+4	; 0x04
    18aa:	9d 81       	ldd	r25, Y+5	; 0x05
    18ac:	97 83       	std	Z+7, r25	; 0x07
    18ae:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18b0:	ea 81       	ldd	r30, Y+2	; 0x02
    18b2:	fb 81       	ldd	r31, Y+3	; 0x03
    18b4:	81 89       	ldd	r24, Z+17	; 0x11
    18b6:	88 23       	and	r24, r24
    18b8:	49 f0       	breq	.+18     	; 0x18cc <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    18ba:	8a 81       	ldd	r24, Y+2	; 0x02
    18bc:	9b 81       	ldd	r25, Y+3	; 0x03
    18be:	41 96       	adiw	r24, 0x11	; 17
    18c0:	0e 94 ec 1f 	call	0x3fd8	; 0x3fd8 <xTaskRemoveFromEventList>
    18c4:	88 23       	and	r24, r24
    18c6:	11 f0       	breq	.+4      	; 0x18cc <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    18c8:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    18cc:	0f 90       	pop	r0
    18ce:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    18d0:	81 e0       	ldi	r24, 0x01	; 1
    18d2:	88 8b       	std	Y+16, r24	; 0x10
    18d4:	63 c0       	rjmp	.+198    	; 0x199c <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    18d6:	8e 85       	ldd	r24, Y+14	; 0x0e
    18d8:	9f 85       	ldd	r25, Y+15	; 0x0f
    18da:	00 97       	sbiw	r24, 0x00	; 0
    18dc:	21 f4       	brne	.+8      	; 0x18e6 <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    18de:	0f 90       	pop	r0
    18e0:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    18e2:	18 8a       	std	Y+16, r1	; 0x10
    18e4:	5b c0       	rjmp	.+182    	; 0x199c <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    18e6:	8e 81       	ldd	r24, Y+6	; 0x06
    18e8:	88 23       	and	r24, r24
    18ea:	31 f4       	brne	.+12     	; 0x18f8 <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    18ec:	ce 01       	movw	r24, r28
    18ee:	07 96       	adiw	r24, 0x07	; 7
    18f0:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    18f4:	81 e0       	ldi	r24, 0x01	; 1
    18f6:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    18f8:	0f 90       	pop	r0
    18fa:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    18fc:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1900:	0f b6       	in	r0, 0x3f	; 63
    1902:	f8 94       	cli
    1904:	0f 92       	push	r0
    1906:	ea 81       	ldd	r30, Y+2	; 0x02
    1908:	fb 81       	ldd	r31, Y+3	; 0x03
    190a:	85 8d       	ldd	r24, Z+29	; 0x1d
    190c:	8f 3f       	cpi	r24, 0xFF	; 255
    190e:	19 f4       	brne	.+6      	; 0x1916 <xQueuePeek+0xca>
    1910:	ea 81       	ldd	r30, Y+2	; 0x02
    1912:	fb 81       	ldd	r31, Y+3	; 0x03
    1914:	15 8e       	std	Z+29, r1	; 0x1d
    1916:	ea 81       	ldd	r30, Y+2	; 0x02
    1918:	fb 81       	ldd	r31, Y+3	; 0x03
    191a:	86 8d       	ldd	r24, Z+30	; 0x1e
    191c:	8f 3f       	cpi	r24, 0xFF	; 255
    191e:	19 f4       	brne	.+6      	; 0x1926 <xQueuePeek+0xda>
    1920:	ea 81       	ldd	r30, Y+2	; 0x02
    1922:	fb 81       	ldd	r31, Y+3	; 0x03
    1924:	16 8e       	std	Z+30, r1	; 0x1e
    1926:	0f 90       	pop	r0
    1928:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    192a:	ce 01       	movw	r24, r28
    192c:	07 96       	adiw	r24, 0x07	; 7
    192e:	9e 01       	movw	r18, r28
    1930:	22 5f       	subi	r18, 0xF2	; 242
    1932:	3f 4f       	sbci	r19, 0xFF	; 255
    1934:	b9 01       	movw	r22, r18
    1936:	0e 94 75 22 	call	0x44ea	; 0x44ea <xTaskCheckForTimeOut>
    193a:	88 23       	and	r24, r24
    193c:	09 f5       	brne	.+66     	; 0x1980 <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    193e:	8a 81       	ldd	r24, Y+2	; 0x02
    1940:	9b 81       	ldd	r25, Y+3	; 0x03
    1942:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvIsQueueEmpty>
    1946:	88 23       	and	r24, r24
    1948:	a1 f0       	breq	.+40     	; 0x1972 <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    194a:	8a 81       	ldd	r24, Y+2	; 0x02
    194c:	9b 81       	ldd	r25, Y+3	; 0x03
    194e:	41 96       	adiw	r24, 0x11	; 17
    1950:	2e 85       	ldd	r18, Y+14	; 0x0e
    1952:	3f 85       	ldd	r19, Y+15	; 0x0f
    1954:	b9 01       	movw	r22, r18
    1956:	0e 94 03 1f 	call	0x3e06	; 0x3e06 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    195a:	8a 81       	ldd	r24, Y+2	; 0x02
    195c:	9b 81       	ldd	r25, Y+3	; 0x03
    195e:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1962:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
    1966:	88 23       	and	r24, r24
    1968:	09 f0       	breq	.+2      	; 0x196c <xQueuePeek+0x120>
    196a:	85 cf       	rjmp	.-246    	; 0x1876 <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    196c:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    1970:	82 cf       	rjmp	.-252    	; 0x1876 <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    1972:	8a 81       	ldd	r24, Y+2	; 0x02
    1974:	9b 81       	ldd	r25, Y+3	; 0x03
    1976:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    197a:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
    197e:	7b cf       	rjmp	.-266    	; 0x1876 <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    1980:	8a 81       	ldd	r24, Y+2	; 0x02
    1982:	9b 81       	ldd	r25, Y+3	; 0x03
    1984:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1988:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    198c:	8a 81       	ldd	r24, Y+2	; 0x02
    198e:	9b 81       	ldd	r25, Y+3	; 0x03
    1990:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvIsQueueEmpty>
    1994:	88 23       	and	r24, r24
    1996:	09 f4       	brne	.+2      	; 0x199a <xQueuePeek+0x14e>
    1998:	6e cf       	rjmp	.-292    	; 0x1876 <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    199a:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    199c:	88 89       	ldd	r24, Y+16	; 0x10
}
    199e:	60 96       	adiw	r28, 0x10	; 16
    19a0:	0f b6       	in	r0, 0x3f	; 63
    19a2:	f8 94       	cli
    19a4:	de bf       	out	0x3e, r29	; 62
    19a6:	0f be       	out	0x3f, r0	; 63
    19a8:	cd bf       	out	0x3d, r28	; 61
    19aa:	cf 91       	pop	r28
    19ac:	df 91       	pop	r29
    19ae:	08 95       	ret

000019b0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    19b0:	df 93       	push	r29
    19b2:	cf 93       	push	r28
    19b4:	cd b7       	in	r28, 0x3d	; 61
    19b6:	de b7       	in	r29, 0x3e	; 62
    19b8:	2d 97       	sbiw	r28, 0x0d	; 13
    19ba:	0f b6       	in	r0, 0x3f	; 63
    19bc:	f8 94       	cli
    19be:	de bf       	out	0x3e, r29	; 62
    19c0:	0f be       	out	0x3f, r0	; 63
    19c2:	cd bf       	out	0x3d, r28	; 61
    19c4:	99 87       	std	Y+9, r25	; 0x09
    19c6:	88 87       	std	Y+8, r24	; 0x08
    19c8:	7b 87       	std	Y+11, r23	; 0x0b
    19ca:	6a 87       	std	Y+10, r22	; 0x0a
    19cc:	5d 87       	std	Y+13, r21	; 0x0d
    19ce:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    19d0:	88 85       	ldd	r24, Y+8	; 0x08
    19d2:	99 85       	ldd	r25, Y+9	; 0x09
    19d4:	9d 83       	std	Y+5, r25	; 0x05
    19d6:	8c 83       	std	Y+4, r24	; 0x04
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    19d8:	1e 82       	std	Y+6, r1	; 0x06
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    19da:	ec 81       	ldd	r30, Y+4	; 0x04
    19dc:	fd 81       	ldd	r31, Y+5	; 0x05
    19de:	82 8d       	ldd	r24, Z+26	; 0x1a
    19e0:	8b 83       	std	Y+3, r24	; 0x03

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    19e2:	8b 81       	ldd	r24, Y+3	; 0x03
    19e4:	88 23       	and	r24, r24
    19e6:	b9 f1       	breq	.+110    	; 0x1a56 <xQueueReceiveFromISR+0xa6>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    19e8:	ec 81       	ldd	r30, Y+4	; 0x04
    19ea:	fd 81       	ldd	r31, Y+5	; 0x05
    19ec:	85 8d       	ldd	r24, Z+29	; 0x1d
    19ee:	8a 83       	std	Y+2, r24	; 0x02

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    19f0:	8c 81       	ldd	r24, Y+4	; 0x04
    19f2:	9d 81       	ldd	r25, Y+5	; 0x05
    19f4:	2a 85       	ldd	r18, Y+10	; 0x0a
    19f6:	3b 85       	ldd	r19, Y+11	; 0x0b
    19f8:	b9 01       	movw	r22, r18
    19fa:	0e 94 83 0e 	call	0x1d06	; 0x1d06 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    19fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1a00:	81 50       	subi	r24, 0x01	; 1
    1a02:	ec 81       	ldd	r30, Y+4	; 0x04
    1a04:	fd 81       	ldd	r31, Y+5	; 0x05
    1a06:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    1a08:	8a 81       	ldd	r24, Y+2	; 0x02
    1a0a:	8f 3f       	cpi	r24, 0xFF	; 255
    1a0c:	a9 f4       	brne	.+42     	; 0x1a38 <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a0e:	ec 81       	ldd	r30, Y+4	; 0x04
    1a10:	fd 81       	ldd	r31, Y+5	; 0x05
    1a12:	80 85       	ldd	r24, Z+8	; 0x08
    1a14:	88 23       	and	r24, r24
    1a16:	e1 f0       	breq	.+56     	; 0x1a50 <xQueueReceiveFromISR+0xa0>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a18:	8c 81       	ldd	r24, Y+4	; 0x04
    1a1a:	9d 81       	ldd	r25, Y+5	; 0x05
    1a1c:	08 96       	adiw	r24, 0x08	; 8
    1a1e:	0e 94 ec 1f 	call	0x3fd8	; 0x3fd8 <xTaskRemoveFromEventList>
    1a22:	88 23       	and	r24, r24
    1a24:	a9 f0       	breq	.+42     	; 0x1a50 <xQueueReceiveFromISR+0xa0>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    1a26:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a28:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a2a:	00 97       	sbiw	r24, 0x00	; 0
    1a2c:	89 f0       	breq	.+34     	; 0x1a50 <xQueueReceiveFromISR+0xa0>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    1a2e:	ec 85       	ldd	r30, Y+12	; 0x0c
    1a30:	fd 85       	ldd	r31, Y+13	; 0x0d
    1a32:	81 e0       	ldi	r24, 0x01	; 1
    1a34:	80 83       	st	Z, r24
    1a36:	0c c0       	rjmp	.+24     	; 0x1a50 <xQueueReceiveFromISR+0xa0>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                prvIncrementQueueRxLock( pxQueue, cRxLock );
    1a38:	0e 94 a9 1c 	call	0x3952	; 0x3952 <uxTaskGetNumberOfTasks>
    1a3c:	89 83       	std	Y+1, r24	; 0x01
    1a3e:	9a 81       	ldd	r25, Y+2	; 0x02
    1a40:	89 81       	ldd	r24, Y+1	; 0x01
    1a42:	98 17       	cp	r25, r24
    1a44:	28 f4       	brcc	.+10     	; 0x1a50 <xQueueReceiveFromISR+0xa0>
    1a46:	8a 81       	ldd	r24, Y+2	; 0x02
    1a48:	8f 5f       	subi	r24, 0xFF	; 255
    1a4a:	ec 81       	ldd	r30, Y+4	; 0x04
    1a4c:	fd 81       	ldd	r31, Y+5	; 0x05
    1a4e:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    1a50:	81 e0       	ldi	r24, 0x01	; 1
    1a52:	8f 83       	std	Y+7, r24	; 0x07
    1a54:	01 c0       	rjmp	.+2      	; 0x1a58 <xQueueReceiveFromISR+0xa8>
        }
        else
        {
            xReturn = pdFAIL;
    1a56:	1f 82       	std	Y+7, r1	; 0x07
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    1a58:	8f 81       	ldd	r24, Y+7	; 0x07
}
    1a5a:	2d 96       	adiw	r28, 0x0d	; 13
    1a5c:	0f b6       	in	r0, 0x3f	; 63
    1a5e:	f8 94       	cli
    1a60:	de bf       	out	0x3e, r29	; 62
    1a62:	0f be       	out	0x3f, r0	; 63
    1a64:	cd bf       	out	0x3d, r28	; 61
    1a66:	cf 91       	pop	r28
    1a68:	df 91       	pop	r29
    1a6a:	08 95       	ret

00001a6c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    1a6c:	df 93       	push	r29
    1a6e:	cf 93       	push	r28
    1a70:	cd b7       	in	r28, 0x3d	; 61
    1a72:	de b7       	in	r29, 0x3e	; 62
    1a74:	2a 97       	sbiw	r28, 0x0a	; 10
    1a76:	0f b6       	in	r0, 0x3f	; 63
    1a78:	f8 94       	cli
    1a7a:	de bf       	out	0x3e, r29	; 62
    1a7c:	0f be       	out	0x3f, r0	; 63
    1a7e:	cd bf       	out	0x3d, r28	; 61
    1a80:	98 87       	std	Y+8, r25	; 0x08
    1a82:	8f 83       	std	Y+7, r24	; 0x07
    1a84:	7a 87       	std	Y+10, r23	; 0x0a
    1a86:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    1a88:	8f 81       	ldd	r24, Y+7	; 0x07
    1a8a:	98 85       	ldd	r25, Y+8	; 0x08
    1a8c:	9a 83       	std	Y+2, r25	; 0x02
    1a8e:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1a90:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a92:	e9 81       	ldd	r30, Y+1	; 0x01
    1a94:	fa 81       	ldd	r31, Y+2	; 0x02
    1a96:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a98:	88 23       	and	r24, r24
    1a9a:	b1 f0       	breq	.+44     	; 0x1ac8 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1a9c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a9e:	fa 81       	ldd	r31, Y+2	; 0x02
    1aa0:	86 81       	ldd	r24, Z+6	; 0x06
    1aa2:	97 81       	ldd	r25, Z+7	; 0x07
    1aa4:	9c 83       	std	Y+4, r25	; 0x04
    1aa6:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    1aa8:	89 81       	ldd	r24, Y+1	; 0x01
    1aaa:	9a 81       	ldd	r25, Y+2	; 0x02
    1aac:	29 85       	ldd	r18, Y+9	; 0x09
    1aae:	3a 85       	ldd	r19, Y+10	; 0x0a
    1ab0:	b9 01       	movw	r22, r18
    1ab2:	0e 94 83 0e 	call	0x1d06	; 0x1d06 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1ab6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ab8:	fa 81       	ldd	r31, Y+2	; 0x02
    1aba:	8b 81       	ldd	r24, Y+3	; 0x03
    1abc:	9c 81       	ldd	r25, Y+4	; 0x04
    1abe:	97 83       	std	Z+7, r25	; 0x07
    1ac0:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    1ac2:	81 e0       	ldi	r24, 0x01	; 1
    1ac4:	8e 83       	std	Y+6, r24	; 0x06
    1ac6:	01 c0       	rjmp	.+2      	; 0x1aca <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    1ac8:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    1aca:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1acc:	2a 96       	adiw	r28, 0x0a	; 10
    1ace:	0f b6       	in	r0, 0x3f	; 63
    1ad0:	f8 94       	cli
    1ad2:	de bf       	out	0x3e, r29	; 62
    1ad4:	0f be       	out	0x3f, r0	; 63
    1ad6:	cd bf       	out	0x3d, r28	; 61
    1ad8:	cf 91       	pop	r28
    1ada:	df 91       	pop	r29
    1adc:	08 95       	ret

00001ade <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    1ade:	df 93       	push	r29
    1ae0:	cf 93       	push	r28
    1ae2:	00 d0       	rcall	.+0      	; 0x1ae4 <uxQueueMessagesWaiting+0x6>
    1ae4:	0f 92       	push	r0
    1ae6:	cd b7       	in	r28, 0x3d	; 61
    1ae8:	de b7       	in	r29, 0x3e	; 62
    1aea:	9b 83       	std	Y+3, r25	; 0x03
    1aec:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    1aee:	0f b6       	in	r0, 0x3f	; 63
    1af0:	f8 94       	cli
    1af2:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1af4:	ea 81       	ldd	r30, Y+2	; 0x02
    1af6:	fb 81       	ldd	r31, Y+3	; 0x03
    1af8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1afa:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    1afc:	0f 90       	pop	r0
    1afe:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    1b00:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1b02:	0f 90       	pop	r0
    1b04:	0f 90       	pop	r0
    1b06:	0f 90       	pop	r0
    1b08:	cf 91       	pop	r28
    1b0a:	df 91       	pop	r29
    1b0c:	08 95       	ret

00001b0e <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1b0e:	df 93       	push	r29
    1b10:	cf 93       	push	r28
    1b12:	00 d0       	rcall	.+0      	; 0x1b14 <uxQueueSpacesAvailable+0x6>
    1b14:	00 d0       	rcall	.+0      	; 0x1b16 <uxQueueSpacesAvailable+0x8>
    1b16:	0f 92       	push	r0
    1b18:	cd b7       	in	r28, 0x3d	; 61
    1b1a:	de b7       	in	r29, 0x3e	; 62
    1b1c:	9d 83       	std	Y+5, r25	; 0x05
    1b1e:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    1b20:	8c 81       	ldd	r24, Y+4	; 0x04
    1b22:	9d 81       	ldd	r25, Y+5	; 0x05
    1b24:	9a 83       	std	Y+2, r25	; 0x02
    1b26:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    1b28:	0f b6       	in	r0, 0x3f	; 63
    1b2a:	f8 94       	cli
    1b2c:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1b2e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b30:	fa 81       	ldd	r31, Y+2	; 0x02
    1b32:	93 8d       	ldd	r25, Z+27	; 0x1b
    1b34:	e9 81       	ldd	r30, Y+1	; 0x01
    1b36:	fa 81       	ldd	r31, Y+2	; 0x02
    1b38:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b3a:	29 2f       	mov	r18, r25
    1b3c:	28 1b       	sub	r18, r24
    1b3e:	82 2f       	mov	r24, r18
    1b40:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    1b42:	0f 90       	pop	r0
    1b44:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    1b46:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1b48:	0f 90       	pop	r0
    1b4a:	0f 90       	pop	r0
    1b4c:	0f 90       	pop	r0
    1b4e:	0f 90       	pop	r0
    1b50:	0f 90       	pop	r0
    1b52:	cf 91       	pop	r28
    1b54:	df 91       	pop	r29
    1b56:	08 95       	ret

00001b58 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    1b58:	df 93       	push	r29
    1b5a:	cf 93       	push	r28
    1b5c:	00 d0       	rcall	.+0      	; 0x1b5e <uxQueueMessagesWaitingFromISR+0x6>
    1b5e:	00 d0       	rcall	.+0      	; 0x1b60 <uxQueueMessagesWaitingFromISR+0x8>
    1b60:	0f 92       	push	r0
    1b62:	cd b7       	in	r28, 0x3d	; 61
    1b64:	de b7       	in	r29, 0x3e	; 62
    1b66:	9d 83       	std	Y+5, r25	; 0x05
    1b68:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    1b6a:	8c 81       	ldd	r24, Y+4	; 0x04
    1b6c:	9d 81       	ldd	r25, Y+5	; 0x05
    1b6e:	9a 83       	std	Y+2, r25	; 0x02
    1b70:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    1b72:	e9 81       	ldd	r30, Y+1	; 0x01
    1b74:	fa 81       	ldd	r31, Y+2	; 0x02
    1b76:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b78:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    1b7a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1b7c:	0f 90       	pop	r0
    1b7e:	0f 90       	pop	r0
    1b80:	0f 90       	pop	r0
    1b82:	0f 90       	pop	r0
    1b84:	0f 90       	pop	r0
    1b86:	cf 91       	pop	r28
    1b88:	df 91       	pop	r29
    1b8a:	08 95       	ret

00001b8c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1b8c:	df 93       	push	r29
    1b8e:	cf 93       	push	r28
    1b90:	00 d0       	rcall	.+0      	; 0x1b92 <vQueueDelete+0x6>
    1b92:	00 d0       	rcall	.+0      	; 0x1b94 <vQueueDelete+0x8>
    1b94:	cd b7       	in	r28, 0x3d	; 61
    1b96:	de b7       	in	r29, 0x3e	; 62
    1b98:	9c 83       	std	Y+4, r25	; 0x04
    1b9a:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    1b9c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b9e:	9c 81       	ldd	r25, Y+4	; 0x04
    1ba0:	9a 83       	std	Y+2, r25	; 0x02
    1ba2:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The queue can only have been allocated dynamically - free it
         * again. */
        vPortFree( pxQueue );
    1ba4:	89 81       	ldd	r24, Y+1	; 0x01
    1ba6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ba8:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
        /* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. */
        ( void ) pxQueue;
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1bac:	0f 90       	pop	r0
    1bae:	0f 90       	pop	r0
    1bb0:	0f 90       	pop	r0
    1bb2:	0f 90       	pop	r0
    1bb4:	cf 91       	pop	r28
    1bb6:	df 91       	pop	r29
    1bb8:	08 95       	ret

00001bba <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    1bba:	df 93       	push	r29
    1bbc:	cf 93       	push	r28
    1bbe:	cd b7       	in	r28, 0x3d	; 61
    1bc0:	de b7       	in	r29, 0x3e	; 62
    1bc2:	27 97       	sbiw	r28, 0x07	; 7
    1bc4:	0f b6       	in	r0, 0x3f	; 63
    1bc6:	f8 94       	cli
    1bc8:	de bf       	out	0x3e, r29	; 62
    1bca:	0f be       	out	0x3f, r0	; 63
    1bcc:	cd bf       	out	0x3d, r28	; 61
    1bce:	9c 83       	std	Y+4, r25	; 0x04
    1bd0:	8b 83       	std	Y+3, r24	; 0x03
    1bd2:	7e 83       	std	Y+6, r23	; 0x06
    1bd4:	6d 83       	std	Y+5, r22	; 0x05
    1bd6:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    1bd8:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1bda:	eb 81       	ldd	r30, Y+3	; 0x03
    1bdc:	fc 81       	ldd	r31, Y+4	; 0x04
    1bde:	82 8d       	ldd	r24, Z+26	; 0x1a
    1be0:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1be2:	eb 81       	ldd	r30, Y+3	; 0x03
    1be4:	fc 81       	ldd	r31, Y+4	; 0x04
    1be6:	84 8d       	ldd	r24, Z+28	; 0x1c
    1be8:	88 23       	and	r24, r24
    1bea:	09 f4       	brne	.+2      	; 0x1bee <prvCopyDataToQueue+0x34>
    1bec:	7d c0       	rjmp	.+250    	; 0x1ce8 <prvCopyDataToQueue+0x12e>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    1bee:	8f 81       	ldd	r24, Y+7	; 0x07
    1bf0:	88 23       	and	r24, r24
    1bf2:	99 f5       	brne	.+102    	; 0x1c5a <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1bf4:	eb 81       	ldd	r30, Y+3	; 0x03
    1bf6:	fc 81       	ldd	r31, Y+4	; 0x04
    1bf8:	62 81       	ldd	r22, Z+2	; 0x02
    1bfa:	73 81       	ldd	r23, Z+3	; 0x03
    1bfc:	eb 81       	ldd	r30, Y+3	; 0x03
    1bfe:	fc 81       	ldd	r31, Y+4	; 0x04
    1c00:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c02:	48 2f       	mov	r20, r24
    1c04:	50 e0       	ldi	r21, 0x00	; 0
    1c06:	2d 81       	ldd	r18, Y+5	; 0x05
    1c08:	3e 81       	ldd	r19, Y+6	; 0x06
    1c0a:	cb 01       	movw	r24, r22
    1c0c:	b9 01       	movw	r22, r18
    1c0e:	0e 94 1b 32 	call	0x6436	; 0x6436 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1c12:	eb 81       	ldd	r30, Y+3	; 0x03
    1c14:	fc 81       	ldd	r31, Y+4	; 0x04
    1c16:	22 81       	ldd	r18, Z+2	; 0x02
    1c18:	33 81       	ldd	r19, Z+3	; 0x03
    1c1a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c1c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c1e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c20:	88 2f       	mov	r24, r24
    1c22:	90 e0       	ldi	r25, 0x00	; 0
    1c24:	82 0f       	add	r24, r18
    1c26:	93 1f       	adc	r25, r19
    1c28:	eb 81       	ldd	r30, Y+3	; 0x03
    1c2a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c2c:	93 83       	std	Z+3, r25	; 0x03
    1c2e:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1c30:	eb 81       	ldd	r30, Y+3	; 0x03
    1c32:	fc 81       	ldd	r31, Y+4	; 0x04
    1c34:	22 81       	ldd	r18, Z+2	; 0x02
    1c36:	33 81       	ldd	r19, Z+3	; 0x03
    1c38:	eb 81       	ldd	r30, Y+3	; 0x03
    1c3a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c3c:	84 81       	ldd	r24, Z+4	; 0x04
    1c3e:	95 81       	ldd	r25, Z+5	; 0x05
    1c40:	28 17       	cp	r18, r24
    1c42:	39 07       	cpc	r19, r25
    1c44:	08 f4       	brcc	.+2      	; 0x1c48 <prvCopyDataToQueue+0x8e>
    1c46:	50 c0       	rjmp	.+160    	; 0x1ce8 <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1c48:	eb 81       	ldd	r30, Y+3	; 0x03
    1c4a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c4c:	80 81       	ld	r24, Z
    1c4e:	91 81       	ldd	r25, Z+1	; 0x01
    1c50:	eb 81       	ldd	r30, Y+3	; 0x03
    1c52:	fc 81       	ldd	r31, Y+4	; 0x04
    1c54:	93 83       	std	Z+3, r25	; 0x03
    1c56:	82 83       	std	Z+2, r24	; 0x02
    1c58:	47 c0       	rjmp	.+142    	; 0x1ce8 <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1c5a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c5c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c5e:	66 81       	ldd	r22, Z+6	; 0x06
    1c60:	77 81       	ldd	r23, Z+7	; 0x07
    1c62:	eb 81       	ldd	r30, Y+3	; 0x03
    1c64:	fc 81       	ldd	r31, Y+4	; 0x04
    1c66:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c68:	48 2f       	mov	r20, r24
    1c6a:	50 e0       	ldi	r21, 0x00	; 0
    1c6c:	2d 81       	ldd	r18, Y+5	; 0x05
    1c6e:	3e 81       	ldd	r19, Y+6	; 0x06
    1c70:	cb 01       	movw	r24, r22
    1c72:	b9 01       	movw	r22, r18
    1c74:	0e 94 1b 32 	call	0x6436	; 0x6436 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1c78:	eb 81       	ldd	r30, Y+3	; 0x03
    1c7a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c7c:	26 81       	ldd	r18, Z+6	; 0x06
    1c7e:	37 81       	ldd	r19, Z+7	; 0x07
    1c80:	eb 81       	ldd	r30, Y+3	; 0x03
    1c82:	fc 81       	ldd	r31, Y+4	; 0x04
    1c84:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c86:	88 2f       	mov	r24, r24
    1c88:	90 e0       	ldi	r25, 0x00	; 0
    1c8a:	90 95       	com	r25
    1c8c:	81 95       	neg	r24
    1c8e:	9f 4f       	sbci	r25, 0xFF	; 255
    1c90:	82 0f       	add	r24, r18
    1c92:	93 1f       	adc	r25, r19
    1c94:	eb 81       	ldd	r30, Y+3	; 0x03
    1c96:	fc 81       	ldd	r31, Y+4	; 0x04
    1c98:	97 83       	std	Z+7, r25	; 0x07
    1c9a:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1c9c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c9e:	fc 81       	ldd	r31, Y+4	; 0x04
    1ca0:	26 81       	ldd	r18, Z+6	; 0x06
    1ca2:	37 81       	ldd	r19, Z+7	; 0x07
    1ca4:	eb 81       	ldd	r30, Y+3	; 0x03
    1ca6:	fc 81       	ldd	r31, Y+4	; 0x04
    1ca8:	80 81       	ld	r24, Z
    1caa:	91 81       	ldd	r25, Z+1	; 0x01
    1cac:	28 17       	cp	r18, r24
    1cae:	39 07       	cpc	r19, r25
    1cb0:	90 f4       	brcc	.+36     	; 0x1cd6 <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1cb2:	eb 81       	ldd	r30, Y+3	; 0x03
    1cb4:	fc 81       	ldd	r31, Y+4	; 0x04
    1cb6:	24 81       	ldd	r18, Z+4	; 0x04
    1cb8:	35 81       	ldd	r19, Z+5	; 0x05
    1cba:	eb 81       	ldd	r30, Y+3	; 0x03
    1cbc:	fc 81       	ldd	r31, Y+4	; 0x04
    1cbe:	84 8d       	ldd	r24, Z+28	; 0x1c
    1cc0:	88 2f       	mov	r24, r24
    1cc2:	90 e0       	ldi	r25, 0x00	; 0
    1cc4:	90 95       	com	r25
    1cc6:	81 95       	neg	r24
    1cc8:	9f 4f       	sbci	r25, 0xFF	; 255
    1cca:	82 0f       	add	r24, r18
    1ccc:	93 1f       	adc	r25, r19
    1cce:	eb 81       	ldd	r30, Y+3	; 0x03
    1cd0:	fc 81       	ldd	r31, Y+4	; 0x04
    1cd2:	97 83       	std	Z+7, r25	; 0x07
    1cd4:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    1cd6:	8f 81       	ldd	r24, Y+7	; 0x07
    1cd8:	82 30       	cpi	r24, 0x02	; 2
    1cda:	31 f4       	brne	.+12     	; 0x1ce8 <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1cdc:	89 81       	ldd	r24, Y+1	; 0x01
    1cde:	88 23       	and	r24, r24
    1ce0:	19 f0       	breq	.+6      	; 0x1ce8 <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    1ce2:	89 81       	ldd	r24, Y+1	; 0x01
    1ce4:	81 50       	subi	r24, 0x01	; 1
    1ce6:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1ce8:	89 81       	ldd	r24, Y+1	; 0x01
    1cea:	8f 5f       	subi	r24, 0xFF	; 255
    1cec:	eb 81       	ldd	r30, Y+3	; 0x03
    1cee:	fc 81       	ldd	r31, Y+4	; 0x04
    1cf0:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    1cf2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1cf4:	27 96       	adiw	r28, 0x07	; 7
    1cf6:	0f b6       	in	r0, 0x3f	; 63
    1cf8:	f8 94       	cli
    1cfa:	de bf       	out	0x3e, r29	; 62
    1cfc:	0f be       	out	0x3f, r0	; 63
    1cfe:	cd bf       	out	0x3d, r28	; 61
    1d00:	cf 91       	pop	r28
    1d02:	df 91       	pop	r29
    1d04:	08 95       	ret

00001d06 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    1d06:	df 93       	push	r29
    1d08:	cf 93       	push	r28
    1d0a:	00 d0       	rcall	.+0      	; 0x1d0c <prvCopyDataFromQueue+0x6>
    1d0c:	00 d0       	rcall	.+0      	; 0x1d0e <prvCopyDataFromQueue+0x8>
    1d0e:	cd b7       	in	r28, 0x3d	; 61
    1d10:	de b7       	in	r29, 0x3e	; 62
    1d12:	9a 83       	std	Y+2, r25	; 0x02
    1d14:	89 83       	std	Y+1, r24	; 0x01
    1d16:	7c 83       	std	Y+4, r23	; 0x04
    1d18:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1d1a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d1c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d1e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d20:	88 23       	and	r24, r24
    1d22:	89 f1       	breq	.+98     	; 0x1d86 <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1d24:	e9 81       	ldd	r30, Y+1	; 0x01
    1d26:	fa 81       	ldd	r31, Y+2	; 0x02
    1d28:	26 81       	ldd	r18, Z+6	; 0x06
    1d2a:	37 81       	ldd	r19, Z+7	; 0x07
    1d2c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d2e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d30:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d32:	88 2f       	mov	r24, r24
    1d34:	90 e0       	ldi	r25, 0x00	; 0
    1d36:	82 0f       	add	r24, r18
    1d38:	93 1f       	adc	r25, r19
    1d3a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d3c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d3e:	97 83       	std	Z+7, r25	; 0x07
    1d40:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1d42:	e9 81       	ldd	r30, Y+1	; 0x01
    1d44:	fa 81       	ldd	r31, Y+2	; 0x02
    1d46:	26 81       	ldd	r18, Z+6	; 0x06
    1d48:	37 81       	ldd	r19, Z+7	; 0x07
    1d4a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d4c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d4e:	84 81       	ldd	r24, Z+4	; 0x04
    1d50:	95 81       	ldd	r25, Z+5	; 0x05
    1d52:	28 17       	cp	r18, r24
    1d54:	39 07       	cpc	r19, r25
    1d56:	40 f0       	brcs	.+16     	; 0x1d68 <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1d58:	e9 81       	ldd	r30, Y+1	; 0x01
    1d5a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d5c:	80 81       	ld	r24, Z
    1d5e:	91 81       	ldd	r25, Z+1	; 0x01
    1d60:	e9 81       	ldd	r30, Y+1	; 0x01
    1d62:	fa 81       	ldd	r31, Y+2	; 0x02
    1d64:	97 83       	std	Z+7, r25	; 0x07
    1d66:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1d68:	e9 81       	ldd	r30, Y+1	; 0x01
    1d6a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d6c:	46 81       	ldd	r20, Z+6	; 0x06
    1d6e:	57 81       	ldd	r21, Z+7	; 0x07
    1d70:	e9 81       	ldd	r30, Y+1	; 0x01
    1d72:	fa 81       	ldd	r31, Y+2	; 0x02
    1d74:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d76:	28 2f       	mov	r18, r24
    1d78:	30 e0       	ldi	r19, 0x00	; 0
    1d7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d7e:	ba 01       	movw	r22, r20
    1d80:	a9 01       	movw	r20, r18
    1d82:	0e 94 1b 32 	call	0x6436	; 0x6436 <memcpy>
    }
}
    1d86:	0f 90       	pop	r0
    1d88:	0f 90       	pop	r0
    1d8a:	0f 90       	pop	r0
    1d8c:	0f 90       	pop	r0
    1d8e:	cf 91       	pop	r28
    1d90:	df 91       	pop	r29
    1d92:	08 95       	ret

00001d94 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1d94:	df 93       	push	r29
    1d96:	cf 93       	push	r28
    1d98:	00 d0       	rcall	.+0      	; 0x1d9a <prvUnlockQueue+0x6>
    1d9a:	00 d0       	rcall	.+0      	; 0x1d9c <prvUnlockQueue+0x8>
    1d9c:	cd b7       	in	r28, 0x3d	; 61
    1d9e:	de b7       	in	r29, 0x3e	; 62
    1da0:	9c 83       	std	Y+4, r25	; 0x04
    1da2:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    1da4:	0f b6       	in	r0, 0x3f	; 63
    1da6:	f8 94       	cli
    1da8:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    1daa:	eb 81       	ldd	r30, Y+3	; 0x03
    1dac:	fc 81       	ldd	r31, Y+4	; 0x04
    1dae:	86 8d       	ldd	r24, Z+30	; 0x1e
    1db0:	8a 83       	std	Y+2, r24	; 0x02
    1db2:	11 c0       	rjmp	.+34     	; 0x1dd6 <prvUnlockQueue+0x42>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1db4:	eb 81       	ldd	r30, Y+3	; 0x03
    1db6:	fc 81       	ldd	r31, Y+4	; 0x04
    1db8:	81 89       	ldd	r24, Z+17	; 0x11
    1dba:	88 23       	and	r24, r24
    1dbc:	79 f0       	breq	.+30     	; 0x1ddc <prvUnlockQueue+0x48>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1dbe:	8b 81       	ldd	r24, Y+3	; 0x03
    1dc0:	9c 81       	ldd	r25, Y+4	; 0x04
    1dc2:	41 96       	adiw	r24, 0x11	; 17
    1dc4:	0e 94 ec 1f 	call	0x3fd8	; 0x3fd8 <xTaskRemoveFromEventList>
    1dc8:	88 23       	and	r24, r24
    1dca:	11 f0       	breq	.+4      	; 0x1dd0 <prvUnlockQueue+0x3c>
                    {
                        /* The task waiting has a higher priority so record that
                         * a context switch is required. */
                        vTaskMissedYield();
    1dcc:	0e 94 dc 22 	call	0x45b8	; 0x45b8 <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    1dd0:	8a 81       	ldd	r24, Y+2	; 0x02
    1dd2:	81 50       	subi	r24, 0x01	; 1
    1dd4:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    1dd6:	8a 81       	ldd	r24, Y+2	; 0x02
    1dd8:	18 16       	cp	r1, r24
    1dda:	64 f3       	brlt	.-40     	; 0x1db4 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    1ddc:	eb 81       	ldd	r30, Y+3	; 0x03
    1dde:	fc 81       	ldd	r31, Y+4	; 0x04
    1de0:	8f ef       	ldi	r24, 0xFF	; 255
    1de2:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    1de4:	0f 90       	pop	r0
    1de6:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    1de8:	0f b6       	in	r0, 0x3f	; 63
    1dea:	f8 94       	cli
    1dec:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    1dee:	eb 81       	ldd	r30, Y+3	; 0x03
    1df0:	fc 81       	ldd	r31, Y+4	; 0x04
    1df2:	85 8d       	ldd	r24, Z+29	; 0x1d
    1df4:	89 83       	std	Y+1, r24	; 0x01
    1df6:	11 c0       	rjmp	.+34     	; 0x1e1a <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1df8:	eb 81       	ldd	r30, Y+3	; 0x03
    1dfa:	fc 81       	ldd	r31, Y+4	; 0x04
    1dfc:	80 85       	ldd	r24, Z+8	; 0x08
    1dfe:	88 23       	and	r24, r24
    1e00:	79 f0       	breq	.+30     	; 0x1e20 <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e02:	8b 81       	ldd	r24, Y+3	; 0x03
    1e04:	9c 81       	ldd	r25, Y+4	; 0x04
    1e06:	08 96       	adiw	r24, 0x08	; 8
    1e08:	0e 94 ec 1f 	call	0x3fd8	; 0x3fd8 <xTaskRemoveFromEventList>
    1e0c:	88 23       	and	r24, r24
    1e0e:	11 f0       	breq	.+4      	; 0x1e14 <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    1e10:	0e 94 dc 22 	call	0x45b8	; 0x45b8 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    1e14:	89 81       	ldd	r24, Y+1	; 0x01
    1e16:	81 50       	subi	r24, 0x01	; 1
    1e18:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    1e1a:	89 81       	ldd	r24, Y+1	; 0x01
    1e1c:	18 16       	cp	r1, r24
    1e1e:	64 f3       	brlt	.-40     	; 0x1df8 <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    1e20:	eb 81       	ldd	r30, Y+3	; 0x03
    1e22:	fc 81       	ldd	r31, Y+4	; 0x04
    1e24:	8f ef       	ldi	r24, 0xFF	; 255
    1e26:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    1e28:	0f 90       	pop	r0
    1e2a:	0f be       	out	0x3f, r0	; 63
}
    1e2c:	0f 90       	pop	r0
    1e2e:	0f 90       	pop	r0
    1e30:	0f 90       	pop	r0
    1e32:	0f 90       	pop	r0
    1e34:	cf 91       	pop	r28
    1e36:	df 91       	pop	r29
    1e38:	08 95       	ret

00001e3a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    1e3a:	df 93       	push	r29
    1e3c:	cf 93       	push	r28
    1e3e:	00 d0       	rcall	.+0      	; 0x1e40 <prvIsQueueEmpty+0x6>
    1e40:	0f 92       	push	r0
    1e42:	cd b7       	in	r28, 0x3d	; 61
    1e44:	de b7       	in	r29, 0x3e	; 62
    1e46:	9b 83       	std	Y+3, r25	; 0x03
    1e48:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1e4a:	0f b6       	in	r0, 0x3f	; 63
    1e4c:	f8 94       	cli
    1e4e:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1e50:	ea 81       	ldd	r30, Y+2	; 0x02
    1e52:	fb 81       	ldd	r31, Y+3	; 0x03
    1e54:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e56:	88 23       	and	r24, r24
    1e58:	19 f4       	brne	.+6      	; 0x1e60 <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    1e5a:	81 e0       	ldi	r24, 0x01	; 1
    1e5c:	89 83       	std	Y+1, r24	; 0x01
    1e5e:	01 c0       	rjmp	.+2      	; 0x1e62 <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    1e60:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    1e62:	0f 90       	pop	r0
    1e64:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    1e66:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e68:	0f 90       	pop	r0
    1e6a:	0f 90       	pop	r0
    1e6c:	0f 90       	pop	r0
    1e6e:	cf 91       	pop	r28
    1e70:	df 91       	pop	r29
    1e72:	08 95       	ret

00001e74 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    1e74:	df 93       	push	r29
    1e76:	cf 93       	push	r28
    1e78:	00 d0       	rcall	.+0      	; 0x1e7a <xQueueIsQueueEmptyFromISR+0x6>
    1e7a:	00 d0       	rcall	.+0      	; 0x1e7c <xQueueIsQueueEmptyFromISR+0x8>
    1e7c:	0f 92       	push	r0
    1e7e:	cd b7       	in	r28, 0x3d	; 61
    1e80:	de b7       	in	r29, 0x3e	; 62
    1e82:	9d 83       	std	Y+5, r25	; 0x05
    1e84:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    1e86:	8c 81       	ldd	r24, Y+4	; 0x04
    1e88:	9d 81       	ldd	r25, Y+5	; 0x05
    1e8a:	9a 83       	std	Y+2, r25	; 0x02
    1e8c:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1e8e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e90:	fa 81       	ldd	r31, Y+2	; 0x02
    1e92:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e94:	88 23       	and	r24, r24
    1e96:	19 f4       	brne	.+6      	; 0x1e9e <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    1e98:	81 e0       	ldi	r24, 0x01	; 1
    1e9a:	8b 83       	std	Y+3, r24	; 0x03
    1e9c:	01 c0       	rjmp	.+2      	; 0x1ea0 <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    1e9e:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    1ea0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1ea2:	0f 90       	pop	r0
    1ea4:	0f 90       	pop	r0
    1ea6:	0f 90       	pop	r0
    1ea8:	0f 90       	pop	r0
    1eaa:	0f 90       	pop	r0
    1eac:	cf 91       	pop	r28
    1eae:	df 91       	pop	r29
    1eb0:	08 95       	ret

00001eb2 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    1eb2:	df 93       	push	r29
    1eb4:	cf 93       	push	r28
    1eb6:	00 d0       	rcall	.+0      	; 0x1eb8 <prvIsQueueFull+0x6>
    1eb8:	0f 92       	push	r0
    1eba:	cd b7       	in	r28, 0x3d	; 61
    1ebc:	de b7       	in	r29, 0x3e	; 62
    1ebe:	9b 83       	std	Y+3, r25	; 0x03
    1ec0:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1ec2:	0f b6       	in	r0, 0x3f	; 63
    1ec4:	f8 94       	cli
    1ec6:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1ec8:	ea 81       	ldd	r30, Y+2	; 0x02
    1eca:	fb 81       	ldd	r31, Y+3	; 0x03
    1ecc:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ece:	ea 81       	ldd	r30, Y+2	; 0x02
    1ed0:	fb 81       	ldd	r31, Y+3	; 0x03
    1ed2:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ed4:	98 17       	cp	r25, r24
    1ed6:	19 f4       	brne	.+6      	; 0x1ede <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    1ed8:	81 e0       	ldi	r24, 0x01	; 1
    1eda:	89 83       	std	Y+1, r24	; 0x01
    1edc:	01 c0       	rjmp	.+2      	; 0x1ee0 <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    1ede:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    1ee0:	0f 90       	pop	r0
    1ee2:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    1ee4:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ee6:	0f 90       	pop	r0
    1ee8:	0f 90       	pop	r0
    1eea:	0f 90       	pop	r0
    1eec:	cf 91       	pop	r28
    1eee:	df 91       	pop	r29
    1ef0:	08 95       	ret

00001ef2 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1ef2:	df 93       	push	r29
    1ef4:	cf 93       	push	r28
    1ef6:	00 d0       	rcall	.+0      	; 0x1ef8 <xQueueIsQueueFullFromISR+0x6>
    1ef8:	00 d0       	rcall	.+0      	; 0x1efa <xQueueIsQueueFullFromISR+0x8>
    1efa:	0f 92       	push	r0
    1efc:	cd b7       	in	r28, 0x3d	; 61
    1efe:	de b7       	in	r29, 0x3e	; 62
    1f00:	9d 83       	std	Y+5, r25	; 0x05
    1f02:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    1f04:	8c 81       	ldd	r24, Y+4	; 0x04
    1f06:	9d 81       	ldd	r25, Y+5	; 0x05
    1f08:	9a 83       	std	Y+2, r25	; 0x02
    1f0a:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1f0c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f0e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f10:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f12:	e9 81       	ldd	r30, Y+1	; 0x01
    1f14:	fa 81       	ldd	r31, Y+2	; 0x02
    1f16:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f18:	98 17       	cp	r25, r24
    1f1a:	19 f4       	brne	.+6      	; 0x1f22 <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    1f1c:	81 e0       	ldi	r24, 0x01	; 1
    1f1e:	8b 83       	std	Y+3, r24	; 0x03
    1f20:	01 c0       	rjmp	.+2      	; 0x1f24 <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    1f22:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    1f24:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1f26:	0f 90       	pop	r0
    1f28:	0f 90       	pop	r0
    1f2a:	0f 90       	pop	r0
    1f2c:	0f 90       	pop	r0
    1f2e:	0f 90       	pop	r0
    1f30:	cf 91       	pop	r28
    1f32:	df 91       	pop	r29
    1f34:	08 95       	ret

00001f36 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
    1f36:	df 93       	push	r29
    1f38:	cf 93       	push	r28
    1f3a:	cd b7       	in	r28, 0x3d	; 61
    1f3c:	de b7       	in	r29, 0x3e	; 62
    1f3e:	27 97       	sbiw	r28, 0x07	; 7
    1f40:	0f b6       	in	r0, 0x3f	; 63
    1f42:	f8 94       	cli
    1f44:	de bf       	out	0x3e, r29	; 62
    1f46:	0f be       	out	0x3f, r0	; 63
    1f48:	cd bf       	out	0x3d, r28	; 61
    1f4a:	9c 83       	std	Y+4, r25	; 0x04
    1f4c:	8b 83       	std	Y+3, r24	; 0x03
    1f4e:	7e 83       	std	Y+6, r23	; 0x06
    1f50:	6d 83       	std	Y+5, r22	; 0x05
    1f52:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    1f54:	8b 81       	ldd	r24, Y+3	; 0x03
    1f56:	9c 81       	ldd	r25, Y+4	; 0x04
    1f58:	9a 83       	std	Y+2, r25	; 0x02
    1f5a:	89 83       	std	Y+1, r24	; 0x01
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    1f5c:	0f b6       	in	r0, 0x3f	; 63
    1f5e:	f8 94       	cli
    1f60:	0f 92       	push	r0
    1f62:	e9 81       	ldd	r30, Y+1	; 0x01
    1f64:	fa 81       	ldd	r31, Y+2	; 0x02
    1f66:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f68:	8f 3f       	cpi	r24, 0xFF	; 255
    1f6a:	19 f4       	brne	.+6      	; 0x1f72 <vQueueWaitForMessageRestricted+0x3c>
    1f6c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f6e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f70:	15 8e       	std	Z+29, r1	; 0x1d
    1f72:	e9 81       	ldd	r30, Y+1	; 0x01
    1f74:	fa 81       	ldd	r31, Y+2	; 0x02
    1f76:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f78:	8f 3f       	cpi	r24, 0xFF	; 255
    1f7a:	19 f4       	brne	.+6      	; 0x1f82 <vQueueWaitForMessageRestricted+0x4c>
    1f7c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f7e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f80:	16 8e       	std	Z+30, r1	; 0x1e
    1f82:	0f 90       	pop	r0
    1f84:	0f be       	out	0x3f, r0	; 63

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1f86:	e9 81       	ldd	r30, Y+1	; 0x01
    1f88:	fa 81       	ldd	r31, Y+2	; 0x02
    1f8a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f8c:	88 23       	and	r24, r24
    1f8e:	49 f4       	brne	.+18     	; 0x1fa2 <vQueueWaitForMessageRestricted+0x6c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1f90:	89 81       	ldd	r24, Y+1	; 0x01
    1f92:	9a 81       	ldd	r25, Y+2	; 0x02
    1f94:	41 96       	adiw	r24, 0x11	; 17
    1f96:	2d 81       	ldd	r18, Y+5	; 0x05
    1f98:	3e 81       	ldd	r19, Y+6	; 0x06
    1f9a:	b9 01       	movw	r22, r18
    1f9c:	4f 81       	ldd	r20, Y+7	; 0x07
    1f9e:	0e 94 8a 1f 	call	0x3f14	; 0x3f14 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    1fa2:	89 81       	ldd	r24, Y+1	; 0x01
    1fa4:	9a 81       	ldd	r25, Y+2	; 0x02
    1fa6:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
    }
    1faa:	27 96       	adiw	r28, 0x07	; 7
    1fac:	0f b6       	in	r0, 0x3f	; 63
    1fae:	f8 94       	cli
    1fb0:	de bf       	out	0x3e, r29	; 62
    1fb2:	0f be       	out	0x3f, r0	; 63
    1fb4:	cd bf       	out	0x3d, r28	; 61
    1fb6:	cf 91       	pop	r28
    1fb8:	df 91       	pop	r29
    1fba:	08 95       	ret

00001fbc <xStreamBufferGenericCreate>:
    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer,
                                                     StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                                     StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
    {
    1fbc:	cf 92       	push	r12
    1fbe:	df 92       	push	r13
    1fc0:	ef 92       	push	r14
    1fc2:	ff 92       	push	r15
    1fc4:	0f 93       	push	r16
    1fc6:	1f 93       	push	r17
    1fc8:	df 93       	push	r29
    1fca:	cf 93       	push	r28
    1fcc:	cd b7       	in	r28, 0x3d	; 61
    1fce:	de b7       	in	r29, 0x3e	; 62
    1fd0:	2c 97       	sbiw	r28, 0x0c	; 12
    1fd2:	0f b6       	in	r0, 0x3f	; 63
    1fd4:	f8 94       	cli
    1fd6:	de bf       	out	0x3e, r29	; 62
    1fd8:	0f be       	out	0x3f, r0	; 63
    1fda:	cd bf       	out	0x3d, r28	; 61
    1fdc:	9d 83       	std	Y+5, r25	; 0x05
    1fde:	8c 83       	std	Y+4, r24	; 0x04
    1fe0:	7f 83       	std	Y+7, r23	; 0x07
    1fe2:	6e 83       	std	Y+6, r22	; 0x06
    1fe4:	48 87       	std	Y+8, r20	; 0x08
    1fe6:	3a 87       	std	Y+10, r19	; 0x0a
    1fe8:	29 87       	std	Y+9, r18	; 0x09
    1fea:	1c 87       	std	Y+12, r17	; 0x0c
    1fec:	0b 87       	std	Y+11, r16	; 0x0b

        /* In case the stream buffer is going to be used as a message buffer
         * (that is, it will hold discrete messages with a little meta data that
         * says how big the next message is) check the buffer will be large enough
         * to hold at least one message. */
        if( xIsMessageBuffer == pdTRUE )
    1fee:	88 85       	ldd	r24, Y+8	; 0x08
    1ff0:	81 30       	cpi	r24, 0x01	; 1
    1ff2:	19 f4       	brne	.+6      	; 0x1ffa <xStreamBufferGenericCreate+0x3e>
        {
            /* Is a message buffer but not statically allocated. */
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    1ff4:	81 e0       	ldi	r24, 0x01	; 1
    1ff6:	89 83       	std	Y+1, r24	; 0x01
    1ff8:	01 c0       	rjmp	.+2      	; 0x1ffc <xStreamBufferGenericCreate+0x40>
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
        }
        else
        {
            /* Not a message buffer and not statically allocated. */
            ucFlags = 0;
    1ffa:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
    1ffc:	8e 81       	ldd	r24, Y+6	; 0x06
    1ffe:	9f 81       	ldd	r25, Y+7	; 0x07
    2000:	00 97       	sbiw	r24, 0x00	; 0
    2002:	21 f4       	brne	.+8      	; 0x200c <xStreamBufferGenericCreate+0x50>
        {
            xTriggerLevelBytes = ( size_t ) 1;
    2004:	81 e0       	ldi	r24, 0x01	; 1
    2006:	90 e0       	ldi	r25, 0x00	; 0
    2008:	9f 83       	std	Y+7, r25	; 0x07
    200a:	8e 83       	std	Y+6, r24	; 0x06
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
    200c:	8c 81       	ldd	r24, Y+4	; 0x04
    200e:	9d 81       	ldd	r25, Y+5	; 0x05
    2010:	9c 01       	movw	r18, r24
    2012:	20 5f       	subi	r18, 0xF0	; 240
    2014:	3f 4f       	sbci	r19, 0xFF	; 255
    2016:	8c 81       	ldd	r24, Y+4	; 0x04
    2018:	9d 81       	ldd	r25, Y+5	; 0x05
    201a:	82 17       	cp	r24, r18
    201c:	93 07       	cpc	r25, r19
    201e:	68 f4       	brcc	.+26     	; 0x203a <xStreamBufferGenericCreate+0x7e>
        {
            xBufferSizeBytes++;
    2020:	8c 81       	ldd	r24, Y+4	; 0x04
    2022:	9d 81       	ldd	r25, Y+5	; 0x05
    2024:	01 96       	adiw	r24, 0x01	; 1
    2026:	9d 83       	std	Y+5, r25	; 0x05
    2028:	8c 83       	std	Y+4, r24	; 0x04
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    202a:	8c 81       	ldd	r24, Y+4	; 0x04
    202c:	9d 81       	ldd	r25, Y+5	; 0x05
    202e:	0f 96       	adiw	r24, 0x0f	; 15
    2030:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    2034:	9b 83       	std	Y+3, r25	; 0x03
    2036:	8a 83       	std	Y+2, r24	; 0x02
    2038:	02 c0       	rjmp	.+4      	; 0x203e <xStreamBufferGenericCreate+0x82>
        }
        else
        {
            pucAllocatedMemory = NULL;
    203a:	1b 82       	std	Y+3, r1	; 0x03
    203c:	1a 82       	std	Y+2, r1	; 0x02
        }

        if( pucAllocatedMemory != NULL )
    203e:	8a 81       	ldd	r24, Y+2	; 0x02
    2040:	9b 81       	ldd	r25, Y+3	; 0x03
    2042:	00 97       	sbiw	r24, 0x00	; 0
    2044:	b1 f0       	breq	.+44     	; 0x2072 <xStreamBufferGenericCreate+0xb6>
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    2046:	6a 81       	ldd	r22, Y+2	; 0x02
    2048:	7b 81       	ldd	r23, Y+3	; 0x03
    204a:	8a 81       	ldd	r24, Y+2	; 0x02
    204c:	9b 81       	ldd	r25, Y+3	; 0x03
    204e:	9c 01       	movw	r18, r24
    2050:	21 5f       	subi	r18, 0xF1	; 241
    2052:	3f 4f       	sbci	r19, 0xFF	; 255
    2054:	4c 81       	ldd	r20, Y+4	; 0x04
    2056:	5d 81       	ldd	r21, Y+5	; 0x05
    2058:	ee 81       	ldd	r30, Y+6	; 0x06
    205a:	ff 81       	ldd	r31, Y+7	; 0x07
    205c:	a9 85       	ldd	r26, Y+9	; 0x09
    205e:	ba 85       	ldd	r27, Y+10	; 0x0a
    2060:	cb 84       	ldd	r12, Y+11	; 0x0b
    2062:	dc 84       	ldd	r13, Y+12	; 0x0c
    2064:	cb 01       	movw	r24, r22
    2066:	b9 01       	movw	r22, r18
    2068:	9f 01       	movw	r18, r30
    206a:	09 81       	ldd	r16, Y+1	; 0x01
    206c:	7d 01       	movw	r14, r26
    206e:	0e 94 96 17 	call	0x2f2c	; 0x2f2c <prvInitialiseNewStreamBuffer>
        else
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    2072:	8a 81       	ldd	r24, Y+2	; 0x02
    2074:	9b 81       	ldd	r25, Y+3	; 0x03
    }
    2076:	2c 96       	adiw	r28, 0x0c	; 12
    2078:	0f b6       	in	r0, 0x3f	; 63
    207a:	f8 94       	cli
    207c:	de bf       	out	0x3e, r29	; 62
    207e:	0f be       	out	0x3f, r0	; 63
    2080:	cd bf       	out	0x3d, r28	; 61
    2082:	cf 91       	pop	r28
    2084:	df 91       	pop	r29
    2086:	1f 91       	pop	r17
    2088:	0f 91       	pop	r16
    208a:	ff 90       	pop	r15
    208c:	ef 90       	pop	r14
    208e:	df 90       	pop	r13
    2090:	cf 90       	pop	r12
    2092:	08 95       	ret

00002094 <vStreamBufferDelete>:
    }
#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    2094:	df 93       	push	r29
    2096:	cf 93       	push	r28
    2098:	00 d0       	rcall	.+0      	; 0x209a <vStreamBufferDelete+0x6>
    209a:	00 d0       	rcall	.+0      	; 0x209c <vStreamBufferDelete+0x8>
    209c:	cd b7       	in	r28, 0x3d	; 61
    209e:	de b7       	in	r29, 0x3e	; 62
    20a0:	9c 83       	std	Y+4, r25	; 0x04
    20a2:	8b 83       	std	Y+3, r24	; 0x03
    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    20a4:	8b 81       	ldd	r24, Y+3	; 0x03
    20a6:	9c 81       	ldd	r25, Y+4	; 0x04
    20a8:	9a 83       	std	Y+2, r25	; 0x02
    20aa:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    20ac:	e9 81       	ldd	r30, Y+1	; 0x01
    20ae:	fa 81       	ldd	r31, Y+2	; 0x02
    20b0:	86 85       	ldd	r24, Z+14	; 0x0e
    20b2:	88 2f       	mov	r24, r24
    20b4:	90 e0       	ldi	r25, 0x00	; 0
    20b6:	82 70       	andi	r24, 0x02	; 2
    20b8:	90 70       	andi	r25, 0x00	; 0
    20ba:	00 97       	sbiw	r24, 0x00	; 0
    20bc:	29 f4       	brne	.+10     	; 0x20c8 <vStreamBufferDelete+0x34>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
        {
            /* Both the structure and the buffer were allocated using a single call
            * to pvPortMalloc(), hence only one call to vPortFree() is required. */
            vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    20be:	89 81       	ldd	r24, Y+1	; 0x01
    20c0:	9a 81       	ldd	r25, Y+2	; 0x02
    20c2:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
    20c6:	08 c0       	rjmp	.+16     	; 0x20d8 <vStreamBufferDelete+0x44>
    }
    else
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    20c8:	89 81       	ldd	r24, Y+1	; 0x01
    20ca:	9a 81       	ldd	r25, Y+2	; 0x02
    20cc:	60 e0       	ldi	r22, 0x00	; 0
    20ce:	70 e0       	ldi	r23, 0x00	; 0
    20d0:	4f e0       	ldi	r20, 0x0F	; 15
    20d2:	50 e0       	ldi	r21, 0x00	; 0
    20d4:	0e 94 24 32 	call	0x6448	; 0x6448 <memset>
    }
}
    20d8:	0f 90       	pop	r0
    20da:	0f 90       	pop	r0
    20dc:	0f 90       	pop	r0
    20de:	0f 90       	pop	r0
    20e0:	cf 91       	pop	r28
    20e2:	df 91       	pop	r29
    20e4:	08 95       	ret

000020e6 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    20e6:	cf 92       	push	r12
    20e8:	df 92       	push	r13
    20ea:	ef 92       	push	r14
    20ec:	ff 92       	push	r15
    20ee:	0f 93       	push	r16
    20f0:	1f 93       	push	r17
    20f2:	df 93       	push	r29
    20f4:	cf 93       	push	r28
    20f6:	cd b7       	in	r28, 0x3d	; 61
    20f8:	de b7       	in	r29, 0x3e	; 62
    20fa:	29 97       	sbiw	r28, 0x09	; 9
    20fc:	0f b6       	in	r0, 0x3f	; 63
    20fe:	f8 94       	cli
    2100:	de bf       	out	0x3e, r29	; 62
    2102:	0f be       	out	0x3f, r0	; 63
    2104:	cd bf       	out	0x3d, r28	; 61
    2106:	99 87       	std	Y+9, r25	; 0x09
    2108:	88 87       	std	Y+8, r24	; 0x08
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    210a:	88 85       	ldd	r24, Y+8	; 0x08
    210c:	99 85       	ldd	r25, Y+9	; 0x09
    210e:	9f 83       	std	Y+7, r25	; 0x07
    2110:	8e 83       	std	Y+6, r24	; 0x06
    BaseType_t xReturn = pdFAIL;
    2112:	1d 82       	std	Y+5, r1	; 0x05
    StreamBufferCallbackFunction_t pxSendCallback = NULL, pxReceiveCallback = NULL;
    2114:	1c 82       	std	Y+4, r1	; 0x04
    2116:	1b 82       	std	Y+3, r1	; 0x03
    2118:	1a 82       	std	Y+2, r1	; 0x02
    211a:	19 82       	std	Y+1, r1	; 0x01
        uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
    }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
    211c:	0f b6       	in	r0, 0x3f	; 63
    211e:	f8 94       	cli
    2120:	0f 92       	push	r0
    {
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
    2122:	ee 81       	ldd	r30, Y+6	; 0x06
    2124:	ff 81       	ldd	r31, Y+7	; 0x07
    2126:	80 85       	ldd	r24, Z+8	; 0x08
    2128:	91 85       	ldd	r25, Z+9	; 0x09
    212a:	00 97       	sbiw	r24, 0x00	; 0
    212c:	21 f5       	brne	.+72     	; 0x2176 <xStreamBufferReset+0x90>
    212e:	ee 81       	ldd	r30, Y+6	; 0x06
    2130:	ff 81       	ldd	r31, Y+7	; 0x07
    2132:	82 85       	ldd	r24, Z+10	; 0x0a
    2134:	93 85       	ldd	r25, Z+11	; 0x0b
    2136:	00 97       	sbiw	r24, 0x00	; 0
    2138:	f1 f4       	brne	.+60     	; 0x2176 <xStreamBufferReset+0x90>
                pxSendCallback = pxStreamBuffer->pxSendCompletedCallback;
                pxReceiveCallback = pxStreamBuffer->pxReceiveCompletedCallback;
            }
            #endif

            prvInitialiseNewStreamBuffer( pxStreamBuffer,
    213a:	ee 81       	ldd	r30, Y+6	; 0x06
    213c:	ff 81       	ldd	r31, Y+7	; 0x07
    213e:	44 85       	ldd	r20, Z+12	; 0x0c
    2140:	55 85       	ldd	r21, Z+13	; 0x0d
    2142:	ee 81       	ldd	r30, Y+6	; 0x06
    2144:	ff 81       	ldd	r31, Y+7	; 0x07
    2146:	24 81       	ldd	r18, Z+4	; 0x04
    2148:	35 81       	ldd	r19, Z+5	; 0x05
    214a:	ee 81       	ldd	r30, Y+6	; 0x06
    214c:	ff 81       	ldd	r31, Y+7	; 0x07
    214e:	a6 81       	ldd	r26, Z+6	; 0x06
    2150:	b7 81       	ldd	r27, Z+7	; 0x07
    2152:	ee 81       	ldd	r30, Y+6	; 0x06
    2154:	ff 81       	ldd	r31, Y+7	; 0x07
    2156:	16 85       	ldd	r17, Z+14	; 0x0e
    2158:	8e 81       	ldd	r24, Y+6	; 0x06
    215a:	9f 81       	ldd	r25, Y+7	; 0x07
    215c:	eb 81       	ldd	r30, Y+3	; 0x03
    215e:	fc 81       	ldd	r31, Y+4	; 0x04
    2160:	c9 80       	ldd	r12, Y+1	; 0x01
    2162:	da 80       	ldd	r13, Y+2	; 0x02
    2164:	ba 01       	movw	r22, r20
    2166:	a9 01       	movw	r20, r18
    2168:	9d 01       	movw	r18, r26
    216a:	01 2f       	mov	r16, r17
    216c:	7f 01       	movw	r14, r30
    216e:	0e 94 96 17 	call	0x2f2c	; 0x2f2c <prvInitialiseNewStreamBuffer>
            }
            #endif

            traceSTREAM_BUFFER_RESET( xStreamBuffer );

            xReturn = pdPASS;
    2172:	81 e0       	ldi	r24, 0x01	; 1
    2174:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    2176:	0f 90       	pop	r0
    2178:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    217a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    217c:	29 96       	adiw	r28, 0x09	; 9
    217e:	0f b6       	in	r0, 0x3f	; 63
    2180:	f8 94       	cli
    2182:	de bf       	out	0x3e, r29	; 62
    2184:	0f be       	out	0x3f, r0	; 63
    2186:	cd bf       	out	0x3d, r28	; 61
    2188:	cf 91       	pop	r28
    218a:	df 91       	pop	r29
    218c:	1f 91       	pop	r17
    218e:	0f 91       	pop	r16
    2190:	ff 90       	pop	r15
    2192:	ef 90       	pop	r14
    2194:	df 90       	pop	r13
    2196:	cf 90       	pop	r12
    2198:	08 95       	ret

0000219a <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
    219a:	df 93       	push	r29
    219c:	cf 93       	push	r28
    219e:	cd b7       	in	r28, 0x3d	; 61
    21a0:	de b7       	in	r29, 0x3e	; 62
    21a2:	27 97       	sbiw	r28, 0x07	; 7
    21a4:	0f b6       	in	r0, 0x3f	; 63
    21a6:	f8 94       	cli
    21a8:	de bf       	out	0x3e, r29	; 62
    21aa:	0f be       	out	0x3f, r0	; 63
    21ac:	cd bf       	out	0x3d, r28	; 61
    21ae:	9d 83       	std	Y+5, r25	; 0x05
    21b0:	8c 83       	std	Y+4, r24	; 0x04
    21b2:	7f 83       	std	Y+7, r23	; 0x07
    21b4:	6e 83       	std	Y+6, r22	; 0x06
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    21b6:	8c 81       	ldd	r24, Y+4	; 0x04
    21b8:	9d 81       	ldd	r25, Y+5	; 0x05
    21ba:	9b 83       	std	Y+3, r25	; 0x03
    21bc:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
    21be:	8e 81       	ldd	r24, Y+6	; 0x06
    21c0:	9f 81       	ldd	r25, Y+7	; 0x07
    21c2:	00 97       	sbiw	r24, 0x00	; 0
    21c4:	21 f4       	brne	.+8      	; 0x21ce <xStreamBufferSetTriggerLevel+0x34>
    {
        xTriggerLevel = ( size_t ) 1;
    21c6:	81 e0       	ldi	r24, 0x01	; 1
    21c8:	90 e0       	ldi	r25, 0x00	; 0
    21ca:	9f 83       	std	Y+7, r25	; 0x07
    21cc:	8e 83       	std	Y+6, r24	; 0x06
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
    21ce:	ea 81       	ldd	r30, Y+2	; 0x02
    21d0:	fb 81       	ldd	r31, Y+3	; 0x03
    21d2:	24 81       	ldd	r18, Z+4	; 0x04
    21d4:	35 81       	ldd	r19, Z+5	; 0x05
    21d6:	8e 81       	ldd	r24, Y+6	; 0x06
    21d8:	9f 81       	ldd	r25, Y+7	; 0x07
    21da:	82 17       	cp	r24, r18
    21dc:	93 07       	cpc	r25, r19
    21de:	48 f4       	brcc	.+18     	; 0x21f2 <xStreamBufferSetTriggerLevel+0x58>
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    21e0:	ea 81       	ldd	r30, Y+2	; 0x02
    21e2:	fb 81       	ldd	r31, Y+3	; 0x03
    21e4:	8e 81       	ldd	r24, Y+6	; 0x06
    21e6:	9f 81       	ldd	r25, Y+7	; 0x07
    21e8:	97 83       	std	Z+7, r25	; 0x07
    21ea:	86 83       	std	Z+6, r24	; 0x06
        xReturn = pdPASS;
    21ec:	81 e0       	ldi	r24, 0x01	; 1
    21ee:	89 83       	std	Y+1, r24	; 0x01
    21f0:	01 c0       	rjmp	.+2      	; 0x21f4 <xStreamBufferSetTriggerLevel+0x5a>
    }
    else
    {
        xReturn = pdFALSE;
    21f2:	19 82       	std	Y+1, r1	; 0x01
    }

    return xReturn;
    21f4:	89 81       	ldd	r24, Y+1	; 0x01
}
    21f6:	27 96       	adiw	r28, 0x07	; 7
    21f8:	0f b6       	in	r0, 0x3f	; 63
    21fa:	f8 94       	cli
    21fc:	de bf       	out	0x3e, r29	; 62
    21fe:	0f be       	out	0x3f, r0	; 63
    2200:	cd bf       	out	0x3d, r28	; 61
    2202:	cf 91       	pop	r28
    2204:	df 91       	pop	r29
    2206:	08 95       	ret

00002208 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2208:	df 93       	push	r29
    220a:	cf 93       	push	r28
    220c:	cd b7       	in	r28, 0x3d	; 61
    220e:	de b7       	in	r29, 0x3e	; 62
    2210:	28 97       	sbiw	r28, 0x08	; 8
    2212:	0f b6       	in	r0, 0x3f	; 63
    2214:	f8 94       	cli
    2216:	de bf       	out	0x3e, r29	; 62
    2218:	0f be       	out	0x3f, r0	; 63
    221a:	cd bf       	out	0x3d, r28	; 61
    221c:	98 87       	std	Y+8, r25	; 0x08
    221e:	8f 83       	std	Y+7, r24	; 0x07
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2220:	8f 81       	ldd	r24, Y+7	; 0x07
    2222:	98 85       	ldd	r25, Y+8	; 0x08
    2224:	9e 83       	std	Y+6, r25	; 0x06
    2226:	8d 83       	std	Y+5, r24	; 0x05
    /* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
    2228:	ed 81       	ldd	r30, Y+5	; 0x05
    222a:	fe 81       	ldd	r31, Y+6	; 0x06
    222c:	80 81       	ld	r24, Z
    222e:	91 81       	ldd	r25, Z+1	; 0x01
    2230:	9a 83       	std	Y+2, r25	; 0x02
    2232:	89 83       	std	Y+1, r24	; 0x01
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2234:	ed 81       	ldd	r30, Y+5	; 0x05
    2236:	fe 81       	ldd	r31, Y+6	; 0x06
    2238:	24 81       	ldd	r18, Z+4	; 0x04
    223a:	35 81       	ldd	r19, Z+5	; 0x05
    223c:	ed 81       	ldd	r30, Y+5	; 0x05
    223e:	fe 81       	ldd	r31, Y+6	; 0x06
    2240:	80 81       	ld	r24, Z
    2242:	91 81       	ldd	r25, Z+1	; 0x01
    2244:	82 0f       	add	r24, r18
    2246:	93 1f       	adc	r25, r19
    2248:	9c 83       	std	Y+4, r25	; 0x04
    224a:	8b 83       	std	Y+3, r24	; 0x03
        xSpace -= pxStreamBuffer->xHead;
    224c:	ed 81       	ldd	r30, Y+5	; 0x05
    224e:	fe 81       	ldd	r31, Y+6	; 0x06
    2250:	22 81       	ldd	r18, Z+2	; 0x02
    2252:	33 81       	ldd	r19, Z+3	; 0x03
    2254:	8b 81       	ldd	r24, Y+3	; 0x03
    2256:	9c 81       	ldd	r25, Y+4	; 0x04
    2258:	82 1b       	sub	r24, r18
    225a:	93 0b       	sbc	r25, r19
    225c:	9c 83       	std	Y+4, r25	; 0x04
    225e:	8b 83       	std	Y+3, r24	; 0x03
    } while( xOriginalTail != pxStreamBuffer->xTail );
    2260:	ed 81       	ldd	r30, Y+5	; 0x05
    2262:	fe 81       	ldd	r31, Y+6	; 0x06
    2264:	20 81       	ld	r18, Z
    2266:	31 81       	ldd	r19, Z+1	; 0x01
    2268:	89 81       	ldd	r24, Y+1	; 0x01
    226a:	9a 81       	ldd	r25, Y+2	; 0x02
    226c:	28 17       	cp	r18, r24
    226e:	39 07       	cpc	r19, r25
    2270:	d9 f6       	brne	.-74     	; 0x2228 <xStreamBufferSpacesAvailable+0x20>

    xSpace -= ( size_t ) 1;
    2272:	8b 81       	ldd	r24, Y+3	; 0x03
    2274:	9c 81       	ldd	r25, Y+4	; 0x04
    2276:	01 97       	sbiw	r24, 0x01	; 1
    2278:	9c 83       	std	Y+4, r25	; 0x04
    227a:	8b 83       	std	Y+3, r24	; 0x03

    if( xSpace >= pxStreamBuffer->xLength )
    227c:	ed 81       	ldd	r30, Y+5	; 0x05
    227e:	fe 81       	ldd	r31, Y+6	; 0x06
    2280:	24 81       	ldd	r18, Z+4	; 0x04
    2282:	35 81       	ldd	r19, Z+5	; 0x05
    2284:	8b 81       	ldd	r24, Y+3	; 0x03
    2286:	9c 81       	ldd	r25, Y+4	; 0x04
    2288:	82 17       	cp	r24, r18
    228a:	93 07       	cpc	r25, r19
    228c:	50 f0       	brcs	.+20     	; 0x22a2 <xStreamBufferSpacesAvailable+0x9a>
    {
        xSpace -= pxStreamBuffer->xLength;
    228e:	ed 81       	ldd	r30, Y+5	; 0x05
    2290:	fe 81       	ldd	r31, Y+6	; 0x06
    2292:	24 81       	ldd	r18, Z+4	; 0x04
    2294:	35 81       	ldd	r19, Z+5	; 0x05
    2296:	8b 81       	ldd	r24, Y+3	; 0x03
    2298:	9c 81       	ldd	r25, Y+4	; 0x04
    229a:	82 1b       	sub	r24, r18
    229c:	93 0b       	sbc	r25, r19
    229e:	9c 83       	std	Y+4, r25	; 0x04
    22a0:	8b 83       	std	Y+3, r24	; 0x03
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
    22a2:	8b 81       	ldd	r24, Y+3	; 0x03
    22a4:	9c 81       	ldd	r25, Y+4	; 0x04
}
    22a6:	28 96       	adiw	r28, 0x08	; 8
    22a8:	0f b6       	in	r0, 0x3f	; 63
    22aa:	f8 94       	cli
    22ac:	de bf       	out	0x3e, r29	; 62
    22ae:	0f be       	out	0x3f, r0	; 63
    22b0:	cd bf       	out	0x3d, r28	; 61
    22b2:	cf 91       	pop	r28
    22b4:	df 91       	pop	r29
    22b6:	08 95       	ret

000022b8 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    22b8:	df 93       	push	r29
    22ba:	cf 93       	push	r28
    22bc:	00 d0       	rcall	.+0      	; 0x22be <xStreamBufferBytesAvailable+0x6>
    22be:	00 d0       	rcall	.+0      	; 0x22c0 <xStreamBufferBytesAvailable+0x8>
    22c0:	00 d0       	rcall	.+0      	; 0x22c2 <xStreamBufferBytesAvailable+0xa>
    22c2:	cd b7       	in	r28, 0x3d	; 61
    22c4:	de b7       	in	r29, 0x3e	; 62
    22c6:	9e 83       	std	Y+6, r25	; 0x06
    22c8:	8d 83       	std	Y+5, r24	; 0x05
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    22ca:	8d 81       	ldd	r24, Y+5	; 0x05
    22cc:	9e 81       	ldd	r25, Y+6	; 0x06
    22ce:	9c 83       	std	Y+4, r25	; 0x04
    22d0:	8b 83       	std	Y+3, r24	; 0x03
    size_t xReturn;

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
    22d2:	8b 81       	ldd	r24, Y+3	; 0x03
    22d4:	9c 81       	ldd	r25, Y+4	; 0x04
    22d6:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <prvBytesInBuffer>
    22da:	9a 83       	std	Y+2, r25	; 0x02
    22dc:	89 83       	std	Y+1, r24	; 0x01
    return xReturn;
    22de:	89 81       	ldd	r24, Y+1	; 0x01
    22e0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    22e2:	26 96       	adiw	r28, 0x06	; 6
    22e4:	0f b6       	in	r0, 0x3f	; 63
    22e6:	f8 94       	cli
    22e8:	de bf       	out	0x3e, r29	; 62
    22ea:	0f be       	out	0x3f, r0	; 63
    22ec:	cd bf       	out	0x3d, r28	; 61
    22ee:	cf 91       	pop	r28
    22f0:	df 91       	pop	r29
    22f2:	08 95       	ret

000022f4 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
    22f4:	cf 92       	push	r12
    22f6:	df 92       	push	r13
    22f8:	ef 92       	push	r14
    22fa:	ff 92       	push	r15
    22fc:	0f 93       	push	r16
    22fe:	1f 93       	push	r17
    2300:	df 93       	push	r29
    2302:	cf 93       	push	r28
    2304:	cd b7       	in	r28, 0x3d	; 61
    2306:	de b7       	in	r29, 0x3e	; 62
    2308:	65 97       	sbiw	r28, 0x15	; 21
    230a:	0f b6       	in	r0, 0x3f	; 63
    230c:	f8 94       	cli
    230e:	de bf       	out	0x3e, r29	; 62
    2310:	0f be       	out	0x3f, r0	; 63
    2312:	cd bf       	out	0x3d, r28	; 61
    2314:	9f 87       	std	Y+15, r25	; 0x0f
    2316:	8e 87       	std	Y+14, r24	; 0x0e
    2318:	79 8b       	std	Y+17, r23	; 0x11
    231a:	68 8b       	std	Y+16, r22	; 0x10
    231c:	5b 8b       	std	Y+19, r21	; 0x13
    231e:	4a 8b       	std	Y+18, r20	; 0x12
    2320:	3d 8b       	std	Y+21, r19	; 0x15
    2322:	2c 8b       	std	Y+20, r18	; 0x14
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2324:	8e 85       	ldd	r24, Y+14	; 0x0e
    2326:	9f 85       	ldd	r25, Y+15	; 0x0f
    2328:	9a 87       	std	Y+10, r25	; 0x0a
    232a:	89 87       	std	Y+9, r24	; 0x09
    size_t xReturn, xSpace = 0;
    232c:	1e 82       	std	Y+6, r1	; 0x06
    232e:	1d 82       	std	Y+5, r1	; 0x05
    size_t xRequiredSpace = xDataLengthBytes;
    2330:	8a 89       	ldd	r24, Y+18	; 0x12
    2332:	9b 89       	ldd	r25, Y+19	; 0x13
    2334:	9c 83       	std	Y+4, r25	; 0x04
    2336:	8b 83       	std	Y+3, r24	; 0x03
    TimeOut_t xTimeOut;
    size_t xMaxReportedSpace = 0;
    2338:	1a 82       	std	Y+2, r1	; 0x02
    233a:	19 82       	std	Y+1, r1	; 0x01
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
    233c:	e9 85       	ldd	r30, Y+9	; 0x09
    233e:	fa 85       	ldd	r31, Y+10	; 0x0a
    2340:	84 81       	ldd	r24, Z+4	; 0x04
    2342:	95 81       	ldd	r25, Z+5	; 0x05
    2344:	01 97       	sbiw	r24, 0x01	; 1
    2346:	9a 83       	std	Y+2, r25	; 0x02
    2348:	89 83       	std	Y+1, r24	; 0x01

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    234a:	e9 85       	ldd	r30, Y+9	; 0x09
    234c:	fa 85       	ldd	r31, Y+10	; 0x0a
    234e:	86 85       	ldd	r24, Z+14	; 0x0e
    2350:	88 2f       	mov	r24, r24
    2352:	90 e0       	ldi	r25, 0x00	; 0
    2354:	81 70       	andi	r24, 0x01	; 1
    2356:	90 70       	andi	r25, 0x00	; 0
    2358:	88 23       	and	r24, r24
    235a:	79 f0       	breq	.+30     	; 0x237a <xStreamBufferSend+0x86>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    235c:	8b 81       	ldd	r24, Y+3	; 0x03
    235e:	9c 81       	ldd	r25, Y+4	; 0x04
    2360:	02 96       	adiw	r24, 0x02	; 2
    2362:	9c 83       	std	Y+4, r25	; 0x04
    2364:	8b 83       	std	Y+3, r24	; 0x03
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
    2366:	2b 81       	ldd	r18, Y+3	; 0x03
    2368:	3c 81       	ldd	r19, Y+4	; 0x04
    236a:	89 81       	ldd	r24, Y+1	; 0x01
    236c:	9a 81       	ldd	r25, Y+2	; 0x02
    236e:	82 17       	cp	r24, r18
    2370:	93 07       	cpc	r25, r19
    2372:	70 f4       	brcc	.+28     	; 0x2390 <xStreamBufferSend+0x9c>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
    2374:	1d 8a       	std	Y+21, r1	; 0x15
    2376:	1c 8a       	std	Y+20, r1	; 0x14
    2378:	0b c0       	rjmp	.+22     	; 0x2390 <xStreamBufferSend+0x9c>
    else
    {
        /* If this is a stream buffer then it is acceptable to write only part
         * of the message to the buffer.  Cap the length to the total length of
         * the buffer. */
        if( xRequiredSpace > xMaxReportedSpace )
    237a:	2b 81       	ldd	r18, Y+3	; 0x03
    237c:	3c 81       	ldd	r19, Y+4	; 0x04
    237e:	89 81       	ldd	r24, Y+1	; 0x01
    2380:	9a 81       	ldd	r25, Y+2	; 0x02
    2382:	82 17       	cp	r24, r18
    2384:	93 07       	cpc	r25, r19
    2386:	20 f4       	brcc	.+8      	; 0x2390 <xStreamBufferSend+0x9c>
        {
            xRequiredSpace = xMaxReportedSpace;
    2388:	89 81       	ldd	r24, Y+1	; 0x01
    238a:	9a 81       	ldd	r25, Y+2	; 0x02
    238c:	9c 83       	std	Y+4, r25	; 0x04
    238e:	8b 83       	std	Y+3, r24	; 0x03
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    2390:	8c 89       	ldd	r24, Y+20	; 0x14
    2392:	9d 89       	ldd	r25, Y+21	; 0x15
    2394:	00 97       	sbiw	r24, 0x00	; 0
    2396:	09 f4       	brne	.+2      	; 0x239a <xStreamBufferSend+0xa6>
    2398:	43 c0       	rjmp	.+134    	; 0x2420 <xStreamBufferSend+0x12c>
    {
        vTaskSetTimeOutState( &xTimeOut );
    239a:	ce 01       	movw	r24, r28
    239c:	0b 96       	adiw	r24, 0x0b	; 11
    239e:	0e 94 3e 22 	call	0x447c	; 0x447c <vTaskSetTimeOutState>

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
    23a2:	0f b6       	in	r0, 0x3f	; 63
    23a4:	f8 94       	cli
    23a6:	0f 92       	push	r0
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    23a8:	89 85       	ldd	r24, Y+9	; 0x09
    23aa:	9a 85       	ldd	r25, Y+10	; 0x0a
    23ac:	0e 94 04 11 	call	0x2208	; 0x2208 <xStreamBufferSpacesAvailable>
    23b0:	9e 83       	std	Y+6, r25	; 0x06
    23b2:	8d 83       	std	Y+5, r24	; 0x05

                if( xSpace < xRequiredSpace )
    23b4:	2d 81       	ldd	r18, Y+5	; 0x05
    23b6:	3e 81       	ldd	r19, Y+6	; 0x06
    23b8:	8b 81       	ldd	r24, Y+3	; 0x03
    23ba:	9c 81       	ldd	r25, Y+4	; 0x04
    23bc:	28 17       	cp	r18, r24
    23be:	39 07       	cpc	r19, r25
    23c0:	68 f5       	brcc	.+90     	; 0x241c <xStreamBufferSend+0x128>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
    23c2:	80 e0       	ldi	r24, 0x00	; 0
    23c4:	90 e0       	ldi	r25, 0x00	; 0
    23c6:	60 e0       	ldi	r22, 0x00	; 0
    23c8:	0e 94 a6 2a 	call	0x554c	; 0x554c <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    23cc:	0e 94 9a 23 	call	0x4734	; 0x4734 <xTaskGetCurrentTaskHandle>
    23d0:	e9 85       	ldd	r30, Y+9	; 0x09
    23d2:	fa 85       	ldd	r31, Y+10	; 0x0a
    23d4:	93 87       	std	Z+11, r25	; 0x0b
    23d6:	82 87       	std	Z+10, r24	; 0x0a
                {
                    taskEXIT_CRITICAL();
                    break;
                }
            }
            taskEXIT_CRITICAL();
    23d8:	0f 90       	pop	r0
    23da:	0f be       	out	0x3f, r0	; 63

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    23dc:	ec 89       	ldd	r30, Y+20	; 0x14
    23de:	fd 89       	ldd	r31, Y+21	; 0x15
    23e0:	80 e0       	ldi	r24, 0x00	; 0
    23e2:	40 e0       	ldi	r20, 0x00	; 0
    23e4:	50 e0       	ldi	r21, 0x00	; 0
    23e6:	60 e0       	ldi	r22, 0x00	; 0
    23e8:	70 e0       	ldi	r23, 0x00	; 0
    23ea:	00 e0       	ldi	r16, 0x00	; 0
    23ec:	10 e0       	ldi	r17, 0x00	; 0
    23ee:	20 e0       	ldi	r18, 0x00	; 0
    23f0:	30 e0       	ldi	r19, 0x00	; 0
    23f2:	ee 24       	eor	r14, r14
    23f4:	ff 24       	eor	r15, r15
    23f6:	6f 01       	movw	r12, r30
    23f8:	0e 94 a2 24 	call	0x4944	; 0x4944 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
    23fc:	e9 85       	ldd	r30, Y+9	; 0x09
    23fe:	fa 85       	ldd	r31, Y+10	; 0x0a
    2400:	13 86       	std	Z+11, r1	; 0x0b
    2402:	12 86       	std	Z+10, r1	; 0x0a
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    2404:	ce 01       	movw	r24, r28
    2406:	0b 96       	adiw	r24, 0x0b	; 11
    2408:	9e 01       	movw	r18, r28
    240a:	2c 5e       	subi	r18, 0xEC	; 236
    240c:	3f 4f       	sbci	r19, 0xFF	; 255
    240e:	b9 01       	movw	r22, r18
    2410:	0e 94 75 22 	call	0x44ea	; 0x44ea <xTaskCheckForTimeOut>
    2414:	88 23       	and	r24, r24
    2416:	09 f4       	brne	.+2      	; 0x241a <xStreamBufferSend+0x126>
    2418:	c4 cf       	rjmp	.-120    	; 0x23a2 <xStreamBufferSend+0xae>
    241a:	02 c0       	rjmp	.+4      	; 0x2420 <xStreamBufferSend+0x12c>
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
                }
                else
                {
                    taskEXIT_CRITICAL();
    241c:	0f 90       	pop	r0
    241e:	0f be       	out	0x3f, r0	; 63
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
    2420:	8d 81       	ldd	r24, Y+5	; 0x05
    2422:	9e 81       	ldd	r25, Y+6	; 0x06
    2424:	00 97       	sbiw	r24, 0x00	; 0
    2426:	31 f4       	brne	.+12     	; 0x2434 <xStreamBufferSend+0x140>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2428:	89 85       	ldd	r24, Y+9	; 0x09
    242a:	9a 85       	ldd	r25, Y+10	; 0x0a
    242c:	0e 94 04 11 	call	0x2208	; 0x2208 <xStreamBufferSpacesAvailable>
    2430:	9e 83       	std	Y+6, r25	; 0x06
    2432:	8d 83       	std	Y+5, r24	; 0x05
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2434:	89 85       	ldd	r24, Y+9	; 0x09
    2436:	9a 85       	ldd	r25, Y+10	; 0x0a
    2438:	28 89       	ldd	r18, Y+16	; 0x10
    243a:	39 89       	ldd	r19, Y+17	; 0x11
    243c:	4a 89       	ldd	r20, Y+18	; 0x12
    243e:	5b 89       	ldd	r21, Y+19	; 0x13
    2440:	ed 81       	ldd	r30, Y+5	; 0x05
    2442:	fe 81       	ldd	r31, Y+6	; 0x06
    2444:	ab 81       	ldd	r26, Y+3	; 0x03
    2446:	bc 81       	ldd	r27, Y+4	; 0x04
    2448:	b9 01       	movw	r22, r18
    244a:	9f 01       	movw	r18, r30
    244c:	8d 01       	movw	r16, r26
    244e:	0e 94 ea 12 	call	0x25d4	; 0x25d4 <prvWriteMessageToBuffer>
    2452:	98 87       	std	Y+8, r25	; 0x08
    2454:	8f 83       	std	Y+7, r24	; 0x07

    if( xReturn > ( size_t ) 0 )
    2456:	8f 81       	ldd	r24, Y+7	; 0x07
    2458:	98 85       	ldd	r25, Y+8	; 0x08
    245a:	00 97       	sbiw	r24, 0x00	; 0
    245c:	41 f1       	breq	.+80     	; 0x24ae <xStreamBufferSend+0x1ba>
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    245e:	89 85       	ldd	r24, Y+9	; 0x09
    2460:	9a 85       	ldd	r25, Y+10	; 0x0a
    2462:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <prvBytesInBuffer>
    2466:	9c 01       	movw	r18, r24
    2468:	e9 85       	ldd	r30, Y+9	; 0x09
    246a:	fa 85       	ldd	r31, Y+10	; 0x0a
    246c:	86 81       	ldd	r24, Z+6	; 0x06
    246e:	97 81       	ldd	r25, Z+7	; 0x07
    2470:	28 17       	cp	r18, r24
    2472:	39 07       	cpc	r19, r25
    2474:	e0 f0       	brcs	.+56     	; 0x24ae <xStreamBufferSend+0x1ba>
        {
            prvSEND_COMPLETED( pxStreamBuffer );
    2476:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskSuspendAll>
    247a:	e9 85       	ldd	r30, Y+9	; 0x09
    247c:	fa 85       	ldd	r31, Y+10	; 0x0a
    247e:	80 85       	ldd	r24, Z+8	; 0x08
    2480:	91 85       	ldd	r25, Z+9	; 0x09
    2482:	00 97       	sbiw	r24, 0x00	; 0
    2484:	91 f0       	breq	.+36     	; 0x24aa <xStreamBufferSend+0x1b6>
    2486:	e9 85       	ldd	r30, Y+9	; 0x09
    2488:	fa 85       	ldd	r31, Y+10	; 0x0a
    248a:	80 85       	ldd	r24, Z+8	; 0x08
    248c:	91 85       	ldd	r25, Z+9	; 0x09
    248e:	60 e0       	ldi	r22, 0x00	; 0
    2490:	20 e0       	ldi	r18, 0x00	; 0
    2492:	30 e0       	ldi	r19, 0x00	; 0
    2494:	40 e0       	ldi	r20, 0x00	; 0
    2496:	50 e0       	ldi	r21, 0x00	; 0
    2498:	00 e0       	ldi	r16, 0x00	; 0
    249a:	ee 24       	eor	r14, r14
    249c:	ff 24       	eor	r15, r15
    249e:	0e 94 99 25 	call	0x4b32	; 0x4b32 <xTaskGenericNotify>
    24a2:	e9 85       	ldd	r30, Y+9	; 0x09
    24a4:	fa 85       	ldd	r31, Y+10	; 0x0a
    24a6:	11 86       	std	Z+9, r1	; 0x09
    24a8:	10 86       	std	Z+8, r1	; 0x08
    24aa:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
    {
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
    24ae:	8f 81       	ldd	r24, Y+7	; 0x07
    24b0:	98 85       	ldd	r25, Y+8	; 0x08
}
    24b2:	65 96       	adiw	r28, 0x15	; 21
    24b4:	0f b6       	in	r0, 0x3f	; 63
    24b6:	f8 94       	cli
    24b8:	de bf       	out	0x3e, r29	; 62
    24ba:	0f be       	out	0x3f, r0	; 63
    24bc:	cd bf       	out	0x3d, r28	; 61
    24be:	cf 91       	pop	r28
    24c0:	df 91       	pop	r29
    24c2:	1f 91       	pop	r17
    24c4:	0f 91       	pop	r16
    24c6:	ff 90       	pop	r15
    24c8:	ef 90       	pop	r14
    24ca:	df 90       	pop	r13
    24cc:	cf 90       	pop	r12
    24ce:	08 95       	ret

000024d0 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    24d0:	cf 92       	push	r12
    24d2:	df 92       	push	r13
    24d4:	ef 92       	push	r14
    24d6:	ff 92       	push	r15
    24d8:	0f 93       	push	r16
    24da:	1f 93       	push	r17
    24dc:	df 93       	push	r29
    24de:	cf 93       	push	r28
    24e0:	cd b7       	in	r28, 0x3d	; 61
    24e2:	de b7       	in	r29, 0x3e	; 62
    24e4:	61 97       	sbiw	r28, 0x11	; 17
    24e6:	0f b6       	in	r0, 0x3f	; 63
    24e8:	f8 94       	cli
    24ea:	de bf       	out	0x3e, r29	; 62
    24ec:	0f be       	out	0x3f, r0	; 63
    24ee:	cd bf       	out	0x3d, r28	; 61
    24f0:	9b 87       	std	Y+11, r25	; 0x0b
    24f2:	8a 87       	std	Y+10, r24	; 0x0a
    24f4:	7d 87       	std	Y+13, r23	; 0x0d
    24f6:	6c 87       	std	Y+12, r22	; 0x0c
    24f8:	5f 87       	std	Y+15, r21	; 0x0f
    24fa:	4e 87       	std	Y+14, r20	; 0x0e
    24fc:	39 8b       	std	Y+17, r19	; 0x11
    24fe:	28 8b       	std	Y+16, r18	; 0x10
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2500:	8a 85       	ldd	r24, Y+10	; 0x0a
    2502:	9b 85       	ldd	r25, Y+11	; 0x0b
    2504:	99 87       	std	Y+9, r25	; 0x09
    2506:	88 87       	std	Y+8, r24	; 0x08
    size_t xReturn, xSpace;
    size_t xRequiredSpace = xDataLengthBytes;
    2508:	8e 85       	ldd	r24, Y+14	; 0x0e
    250a:	9f 85       	ldd	r25, Y+15	; 0x0f
    250c:	9b 83       	std	Y+3, r25	; 0x03
    250e:	8a 83       	std	Y+2, r24	; 0x02

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2510:	e8 85       	ldd	r30, Y+8	; 0x08
    2512:	f9 85       	ldd	r31, Y+9	; 0x09
    2514:	86 85       	ldd	r24, Z+14	; 0x0e
    2516:	88 2f       	mov	r24, r24
    2518:	90 e0       	ldi	r25, 0x00	; 0
    251a:	81 70       	andi	r24, 0x01	; 1
    251c:	90 70       	andi	r25, 0x00	; 0
    251e:	88 23       	and	r24, r24
    2520:	29 f0       	breq	.+10     	; 0x252c <xStreamBufferSendFromISR+0x5c>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2522:	8a 81       	ldd	r24, Y+2	; 0x02
    2524:	9b 81       	ldd	r25, Y+3	; 0x03
    2526:	02 96       	adiw	r24, 0x02	; 2
    2528:	9b 83       	std	Y+3, r25	; 0x03
    252a:	8a 83       	std	Y+2, r24	; 0x02
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    252c:	88 85       	ldd	r24, Y+8	; 0x08
    252e:	99 85       	ldd	r25, Y+9	; 0x09
    2530:	0e 94 04 11 	call	0x2208	; 0x2208 <xStreamBufferSpacesAvailable>
    2534:	9d 83       	std	Y+5, r25	; 0x05
    2536:	8c 83       	std	Y+4, r24	; 0x04
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2538:	88 85       	ldd	r24, Y+8	; 0x08
    253a:	99 85       	ldd	r25, Y+9	; 0x09
    253c:	2c 85       	ldd	r18, Y+12	; 0x0c
    253e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2540:	4e 85       	ldd	r20, Y+14	; 0x0e
    2542:	5f 85       	ldd	r21, Y+15	; 0x0f
    2544:	ec 81       	ldd	r30, Y+4	; 0x04
    2546:	fd 81       	ldd	r31, Y+5	; 0x05
    2548:	aa 81       	ldd	r26, Y+2	; 0x02
    254a:	bb 81       	ldd	r27, Y+3	; 0x03
    254c:	b9 01       	movw	r22, r18
    254e:	9f 01       	movw	r18, r30
    2550:	8d 01       	movw	r16, r26
    2552:	0e 94 ea 12 	call	0x25d4	; 0x25d4 <prvWriteMessageToBuffer>
    2556:	9f 83       	std	Y+7, r25	; 0x07
    2558:	8e 83       	std	Y+6, r24	; 0x06

    if( xReturn > ( size_t ) 0 )
    255a:	8e 81       	ldd	r24, Y+6	; 0x06
    255c:	9f 81       	ldd	r25, Y+7	; 0x07
    255e:	00 97       	sbiw	r24, 0x00	; 0
    2560:	41 f1       	breq	.+80     	; 0x25b2 <xStreamBufferSendFromISR+0xe2>
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2562:	88 85       	ldd	r24, Y+8	; 0x08
    2564:	99 85       	ldd	r25, Y+9	; 0x09
    2566:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <prvBytesInBuffer>
    256a:	9c 01       	movw	r18, r24
    256c:	e8 85       	ldd	r30, Y+8	; 0x08
    256e:	f9 85       	ldd	r31, Y+9	; 0x09
    2570:	86 81       	ldd	r24, Z+6	; 0x06
    2572:	97 81       	ldd	r25, Z+7	; 0x07
    2574:	28 17       	cp	r18, r24
    2576:	39 07       	cpc	r19, r25
    2578:	e0 f0       	brcs	.+56     	; 0x25b2 <xStreamBufferSendFromISR+0xe2>
        {
            prvSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    257a:	19 82       	std	Y+1, r1	; 0x01
    257c:	e8 85       	ldd	r30, Y+8	; 0x08
    257e:	f9 85       	ldd	r31, Y+9	; 0x09
    2580:	80 85       	ldd	r24, Z+8	; 0x08
    2582:	91 85       	ldd	r25, Z+9	; 0x09
    2584:	00 97       	sbiw	r24, 0x00	; 0
    2586:	a9 f0       	breq	.+42     	; 0x25b2 <xStreamBufferSendFromISR+0xe2>
    2588:	e8 85       	ldd	r30, Y+8	; 0x08
    258a:	f9 85       	ldd	r31, Y+9	; 0x09
    258c:	80 85       	ldd	r24, Z+8	; 0x08
    258e:	91 85       	ldd	r25, Z+9	; 0x09
    2590:	e8 89       	ldd	r30, Y+16	; 0x10
    2592:	f9 89       	ldd	r31, Y+17	; 0x11
    2594:	60 e0       	ldi	r22, 0x00	; 0
    2596:	20 e0       	ldi	r18, 0x00	; 0
    2598:	30 e0       	ldi	r19, 0x00	; 0
    259a:	40 e0       	ldi	r20, 0x00	; 0
    259c:	50 e0       	ldi	r21, 0x00	; 0
    259e:	00 e0       	ldi	r16, 0x00	; 0
    25a0:	ee 24       	eor	r14, r14
    25a2:	ff 24       	eor	r15, r15
    25a4:	6f 01       	movw	r12, r30
    25a6:	0e 94 57 27 	call	0x4eae	; 0x4eae <xTaskGenericNotifyFromISR>
    25aa:	e8 85       	ldd	r30, Y+8	; 0x08
    25ac:	f9 85       	ldd	r31, Y+9	; 0x09
    25ae:	11 86       	std	Z+9, r1	; 0x09
    25b0:	10 86       	std	Z+8, r1	; 0x08
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
    25b2:	8e 81       	ldd	r24, Y+6	; 0x06
    25b4:	9f 81       	ldd	r25, Y+7	; 0x07
}
    25b6:	61 96       	adiw	r28, 0x11	; 17
    25b8:	0f b6       	in	r0, 0x3f	; 63
    25ba:	f8 94       	cli
    25bc:	de bf       	out	0x3e, r29	; 62
    25be:	0f be       	out	0x3f, r0	; 63
    25c0:	cd bf       	out	0x3d, r28	; 61
    25c2:	cf 91       	pop	r28
    25c4:	df 91       	pop	r29
    25c6:	1f 91       	pop	r17
    25c8:	0f 91       	pop	r16
    25ca:	ff 90       	pop	r15
    25cc:	ef 90       	pop	r14
    25ce:	df 90       	pop	r13
    25d0:	cf 90       	pop	r12
    25d2:	08 95       	ret

000025d4 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
    25d4:	0f 93       	push	r16
    25d6:	1f 93       	push	r17
    25d8:	df 93       	push	r29
    25da:	cf 93       	push	r28
    25dc:	cd b7       	in	r28, 0x3d	; 61
    25de:	de b7       	in	r29, 0x3e	; 62
    25e0:	62 97       	sbiw	r28, 0x12	; 18
    25e2:	0f b6       	in	r0, 0x3f	; 63
    25e4:	f8 94       	cli
    25e6:	de bf       	out	0x3e, r29	; 62
    25e8:	0f be       	out	0x3f, r0	; 63
    25ea:	cd bf       	out	0x3d, r28	; 61
    25ec:	9e 83       	std	Y+6, r25	; 0x06
    25ee:	8d 83       	std	Y+5, r24	; 0x05
    25f0:	78 87       	std	Y+8, r23	; 0x08
    25f2:	6f 83       	std	Y+7, r22	; 0x07
    25f4:	5a 87       	std	Y+10, r21	; 0x0a
    25f6:	49 87       	std	Y+9, r20	; 0x09
    25f8:	3c 87       	std	Y+12, r19	; 0x0c
    25fa:	2b 87       	std	Y+11, r18	; 0x0b
    25fc:	1e 87       	std	Y+14, r17	; 0x0e
    25fe:	0d 87       	std	Y+13, r16	; 0x0d
    size_t xNextHead = pxStreamBuffer->xHead;
    2600:	ed 81       	ldd	r30, Y+5	; 0x05
    2602:	fe 81       	ldd	r31, Y+6	; 0x06
    2604:	82 81       	ldd	r24, Z+2	; 0x02
    2606:	93 81       	ldd	r25, Z+3	; 0x03
    2608:	9a 83       	std	Y+2, r25	; 0x02
    260a:	89 83       	std	Y+1, r24	; 0x01
    configMESSAGE_BUFFER_LENGTH_TYPE xMessageLength;

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    260c:	ed 81       	ldd	r30, Y+5	; 0x05
    260e:	fe 81       	ldd	r31, Y+6	; 0x06
    2610:	86 85       	ldd	r24, Z+14	; 0x0e
    2612:	88 2f       	mov	r24, r24
    2614:	90 e0       	ldi	r25, 0x00	; 0
    2616:	81 70       	andi	r24, 0x01	; 1
    2618:	90 70       	andi	r25, 0x00	; 0
    261a:	88 23       	and	r24, r24
    261c:	f1 f0       	breq	.+60     	; 0x265a <prvWriteMessageToBuffer+0x86>
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        /* Convert xDataLengthBytes to the message length type. */
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;
    261e:	89 85       	ldd	r24, Y+9	; 0x09
    2620:	9a 85       	ldd	r25, Y+10	; 0x0a
    2622:	9c 83       	std	Y+4, r25	; 0x04
    2624:	8b 83       	std	Y+3, r24	; 0x03

        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */
        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );

        if( xSpace >= xRequiredSpace )
    2626:	2b 85       	ldd	r18, Y+11	; 0x0b
    2628:	3c 85       	ldd	r19, Y+12	; 0x0c
    262a:	8d 85       	ldd	r24, Y+13	; 0x0d
    262c:	9e 85       	ldd	r25, Y+14	; 0x0e
    262e:	28 17       	cp	r18, r24
    2630:	39 07       	cpc	r19, r25
    2632:	80 f0       	brcs	.+32     	; 0x2654 <prvWriteMessageToBuffer+0x80>
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
    2634:	9e 01       	movw	r18, r28
    2636:	2d 5f       	subi	r18, 0xFD	; 253
    2638:	3f 4f       	sbci	r19, 0xFF	; 255
    263a:	8d 81       	ldd	r24, Y+5	; 0x05
    263c:	9e 81       	ldd	r25, Y+6	; 0x06
    263e:	e9 81       	ldd	r30, Y+1	; 0x01
    2640:	fa 81       	ldd	r31, Y+2	; 0x02
    2642:	b9 01       	movw	r22, r18
    2644:	42 e0       	ldi	r20, 0x02	; 2
    2646:	50 e0       	ldi	r21, 0x00	; 0
    2648:	9f 01       	movw	r18, r30
    264a:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <prvWriteBytesToBuffer>
    264e:	9a 83       	std	Y+2, r25	; 0x02
    2650:	89 83       	std	Y+1, r24	; 0x01
    2652:	1a c0       	rjmp	.+52     	; 0x2688 <prvWriteMessageToBuffer+0xb4>
        }
        else
        {
            /* Not enough space, so do not write data to the buffer. */
            xDataLengthBytes = 0;
    2654:	1a 86       	std	Y+10, r1	; 0x0a
    2656:	19 86       	std	Y+9, r1	; 0x09
    2658:	17 c0       	rjmp	.+46     	; 0x2688 <prvWriteMessageToBuffer+0xb4>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    265a:	29 85       	ldd	r18, Y+9	; 0x09
    265c:	3a 85       	ldd	r19, Y+10	; 0x0a
    265e:	3a 8b       	std	Y+18, r19	; 0x12
    2660:	29 8b       	std	Y+17, r18	; 0x11
    2662:	8b 85       	ldd	r24, Y+11	; 0x0b
    2664:	9c 85       	ldd	r25, Y+12	; 0x0c
    2666:	98 8b       	std	Y+16, r25	; 0x10
    2668:	8f 87       	std	Y+15, r24	; 0x0f
    266a:	2f 85       	ldd	r18, Y+15	; 0x0f
    266c:	38 89       	ldd	r19, Y+16	; 0x10
    266e:	89 89       	ldd	r24, Y+17	; 0x11
    2670:	9a 89       	ldd	r25, Y+18	; 0x12
    2672:	82 17       	cp	r24, r18
    2674:	93 07       	cpc	r25, r19
    2676:	20 f4       	brcc	.+8      	; 0x2680 <prvWriteMessageToBuffer+0xac>
    2678:	29 89       	ldd	r18, Y+17	; 0x11
    267a:	3a 89       	ldd	r19, Y+18	; 0x12
    267c:	38 8b       	std	Y+16, r19	; 0x10
    267e:	2f 87       	std	Y+15, r18	; 0x0f
    2680:	8f 85       	ldd	r24, Y+15	; 0x0f
    2682:	98 89       	ldd	r25, Y+16	; 0x10
    2684:	9a 87       	std	Y+10, r25	; 0x0a
    2686:	89 87       	std	Y+9, r24	; 0x09
    }

    if( xDataLengthBytes != ( size_t ) 0 )
    2688:	89 85       	ldd	r24, Y+9	; 0x09
    268a:	9a 85       	ldd	r25, Y+10	; 0x0a
    268c:	00 97       	sbiw	r24, 0x00	; 0
    268e:	89 f0       	breq	.+34     	; 0x26b2 <prvWriteMessageToBuffer+0xde>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
    2690:	4f 81       	ldd	r20, Y+7	; 0x07
    2692:	58 85       	ldd	r21, Y+8	; 0x08
    2694:	8d 81       	ldd	r24, Y+5	; 0x05
    2696:	9e 81       	ldd	r25, Y+6	; 0x06
    2698:	29 85       	ldd	r18, Y+9	; 0x09
    269a:	3a 85       	ldd	r19, Y+10	; 0x0a
    269c:	e9 81       	ldd	r30, Y+1	; 0x01
    269e:	fa 81       	ldd	r31, Y+2	; 0x02
    26a0:	ba 01       	movw	r22, r20
    26a2:	a9 01       	movw	r20, r18
    26a4:	9f 01       	movw	r18, r30
    26a6:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <prvWriteBytesToBuffer>
    26aa:	ed 81       	ldd	r30, Y+5	; 0x05
    26ac:	fe 81       	ldd	r31, Y+6	; 0x06
    26ae:	93 83       	std	Z+3, r25	; 0x03
    26b0:	82 83       	std	Z+2, r24	; 0x02
    }

    return xDataLengthBytes;
    26b2:	89 85       	ldd	r24, Y+9	; 0x09
    26b4:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    26b6:	62 96       	adiw	r28, 0x12	; 18
    26b8:	0f b6       	in	r0, 0x3f	; 63
    26ba:	f8 94       	cli
    26bc:	de bf       	out	0x3e, r29	; 62
    26be:	0f be       	out	0x3f, r0	; 63
    26c0:	cd bf       	out	0x3d, r28	; 61
    26c2:	cf 91       	pop	r28
    26c4:	df 91       	pop	r29
    26c6:	1f 91       	pop	r17
    26c8:	0f 91       	pop	r16
    26ca:	08 95       	ret

000026cc <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
    26cc:	cf 92       	push	r12
    26ce:	df 92       	push	r13
    26d0:	ef 92       	push	r14
    26d2:	ff 92       	push	r15
    26d4:	0f 93       	push	r16
    26d6:	1f 93       	push	r17
    26d8:	df 93       	push	r29
    26da:	cf 93       	push	r28
    26dc:	cd b7       	in	r28, 0x3d	; 61
    26de:	de b7       	in	r29, 0x3e	; 62
    26e0:	60 97       	sbiw	r28, 0x10	; 16
    26e2:	0f b6       	in	r0, 0x3f	; 63
    26e4:	f8 94       	cli
    26e6:	de bf       	out	0x3e, r29	; 62
    26e8:	0f be       	out	0x3f, r0	; 63
    26ea:	cd bf       	out	0x3d, r28	; 61
    26ec:	9a 87       	std	Y+10, r25	; 0x0a
    26ee:	89 87       	std	Y+9, r24	; 0x09
    26f0:	7c 87       	std	Y+12, r23	; 0x0c
    26f2:	6b 87       	std	Y+11, r22	; 0x0b
    26f4:	5e 87       	std	Y+14, r21	; 0x0e
    26f6:	4d 87       	std	Y+13, r20	; 0x0d
    26f8:	38 8b       	std	Y+16, r19	; 0x10
    26fa:	2f 87       	std	Y+15, r18	; 0x0f
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    26fc:	89 85       	ldd	r24, Y+9	; 0x09
    26fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    2700:	98 87       	std	Y+8, r25	; 0x08
    2702:	8f 83       	std	Y+7, r24	; 0x07
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    2704:	1e 82       	std	Y+6, r1	; 0x06
    2706:	1d 82       	std	Y+5, r1	; 0x05
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2708:	ef 81       	ldd	r30, Y+7	; 0x07
    270a:	f8 85       	ldd	r31, Y+8	; 0x08
    270c:	86 85       	ldd	r24, Z+14	; 0x0e
    270e:	88 2f       	mov	r24, r24
    2710:	90 e0       	ldi	r25, 0x00	; 0
    2712:	81 70       	andi	r24, 0x01	; 1
    2714:	90 70       	andi	r25, 0x00	; 0
    2716:	88 23       	and	r24, r24
    2718:	29 f0       	breq	.+10     	; 0x2724 <xStreamBufferReceive+0x58>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    271a:	82 e0       	ldi	r24, 0x02	; 2
    271c:	90 e0       	ldi	r25, 0x00	; 0
    271e:	9a 83       	std	Y+2, r25	; 0x02
    2720:	89 83       	std	Y+1, r24	; 0x01
    2722:	02 c0       	rjmp	.+4      	; 0x2728 <xStreamBufferReceive+0x5c>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    2724:	1a 82       	std	Y+2, r1	; 0x02
    2726:	19 82       	std	Y+1, r1	; 0x01
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    2728:	8f 85       	ldd	r24, Y+15	; 0x0f
    272a:	98 89       	ldd	r25, Y+16	; 0x10
    272c:	00 97       	sbiw	r24, 0x00	; 0
    272e:	09 f4       	brne	.+2      	; 0x2732 <xStreamBufferReceive+0x66>
    2730:	3f c0       	rjmp	.+126    	; 0x27b0 <xStreamBufferReceive+0xe4>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
    2732:	0f b6       	in	r0, 0x3f	; 63
    2734:	f8 94       	cli
    2736:	0f 92       	push	r0
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2738:	8f 81       	ldd	r24, Y+7	; 0x07
    273a:	98 85       	ldd	r25, Y+8	; 0x08
    273c:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <prvBytesInBuffer>
    2740:	9c 83       	std	Y+4, r25	; 0x04
    2742:	8b 83       	std	Y+3, r24	; 0x03
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
    2744:	2b 81       	ldd	r18, Y+3	; 0x03
    2746:	3c 81       	ldd	r19, Y+4	; 0x04
    2748:	89 81       	ldd	r24, Y+1	; 0x01
    274a:	9a 81       	ldd	r25, Y+2	; 0x02
    274c:	82 17       	cp	r24, r18
    274e:	93 07       	cpc	r25, r19
    2750:	58 f0       	brcs	.+22     	; 0x2768 <xStreamBufferReceive+0x9c>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
    2752:	80 e0       	ldi	r24, 0x00	; 0
    2754:	90 e0       	ldi	r25, 0x00	; 0
    2756:	60 e0       	ldi	r22, 0x00	; 0
    2758:	0e 94 a6 2a 	call	0x554c	; 0x554c <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    275c:	0e 94 9a 23 	call	0x4734	; 0x4734 <xTaskGetCurrentTaskHandle>
    2760:	ef 81       	ldd	r30, Y+7	; 0x07
    2762:	f8 85       	ldd	r31, Y+8	; 0x08
    2764:	91 87       	std	Z+9, r25	; 0x09
    2766:	80 87       	std	Z+8, r24	; 0x08
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    2768:	0f 90       	pop	r0
    276a:	0f be       	out	0x3f, r0	; 63

        if( xBytesAvailable <= xBytesToStoreMessageLength )
    276c:	2b 81       	ldd	r18, Y+3	; 0x03
    276e:	3c 81       	ldd	r19, Y+4	; 0x04
    2770:	89 81       	ldd	r24, Y+1	; 0x01
    2772:	9a 81       	ldd	r25, Y+2	; 0x02
    2774:	82 17       	cp	r24, r18
    2776:	93 07       	cpc	r25, r19
    2778:	08 f1       	brcs	.+66     	; 0x27bc <xStreamBufferReceive+0xf0>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    277a:	ef 85       	ldd	r30, Y+15	; 0x0f
    277c:	f8 89       	ldd	r31, Y+16	; 0x10
    277e:	80 e0       	ldi	r24, 0x00	; 0
    2780:	40 e0       	ldi	r20, 0x00	; 0
    2782:	50 e0       	ldi	r21, 0x00	; 0
    2784:	60 e0       	ldi	r22, 0x00	; 0
    2786:	70 e0       	ldi	r23, 0x00	; 0
    2788:	00 e0       	ldi	r16, 0x00	; 0
    278a:	10 e0       	ldi	r17, 0x00	; 0
    278c:	20 e0       	ldi	r18, 0x00	; 0
    278e:	30 e0       	ldi	r19, 0x00	; 0
    2790:	ee 24       	eor	r14, r14
    2792:	ff 24       	eor	r15, r15
    2794:	6f 01       	movw	r12, r30
    2796:	0e 94 a2 24 	call	0x4944	; 0x4944 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
    279a:	ef 81       	ldd	r30, Y+7	; 0x07
    279c:	f8 85       	ldd	r31, Y+8	; 0x08
    279e:	11 86       	std	Z+9, r1	; 0x09
    27a0:	10 86       	std	Z+8, r1	; 0x08

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    27a2:	8f 81       	ldd	r24, Y+7	; 0x07
    27a4:	98 85       	ldd	r25, Y+8	; 0x08
    27a6:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <prvBytesInBuffer>
    27aa:	9c 83       	std	Y+4, r25	; 0x04
    27ac:	8b 83       	std	Y+3, r24	; 0x03
    27ae:	06 c0       	rjmp	.+12     	; 0x27bc <xStreamBufferReceive+0xf0>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    27b0:	8f 81       	ldd	r24, Y+7	; 0x07
    27b2:	98 85       	ldd	r25, Y+8	; 0x08
    27b4:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <prvBytesInBuffer>
    27b8:	9c 83       	std	Y+4, r25	; 0x04
    27ba:	8b 83       	std	Y+3, r24	; 0x03
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    27bc:	2b 81       	ldd	r18, Y+3	; 0x03
    27be:	3c 81       	ldd	r19, Y+4	; 0x04
    27c0:	89 81       	ldd	r24, Y+1	; 0x01
    27c2:	9a 81       	ldd	r25, Y+2	; 0x02
    27c4:	82 17       	cp	r24, r18
    27c6:	93 07       	cpc	r25, r19
    27c8:	70 f5       	brcc	.+92     	; 0x2826 <xStreamBufferReceive+0x15a>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    27ca:	8f 81       	ldd	r24, Y+7	; 0x07
    27cc:	98 85       	ldd	r25, Y+8	; 0x08
    27ce:	2b 85       	ldd	r18, Y+11	; 0x0b
    27d0:	3c 85       	ldd	r19, Y+12	; 0x0c
    27d2:	4d 85       	ldd	r20, Y+13	; 0x0d
    27d4:	5e 85       	ldd	r21, Y+14	; 0x0e
    27d6:	eb 81       	ldd	r30, Y+3	; 0x03
    27d8:	fc 81       	ldd	r31, Y+4	; 0x04
    27da:	b9 01       	movw	r22, r18
    27dc:	9f 01       	movw	r18, r30
    27de:	0e 94 e5 14 	call	0x29ca	; 0x29ca <prvReadMessageFromBuffer>
    27e2:	9e 83       	std	Y+6, r25	; 0x06
    27e4:	8d 83       	std	Y+5, r24	; 0x05

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    27e6:	8d 81       	ldd	r24, Y+5	; 0x05
    27e8:	9e 81       	ldd	r25, Y+6	; 0x06
    27ea:	00 97       	sbiw	r24, 0x00	; 0
    27ec:	e1 f0       	breq	.+56     	; 0x2826 <xStreamBufferReceive+0x15a>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            prvRECEIVE_COMPLETED( xStreamBuffer );
    27ee:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskSuspendAll>
    27f2:	e9 85       	ldd	r30, Y+9	; 0x09
    27f4:	fa 85       	ldd	r31, Y+10	; 0x0a
    27f6:	82 85       	ldd	r24, Z+10	; 0x0a
    27f8:	93 85       	ldd	r25, Z+11	; 0x0b
    27fa:	00 97       	sbiw	r24, 0x00	; 0
    27fc:	91 f0       	breq	.+36     	; 0x2822 <xStreamBufferReceive+0x156>
    27fe:	e9 85       	ldd	r30, Y+9	; 0x09
    2800:	fa 85       	ldd	r31, Y+10	; 0x0a
    2802:	82 85       	ldd	r24, Z+10	; 0x0a
    2804:	93 85       	ldd	r25, Z+11	; 0x0b
    2806:	60 e0       	ldi	r22, 0x00	; 0
    2808:	20 e0       	ldi	r18, 0x00	; 0
    280a:	30 e0       	ldi	r19, 0x00	; 0
    280c:	40 e0       	ldi	r20, 0x00	; 0
    280e:	50 e0       	ldi	r21, 0x00	; 0
    2810:	00 e0       	ldi	r16, 0x00	; 0
    2812:	ee 24       	eor	r14, r14
    2814:	ff 24       	eor	r15, r15
    2816:	0e 94 99 25 	call	0x4b32	; 0x4b32 <xTaskGenericNotify>
    281a:	e9 85       	ldd	r30, Y+9	; 0x09
    281c:	fa 85       	ldd	r31, Y+10	; 0x0a
    281e:	13 86       	std	Z+11, r1	; 0x0b
    2820:	12 86       	std	Z+10, r1	; 0x0a
    2822:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
    {
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
    2826:	8d 81       	ldd	r24, Y+5	; 0x05
    2828:	9e 81       	ldd	r25, Y+6	; 0x06
}
    282a:	60 96       	adiw	r28, 0x10	; 16
    282c:	0f b6       	in	r0, 0x3f	; 63
    282e:	f8 94       	cli
    2830:	de bf       	out	0x3e, r29	; 62
    2832:	0f be       	out	0x3f, r0	; 63
    2834:	cd bf       	out	0x3d, r28	; 61
    2836:	cf 91       	pop	r28
    2838:	df 91       	pop	r29
    283a:	1f 91       	pop	r17
    283c:	0f 91       	pop	r16
    283e:	ff 90       	pop	r15
    2840:	ef 90       	pop	r14
    2842:	df 90       	pop	r13
    2844:	cf 90       	pop	r12
    2846:	08 95       	ret

00002848 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    2848:	df 93       	push	r29
    284a:	cf 93       	push	r28
    284c:	cd b7       	in	r28, 0x3d	; 61
    284e:	de b7       	in	r29, 0x3e	; 62
    2850:	2a 97       	sbiw	r28, 0x0a	; 10
    2852:	0f b6       	in	r0, 0x3f	; 63
    2854:	f8 94       	cli
    2856:	de bf       	out	0x3e, r29	; 62
    2858:	0f be       	out	0x3f, r0	; 63
    285a:	cd bf       	out	0x3d, r28	; 61
    285c:	9a 87       	std	Y+10, r25	; 0x0a
    285e:	89 87       	std	Y+9, r24	; 0x09
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2860:	89 85       	ldd	r24, Y+9	; 0x09
    2862:	9a 85       	ldd	r25, Y+10	; 0x0a
    2864:	9e 83       	std	Y+6, r25	; 0x06
    2866:	8d 83       	std	Y+5, r24	; 0x05
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2868:	ed 81       	ldd	r30, Y+5	; 0x05
    286a:	fe 81       	ldd	r31, Y+6	; 0x06
    286c:	86 85       	ldd	r24, Z+14	; 0x0e
    286e:	88 2f       	mov	r24, r24
    2870:	90 e0       	ldi	r25, 0x00	; 0
    2872:	81 70       	andi	r24, 0x01	; 1
    2874:	90 70       	andi	r25, 0x00	; 0
    2876:	88 23       	and	r24, r24
    2878:	19 f1       	breq	.+70     	; 0x28c0 <xStreamBufferNextMessageLengthBytes+0x78>
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    287a:	8d 81       	ldd	r24, Y+5	; 0x05
    287c:	9e 81       	ldd	r25, Y+6	; 0x06
    287e:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <prvBytesInBuffer>
    2882:	9a 83       	std	Y+2, r25	; 0x02
    2884:	89 83       	std	Y+1, r24	; 0x01

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    2886:	89 81       	ldd	r24, Y+1	; 0x01
    2888:	9a 81       	ldd	r25, Y+2	; 0x02
    288a:	83 30       	cpi	r24, 0x03	; 3
    288c:	91 05       	cpc	r25, r1
    288e:	a8 f0       	brcs	.+42     	; 0x28ba <xStreamBufferNextMessageLengthBytes+0x72>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
    2890:	9e 01       	movw	r18, r28
    2892:	29 5f       	subi	r18, 0xF9	; 249
    2894:	3f 4f       	sbci	r19, 0xFF	; 255
    2896:	ed 81       	ldd	r30, Y+5	; 0x05
    2898:	fe 81       	ldd	r31, Y+6	; 0x06
    289a:	01 90       	ld	r0, Z+
    289c:	f0 81       	ld	r31, Z
    289e:	e0 2d       	mov	r30, r0
    28a0:	8d 81       	ldd	r24, Y+5	; 0x05
    28a2:	9e 81       	ldd	r25, Y+6	; 0x06
    28a4:	b9 01       	movw	r22, r18
    28a6:	42 e0       	ldi	r20, 0x02	; 2
    28a8:	50 e0       	ldi	r21, 0x00	; 0
    28aa:	9f 01       	movw	r18, r30
    28ac:	0e 94 d7 16 	call	0x2dae	; 0x2dae <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
    28b0:	8f 81       	ldd	r24, Y+7	; 0x07
    28b2:	98 85       	ldd	r25, Y+8	; 0x08
    28b4:	9c 83       	std	Y+4, r25	; 0x04
    28b6:	8b 83       	std	Y+3, r24	; 0x03
    28b8:	05 c0       	rjmp	.+10     	; 0x28c4 <xStreamBufferNextMessageLengthBytes+0x7c>
            /* The minimum amount of bytes in a message buffer is
             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
             * value is 0. */
            configASSERT( xBytesAvailable == 0 );
            xReturn = 0;
    28ba:	1c 82       	std	Y+4, r1	; 0x04
    28bc:	1b 82       	std	Y+3, r1	; 0x03
    28be:	02 c0       	rjmp	.+4      	; 0x28c4 <xStreamBufferNextMessageLengthBytes+0x7c>
        }
    }
    else
    {
        xReturn = 0;
    28c0:	1c 82       	std	Y+4, r1	; 0x04
    28c2:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    28c4:	8b 81       	ldd	r24, Y+3	; 0x03
    28c6:	9c 81       	ldd	r25, Y+4	; 0x04
}
    28c8:	2a 96       	adiw	r28, 0x0a	; 10
    28ca:	0f b6       	in	r0, 0x3f	; 63
    28cc:	f8 94       	cli
    28ce:	de bf       	out	0x3e, r29	; 62
    28d0:	0f be       	out	0x3f, r0	; 63
    28d2:	cd bf       	out	0x3d, r28	; 61
    28d4:	cf 91       	pop	r28
    28d6:	df 91       	pop	r29
    28d8:	08 95       	ret

000028da <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
    28da:	cf 92       	push	r12
    28dc:	df 92       	push	r13
    28de:	ef 92       	push	r14
    28e0:	ff 92       	push	r15
    28e2:	0f 93       	push	r16
    28e4:	df 93       	push	r29
    28e6:	cf 93       	push	r28
    28e8:	cd b7       	in	r28, 0x3d	; 61
    28ea:	de b7       	in	r29, 0x3e	; 62
    28ec:	61 97       	sbiw	r28, 0x11	; 17
    28ee:	0f b6       	in	r0, 0x3f	; 63
    28f0:	f8 94       	cli
    28f2:	de bf       	out	0x3e, r29	; 62
    28f4:	0f be       	out	0x3f, r0	; 63
    28f6:	cd bf       	out	0x3d, r28	; 61
    28f8:	9b 87       	std	Y+11, r25	; 0x0b
    28fa:	8a 87       	std	Y+10, r24	; 0x0a
    28fc:	7d 87       	std	Y+13, r23	; 0x0d
    28fe:	6c 87       	std	Y+12, r22	; 0x0c
    2900:	5f 87       	std	Y+15, r21	; 0x0f
    2902:	4e 87       	std	Y+14, r20	; 0x0e
    2904:	39 8b       	std	Y+17, r19	; 0x11
    2906:	28 8b       	std	Y+16, r18	; 0x10
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2908:	8a 85       	ldd	r24, Y+10	; 0x0a
    290a:	9b 85       	ldd	r25, Y+11	; 0x0b
    290c:	99 87       	std	Y+9, r25	; 0x09
    290e:	88 87       	std	Y+8, r24	; 0x08
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    2910:	1f 82       	std	Y+7, r1	; 0x07
    2912:	1e 82       	std	Y+6, r1	; 0x06
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2914:	e8 85       	ldd	r30, Y+8	; 0x08
    2916:	f9 85       	ldd	r31, Y+9	; 0x09
    2918:	86 85       	ldd	r24, Z+14	; 0x0e
    291a:	88 2f       	mov	r24, r24
    291c:	90 e0       	ldi	r25, 0x00	; 0
    291e:	81 70       	andi	r24, 0x01	; 1
    2920:	90 70       	andi	r25, 0x00	; 0
    2922:	88 23       	and	r24, r24
    2924:	29 f0       	breq	.+10     	; 0x2930 <xStreamBufferReceiveFromISR+0x56>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2926:	82 e0       	ldi	r24, 0x02	; 2
    2928:	90 e0       	ldi	r25, 0x00	; 0
    292a:	9b 83       	std	Y+3, r25	; 0x03
    292c:	8a 83       	std	Y+2, r24	; 0x02
    292e:	02 c0       	rjmp	.+4      	; 0x2934 <xStreamBufferReceiveFromISR+0x5a>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    2930:	1b 82       	std	Y+3, r1	; 0x03
    2932:	1a 82       	std	Y+2, r1	; 0x02
    }

    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2934:	88 85       	ldd	r24, Y+8	; 0x08
    2936:	99 85       	ldd	r25, Y+9	; 0x09
    2938:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <prvBytesInBuffer>
    293c:	9d 83       	std	Y+5, r25	; 0x05
    293e:	8c 83       	std	Y+4, r24	; 0x04
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    2940:	2c 81       	ldd	r18, Y+4	; 0x04
    2942:	3d 81       	ldd	r19, Y+5	; 0x05
    2944:	8a 81       	ldd	r24, Y+2	; 0x02
    2946:	9b 81       	ldd	r25, Y+3	; 0x03
    2948:	82 17       	cp	r24, r18
    294a:	93 07       	cpc	r25, r19
    294c:	70 f5       	brcc	.+92     	; 0x29aa <xStreamBufferReceiveFromISR+0xd0>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    294e:	88 85       	ldd	r24, Y+8	; 0x08
    2950:	99 85       	ldd	r25, Y+9	; 0x09
    2952:	2c 85       	ldd	r18, Y+12	; 0x0c
    2954:	3d 85       	ldd	r19, Y+13	; 0x0d
    2956:	4e 85       	ldd	r20, Y+14	; 0x0e
    2958:	5f 85       	ldd	r21, Y+15	; 0x0f
    295a:	ec 81       	ldd	r30, Y+4	; 0x04
    295c:	fd 81       	ldd	r31, Y+5	; 0x05
    295e:	b9 01       	movw	r22, r18
    2960:	9f 01       	movw	r18, r30
    2962:	0e 94 e5 14 	call	0x29ca	; 0x29ca <prvReadMessageFromBuffer>
    2966:	9f 83       	std	Y+7, r25	; 0x07
    2968:	8e 83       	std	Y+6, r24	; 0x06

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    296a:	8e 81       	ldd	r24, Y+6	; 0x06
    296c:	9f 81       	ldd	r25, Y+7	; 0x07
    296e:	00 97       	sbiw	r24, 0x00	; 0
    2970:	e1 f0       	breq	.+56     	; 0x29aa <xStreamBufferReceiveFromISR+0xd0>
        {
            prvRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    2972:	19 82       	std	Y+1, r1	; 0x01
    2974:	e8 85       	ldd	r30, Y+8	; 0x08
    2976:	f9 85       	ldd	r31, Y+9	; 0x09
    2978:	82 85       	ldd	r24, Z+10	; 0x0a
    297a:	93 85       	ldd	r25, Z+11	; 0x0b
    297c:	00 97       	sbiw	r24, 0x00	; 0
    297e:	a9 f0       	breq	.+42     	; 0x29aa <xStreamBufferReceiveFromISR+0xd0>
    2980:	e8 85       	ldd	r30, Y+8	; 0x08
    2982:	f9 85       	ldd	r31, Y+9	; 0x09
    2984:	82 85       	ldd	r24, Z+10	; 0x0a
    2986:	93 85       	ldd	r25, Z+11	; 0x0b
    2988:	e8 89       	ldd	r30, Y+16	; 0x10
    298a:	f9 89       	ldd	r31, Y+17	; 0x11
    298c:	60 e0       	ldi	r22, 0x00	; 0
    298e:	20 e0       	ldi	r18, 0x00	; 0
    2990:	30 e0       	ldi	r19, 0x00	; 0
    2992:	40 e0       	ldi	r20, 0x00	; 0
    2994:	50 e0       	ldi	r21, 0x00	; 0
    2996:	00 e0       	ldi	r16, 0x00	; 0
    2998:	ee 24       	eor	r14, r14
    299a:	ff 24       	eor	r15, r15
    299c:	6f 01       	movw	r12, r30
    299e:	0e 94 57 27 	call	0x4eae	; 0x4eae <xTaskGenericNotifyFromISR>
    29a2:	e8 85       	ldd	r30, Y+8	; 0x08
    29a4:	f9 85       	ldd	r31, Y+9	; 0x09
    29a6:	13 86       	std	Z+11, r1	; 0x0b
    29a8:	12 86       	std	Z+10, r1	; 0x0a
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
    29aa:	8e 81       	ldd	r24, Y+6	; 0x06
    29ac:	9f 81       	ldd	r25, Y+7	; 0x07
}
    29ae:	61 96       	adiw	r28, 0x11	; 17
    29b0:	0f b6       	in	r0, 0x3f	; 63
    29b2:	f8 94       	cli
    29b4:	de bf       	out	0x3e, r29	; 62
    29b6:	0f be       	out	0x3f, r0	; 63
    29b8:	cd bf       	out	0x3d, r28	; 61
    29ba:	cf 91       	pop	r28
    29bc:	df 91       	pop	r29
    29be:	0f 91       	pop	r16
    29c0:	ff 90       	pop	r15
    29c2:	ef 90       	pop	r14
    29c4:	df 90       	pop	r13
    29c6:	cf 90       	pop	r12
    29c8:	08 95       	ret

000029ca <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
    29ca:	df 93       	push	r29
    29cc:	cf 93       	push	r28
    29ce:	cd b7       	in	r28, 0x3d	; 61
    29d0:	de b7       	in	r29, 0x3e	; 62
    29d2:	64 97       	sbiw	r28, 0x14	; 20
    29d4:	0f b6       	in	r0, 0x3f	; 63
    29d6:	f8 94       	cli
    29d8:	de bf       	out	0x3e, r29	; 62
    29da:	0f be       	out	0x3f, r0	; 63
    29dc:	cd bf       	out	0x3d, r28	; 61
    29de:	9a 87       	std	Y+10, r25	; 0x0a
    29e0:	89 87       	std	Y+9, r24	; 0x09
    29e2:	7c 87       	std	Y+12, r23	; 0x0c
    29e4:	6b 87       	std	Y+11, r22	; 0x0b
    29e6:	5e 87       	std	Y+14, r21	; 0x0e
    29e8:	4d 87       	std	Y+13, r20	; 0x0d
    29ea:	38 8b       	std	Y+16, r19	; 0x10
    29ec:	2f 87       	std	Y+15, r18	; 0x0f
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
    29ee:	e9 85       	ldd	r30, Y+9	; 0x09
    29f0:	fa 85       	ldd	r31, Y+10	; 0x0a
    29f2:	80 81       	ld	r24, Z
    29f4:	91 81       	ldd	r25, Z+1	; 0x01
    29f6:	9a 83       	std	Y+2, r25	; 0x02
    29f8:	89 83       	std	Y+1, r24	; 0x01

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    29fa:	e9 85       	ldd	r30, Y+9	; 0x09
    29fc:	fa 85       	ldd	r31, Y+10	; 0x0a
    29fe:	86 85       	ldd	r24, Z+14	; 0x0e
    2a00:	88 2f       	mov	r24, r24
    2a02:	90 e0       	ldi	r25, 0x00	; 0
    2a04:	81 70       	andi	r24, 0x01	; 1
    2a06:	90 70       	andi	r25, 0x00	; 0
    2a08:	88 23       	and	r24, r24
    2a0a:	11 f1       	breq	.+68     	; 0x2a50 <prvReadMessageFromBuffer+0x86>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
    2a0c:	9e 01       	movw	r18, r28
    2a0e:	29 5f       	subi	r18, 0xF9	; 249
    2a10:	3f 4f       	sbci	r19, 0xFF	; 255
    2a12:	89 85       	ldd	r24, Y+9	; 0x09
    2a14:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a16:	e9 81       	ldd	r30, Y+1	; 0x01
    2a18:	fa 81       	ldd	r31, Y+2	; 0x02
    2a1a:	b9 01       	movw	r22, r18
    2a1c:	42 e0       	ldi	r20, 0x02	; 2
    2a1e:	50 e0       	ldi	r21, 0x00	; 0
    2a20:	9f 01       	movw	r18, r30
    2a22:	0e 94 d7 16 	call	0x2dae	; 0x2dae <prvReadBytesFromBuffer>
    2a26:	9a 83       	std	Y+2, r25	; 0x02
    2a28:	89 83       	std	Y+1, r24	; 0x01
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
    2a2a:	8f 81       	ldd	r24, Y+7	; 0x07
    2a2c:	98 85       	ldd	r25, Y+8	; 0x08
    2a2e:	9c 83       	std	Y+4, r25	; 0x04
    2a30:	8b 83       	std	Y+3, r24	; 0x03

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2a32:	8f 85       	ldd	r24, Y+15	; 0x0f
    2a34:	98 89       	ldd	r25, Y+16	; 0x10
    2a36:	02 97       	sbiw	r24, 0x02	; 2
    2a38:	98 8b       	std	Y+16, r25	; 0x10
    2a3a:	8f 87       	std	Y+15, r24	; 0x0f

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
    2a3c:	2b 81       	ldd	r18, Y+3	; 0x03
    2a3e:	3c 81       	ldd	r19, Y+4	; 0x04
    2a40:	8d 85       	ldd	r24, Y+13	; 0x0d
    2a42:	9e 85       	ldd	r25, Y+14	; 0x0e
    2a44:	82 17       	cp	r24, r18
    2a46:	93 07       	cpc	r25, r19
    2a48:	38 f4       	brcc	.+14     	; 0x2a58 <prvReadMessageFromBuffer+0x8e>
        {
            /* The user has provided insufficient space to read the message. */
            xNextMessageLength = 0;
    2a4a:	1c 82       	std	Y+4, r1	; 0x04
    2a4c:	1b 82       	std	Y+3, r1	; 0x03
    2a4e:	04 c0       	rjmp	.+8      	; 0x2a58 <prvReadMessageFromBuffer+0x8e>
    }
    else
    {
        /* A stream of bytes is being received (as opposed to a discrete
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
    2a50:	8d 85       	ldd	r24, Y+13	; 0x0d
    2a52:	9e 85       	ldd	r25, Y+14	; 0x0e
    2a54:	9c 83       	std	Y+4, r25	; 0x04
    2a56:	8b 83       	std	Y+3, r24	; 0x03
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
    2a58:	2b 81       	ldd	r18, Y+3	; 0x03
    2a5a:	3c 81       	ldd	r19, Y+4	; 0x04
    2a5c:	3c 8b       	std	Y+20, r19	; 0x14
    2a5e:	2b 8b       	std	Y+19, r18	; 0x13
    2a60:	8f 85       	ldd	r24, Y+15	; 0x0f
    2a62:	98 89       	ldd	r25, Y+16	; 0x10
    2a64:	9a 8b       	std	Y+18, r25	; 0x12
    2a66:	89 8b       	std	Y+17, r24	; 0x11
    2a68:	29 89       	ldd	r18, Y+17	; 0x11
    2a6a:	3a 89       	ldd	r19, Y+18	; 0x12
    2a6c:	8b 89       	ldd	r24, Y+19	; 0x13
    2a6e:	9c 89       	ldd	r25, Y+20	; 0x14
    2a70:	82 17       	cp	r24, r18
    2a72:	93 07       	cpc	r25, r19
    2a74:	20 f4       	brcc	.+8      	; 0x2a7e <prvReadMessageFromBuffer+0xb4>
    2a76:	2b 89       	ldd	r18, Y+19	; 0x13
    2a78:	3c 89       	ldd	r19, Y+20	; 0x14
    2a7a:	3a 8b       	std	Y+18, r19	; 0x12
    2a7c:	29 8b       	std	Y+17, r18	; 0x11
    2a7e:	89 89       	ldd	r24, Y+17	; 0x11
    2a80:	9a 89       	ldd	r25, Y+18	; 0x12
    2a82:	9e 83       	std	Y+6, r25	; 0x06
    2a84:	8d 83       	std	Y+5, r24	; 0x05

    if( xCount != ( size_t ) 0 )
    2a86:	8d 81       	ldd	r24, Y+5	; 0x05
    2a88:	9e 81       	ldd	r25, Y+6	; 0x06
    2a8a:	00 97       	sbiw	r24, 0x00	; 0
    2a8c:	89 f0       	breq	.+34     	; 0x2ab0 <prvReadMessageFromBuffer+0xe6>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    2a8e:	4b 85       	ldd	r20, Y+11	; 0x0b
    2a90:	5c 85       	ldd	r21, Y+12	; 0x0c
    2a92:	89 85       	ldd	r24, Y+9	; 0x09
    2a94:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a96:	2d 81       	ldd	r18, Y+5	; 0x05
    2a98:	3e 81       	ldd	r19, Y+6	; 0x06
    2a9a:	e9 81       	ldd	r30, Y+1	; 0x01
    2a9c:	fa 81       	ldd	r31, Y+2	; 0x02
    2a9e:	ba 01       	movw	r22, r20
    2aa0:	a9 01       	movw	r20, r18
    2aa2:	9f 01       	movw	r18, r30
    2aa4:	0e 94 d7 16 	call	0x2dae	; 0x2dae <prvReadBytesFromBuffer>
    2aa8:	e9 85       	ldd	r30, Y+9	; 0x09
    2aaa:	fa 85       	ldd	r31, Y+10	; 0x0a
    2aac:	91 83       	std	Z+1, r25	; 0x01
    2aae:	80 83       	st	Z, r24
    }

    return xCount;
    2ab0:	8d 81       	ldd	r24, Y+5	; 0x05
    2ab2:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2ab4:	64 96       	adiw	r28, 0x14	; 20
    2ab6:	0f b6       	in	r0, 0x3f	; 63
    2ab8:	f8 94       	cli
    2aba:	de bf       	out	0x3e, r29	; 62
    2abc:	0f be       	out	0x3f, r0	; 63
    2abe:	cd bf       	out	0x3d, r28	; 61
    2ac0:	cf 91       	pop	r28
    2ac2:	df 91       	pop	r29
    2ac4:	08 95       	ret

00002ac6 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    2ac6:	df 93       	push	r29
    2ac8:	cf 93       	push	r28
    2aca:	cd b7       	in	r28, 0x3d	; 61
    2acc:	de b7       	in	r29, 0x3e	; 62
    2ace:	27 97       	sbiw	r28, 0x07	; 7
    2ad0:	0f b6       	in	r0, 0x3f	; 63
    2ad2:	f8 94       	cli
    2ad4:	de bf       	out	0x3e, r29	; 62
    2ad6:	0f be       	out	0x3f, r0	; 63
    2ad8:	cd bf       	out	0x3d, r28	; 61
    2ada:	9f 83       	std	Y+7, r25	; 0x07
    2adc:	8e 83       	std	Y+6, r24	; 0x06
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2ade:	8e 81       	ldd	r24, Y+6	; 0x06
    2ae0:	9f 81       	ldd	r25, Y+7	; 0x07
    2ae2:	9d 83       	std	Y+5, r25	; 0x05
    2ae4:	8c 83       	std	Y+4, r24	; 0x04
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
    2ae6:	ec 81       	ldd	r30, Y+4	; 0x04
    2ae8:	fd 81       	ldd	r31, Y+5	; 0x05
    2aea:	80 81       	ld	r24, Z
    2aec:	91 81       	ldd	r25, Z+1	; 0x01
    2aee:	9a 83       	std	Y+2, r25	; 0x02
    2af0:	89 83       	std	Y+1, r24	; 0x01

    if( pxStreamBuffer->xHead == xTail )
    2af2:	ec 81       	ldd	r30, Y+4	; 0x04
    2af4:	fd 81       	ldd	r31, Y+5	; 0x05
    2af6:	22 81       	ldd	r18, Z+2	; 0x02
    2af8:	33 81       	ldd	r19, Z+3	; 0x03
    2afa:	89 81       	ldd	r24, Y+1	; 0x01
    2afc:	9a 81       	ldd	r25, Y+2	; 0x02
    2afe:	28 17       	cp	r18, r24
    2b00:	39 07       	cpc	r19, r25
    2b02:	19 f4       	brne	.+6      	; 0x2b0a <xStreamBufferIsEmpty+0x44>
    {
        xReturn = pdTRUE;
    2b04:	81 e0       	ldi	r24, 0x01	; 1
    2b06:	8b 83       	std	Y+3, r24	; 0x03
    2b08:	01 c0       	rjmp	.+2      	; 0x2b0c <xStreamBufferIsEmpty+0x46>
    }
    else
    {
        xReturn = pdFALSE;
    2b0a:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    2b0c:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2b0e:	27 96       	adiw	r28, 0x07	; 7
    2b10:	0f b6       	in	r0, 0x3f	; 63
    2b12:	f8 94       	cli
    2b14:	de bf       	out	0x3e, r29	; 62
    2b16:	0f be       	out	0x3f, r0	; 63
    2b18:	cd bf       	out	0x3d, r28	; 61
    2b1a:	cf 91       	pop	r28
    2b1c:	df 91       	pop	r29
    2b1e:	08 95       	ret

00002b20 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    2b20:	df 93       	push	r29
    2b22:	cf 93       	push	r28
    2b24:	cd b7       	in	r28, 0x3d	; 61
    2b26:	de b7       	in	r29, 0x3e	; 62
    2b28:	27 97       	sbiw	r28, 0x07	; 7
    2b2a:	0f b6       	in	r0, 0x3f	; 63
    2b2c:	f8 94       	cli
    2b2e:	de bf       	out	0x3e, r29	; 62
    2b30:	0f be       	out	0x3f, r0	; 63
    2b32:	cd bf       	out	0x3d, r28	; 61
    2b34:	9f 83       	std	Y+7, r25	; 0x07
    2b36:	8e 83       	std	Y+6, r24	; 0x06
    BaseType_t xReturn;
    size_t xBytesToStoreMessageLength;
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2b38:	8e 81       	ldd	r24, Y+6	; 0x06
    2b3a:	9f 81       	ldd	r25, Y+7	; 0x07
    2b3c:	9a 83       	std	Y+2, r25	; 0x02
    2b3e:	89 83       	std	Y+1, r24	; 0x01

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2b40:	e9 81       	ldd	r30, Y+1	; 0x01
    2b42:	fa 81       	ldd	r31, Y+2	; 0x02
    2b44:	86 85       	ldd	r24, Z+14	; 0x0e
    2b46:	88 2f       	mov	r24, r24
    2b48:	90 e0       	ldi	r25, 0x00	; 0
    2b4a:	81 70       	andi	r24, 0x01	; 1
    2b4c:	90 70       	andi	r25, 0x00	; 0
    2b4e:	88 23       	and	r24, r24
    2b50:	29 f0       	breq	.+10     	; 0x2b5c <xStreamBufferIsFull+0x3c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2b52:	82 e0       	ldi	r24, 0x02	; 2
    2b54:	90 e0       	ldi	r25, 0x00	; 0
    2b56:	9c 83       	std	Y+4, r25	; 0x04
    2b58:	8b 83       	std	Y+3, r24	; 0x03
    2b5a:	02 c0       	rjmp	.+4      	; 0x2b60 <xStreamBufferIsFull+0x40>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    2b5c:	1c 82       	std	Y+4, r1	; 0x04
    2b5e:	1b 82       	std	Y+3, r1	; 0x03
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    2b60:	8e 81       	ldd	r24, Y+6	; 0x06
    2b62:	9f 81       	ldd	r25, Y+7	; 0x07
    2b64:	0e 94 04 11 	call	0x2208	; 0x2208 <xStreamBufferSpacesAvailable>
    2b68:	9c 01       	movw	r18, r24
    2b6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b6e:	82 17       	cp	r24, r18
    2b70:	93 07       	cpc	r25, r19
    2b72:	18 f0       	brcs	.+6      	; 0x2b7a <xStreamBufferIsFull+0x5a>
    {
        xReturn = pdTRUE;
    2b74:	81 e0       	ldi	r24, 0x01	; 1
    2b76:	8d 83       	std	Y+5, r24	; 0x05
    2b78:	01 c0       	rjmp	.+2      	; 0x2b7c <xStreamBufferIsFull+0x5c>
    }
    else
    {
        xReturn = pdFALSE;
    2b7a:	1d 82       	std	Y+5, r1	; 0x05
    }

    return xReturn;
    2b7c:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2b7e:	27 96       	adiw	r28, 0x07	; 7
    2b80:	0f b6       	in	r0, 0x3f	; 63
    2b82:	f8 94       	cli
    2b84:	de bf       	out	0x3e, r29	; 62
    2b86:	0f be       	out	0x3f, r0	; 63
    2b88:	cd bf       	out	0x3d, r28	; 61
    2b8a:	cf 91       	pop	r28
    2b8c:	df 91       	pop	r29
    2b8e:	08 95       	ret

00002b90 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
    2b90:	cf 92       	push	r12
    2b92:	df 92       	push	r13
    2b94:	ef 92       	push	r14
    2b96:	ff 92       	push	r15
    2b98:	0f 93       	push	r16
    2b9a:	df 93       	push	r29
    2b9c:	cf 93       	push	r28
    2b9e:	cd b7       	in	r28, 0x3d	; 61
    2ba0:	de b7       	in	r29, 0x3e	; 62
    2ba2:	28 97       	sbiw	r28, 0x08	; 8
    2ba4:	0f b6       	in	r0, 0x3f	; 63
    2ba6:	f8 94       	cli
    2ba8:	de bf       	out	0x3e, r29	; 62
    2baa:	0f be       	out	0x3f, r0	; 63
    2bac:	cd bf       	out	0x3d, r28	; 61
    2bae:	9e 83       	std	Y+6, r25	; 0x06
    2bb0:	8d 83       	std	Y+5, r24	; 0x05
    2bb2:	78 87       	std	Y+8, r23	; 0x08
    2bb4:	6f 83       	std	Y+7, r22	; 0x07
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2bb6:	8d 81       	ldd	r24, Y+5	; 0x05
    2bb8:	9e 81       	ldd	r25, Y+6	; 0x06
    2bba:	9c 83       	std	Y+4, r25	; 0x04
    2bbc:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    2bbe:	19 82       	std	Y+1, r1	; 0x01
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    2bc0:	eb 81       	ldd	r30, Y+3	; 0x03
    2bc2:	fc 81       	ldd	r31, Y+4	; 0x04
    2bc4:	80 85       	ldd	r24, Z+8	; 0x08
    2bc6:	91 85       	ldd	r25, Z+9	; 0x09
    2bc8:	00 97       	sbiw	r24, 0x00	; 0
    2bca:	c1 f0       	breq	.+48     	; 0x2bfc <xStreamBufferSendCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    2bcc:	eb 81       	ldd	r30, Y+3	; 0x03
    2bce:	fc 81       	ldd	r31, Y+4	; 0x04
    2bd0:	80 85       	ldd	r24, Z+8	; 0x08
    2bd2:	91 85       	ldd	r25, Z+9	; 0x09
    2bd4:	ef 81       	ldd	r30, Y+7	; 0x07
    2bd6:	f8 85       	ldd	r31, Y+8	; 0x08
    2bd8:	60 e0       	ldi	r22, 0x00	; 0
    2bda:	20 e0       	ldi	r18, 0x00	; 0
    2bdc:	30 e0       	ldi	r19, 0x00	; 0
    2bde:	40 e0       	ldi	r20, 0x00	; 0
    2be0:	50 e0       	ldi	r21, 0x00	; 0
    2be2:	00 e0       	ldi	r16, 0x00	; 0
    2be4:	ee 24       	eor	r14, r14
    2be6:	ff 24       	eor	r15, r15
    2be8:	6f 01       	movw	r12, r30
    2bea:	0e 94 57 27 	call	0x4eae	; 0x4eae <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    2bee:	eb 81       	ldd	r30, Y+3	; 0x03
    2bf0:	fc 81       	ldd	r31, Y+4	; 0x04
    2bf2:	11 86       	std	Z+9, r1	; 0x09
    2bf4:	10 86       	std	Z+8, r1	; 0x08
            xReturn = pdTRUE;
    2bf6:	81 e0       	ldi	r24, 0x01	; 1
    2bf8:	8a 83       	std	Y+2, r24	; 0x02
    2bfa:	01 c0       	rjmp	.+2      	; 0x2bfe <xStreamBufferSendCompletedFromISR+0x6e>
        }
        else
        {
            xReturn = pdFALSE;
    2bfc:	1a 82       	std	Y+2, r1	; 0x02
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2bfe:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2c00:	28 96       	adiw	r28, 0x08	; 8
    2c02:	0f b6       	in	r0, 0x3f	; 63
    2c04:	f8 94       	cli
    2c06:	de bf       	out	0x3e, r29	; 62
    2c08:	0f be       	out	0x3f, r0	; 63
    2c0a:	cd bf       	out	0x3d, r28	; 61
    2c0c:	cf 91       	pop	r28
    2c0e:	df 91       	pop	r29
    2c10:	0f 91       	pop	r16
    2c12:	ff 90       	pop	r15
    2c14:	ef 90       	pop	r14
    2c16:	df 90       	pop	r13
    2c18:	cf 90       	pop	r12
    2c1a:	08 95       	ret

00002c1c <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
    2c1c:	cf 92       	push	r12
    2c1e:	df 92       	push	r13
    2c20:	ef 92       	push	r14
    2c22:	ff 92       	push	r15
    2c24:	0f 93       	push	r16
    2c26:	df 93       	push	r29
    2c28:	cf 93       	push	r28
    2c2a:	cd b7       	in	r28, 0x3d	; 61
    2c2c:	de b7       	in	r29, 0x3e	; 62
    2c2e:	28 97       	sbiw	r28, 0x08	; 8
    2c30:	0f b6       	in	r0, 0x3f	; 63
    2c32:	f8 94       	cli
    2c34:	de bf       	out	0x3e, r29	; 62
    2c36:	0f be       	out	0x3f, r0	; 63
    2c38:	cd bf       	out	0x3d, r28	; 61
    2c3a:	9e 83       	std	Y+6, r25	; 0x06
    2c3c:	8d 83       	std	Y+5, r24	; 0x05
    2c3e:	78 87       	std	Y+8, r23	; 0x08
    2c40:	6f 83       	std	Y+7, r22	; 0x07
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2c42:	8d 81       	ldd	r24, Y+5	; 0x05
    2c44:	9e 81       	ldd	r25, Y+6	; 0x06
    2c46:	9c 83       	std	Y+4, r25	; 0x04
    2c48:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    2c4a:	19 82       	std	Y+1, r1	; 0x01
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    2c4c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c4e:	fc 81       	ldd	r31, Y+4	; 0x04
    2c50:	82 85       	ldd	r24, Z+10	; 0x0a
    2c52:	93 85       	ldd	r25, Z+11	; 0x0b
    2c54:	00 97       	sbiw	r24, 0x00	; 0
    2c56:	c1 f0       	breq	.+48     	; 0x2c88 <xStreamBufferReceiveCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    2c58:	eb 81       	ldd	r30, Y+3	; 0x03
    2c5a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c5c:	82 85       	ldd	r24, Z+10	; 0x0a
    2c5e:	93 85       	ldd	r25, Z+11	; 0x0b
    2c60:	ef 81       	ldd	r30, Y+7	; 0x07
    2c62:	f8 85       	ldd	r31, Y+8	; 0x08
    2c64:	60 e0       	ldi	r22, 0x00	; 0
    2c66:	20 e0       	ldi	r18, 0x00	; 0
    2c68:	30 e0       	ldi	r19, 0x00	; 0
    2c6a:	40 e0       	ldi	r20, 0x00	; 0
    2c6c:	50 e0       	ldi	r21, 0x00	; 0
    2c6e:	00 e0       	ldi	r16, 0x00	; 0
    2c70:	ee 24       	eor	r14, r14
    2c72:	ff 24       	eor	r15, r15
    2c74:	6f 01       	movw	r12, r30
    2c76:	0e 94 57 27 	call	0x4eae	; 0x4eae <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    2c7a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c7c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c7e:	13 86       	std	Z+11, r1	; 0x0b
    2c80:	12 86       	std	Z+10, r1	; 0x0a
            xReturn = pdTRUE;
    2c82:	81 e0       	ldi	r24, 0x01	; 1
    2c84:	8a 83       	std	Y+2, r24	; 0x02
    2c86:	01 c0       	rjmp	.+2      	; 0x2c8a <xStreamBufferReceiveCompletedFromISR+0x6e>
        }
        else
        {
            xReturn = pdFALSE;
    2c88:	1a 82       	std	Y+2, r1	; 0x02
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2c8a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2c8c:	28 96       	adiw	r28, 0x08	; 8
    2c8e:	0f b6       	in	r0, 0x3f	; 63
    2c90:	f8 94       	cli
    2c92:	de bf       	out	0x3e, r29	; 62
    2c94:	0f be       	out	0x3f, r0	; 63
    2c96:	cd bf       	out	0x3d, r28	; 61
    2c98:	cf 91       	pop	r28
    2c9a:	df 91       	pop	r29
    2c9c:	0f 91       	pop	r16
    2c9e:	ff 90       	pop	r15
    2ca0:	ef 90       	pop	r14
    2ca2:	df 90       	pop	r13
    2ca4:	cf 90       	pop	r12
    2ca6:	08 95       	ret

00002ca8 <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
    2ca8:	df 93       	push	r29
    2caa:	cf 93       	push	r28
    2cac:	cd b7       	in	r28, 0x3d	; 61
    2cae:	de b7       	in	r29, 0x3e	; 62
    2cb0:	2e 97       	sbiw	r28, 0x0e	; 14
    2cb2:	0f b6       	in	r0, 0x3f	; 63
    2cb4:	f8 94       	cli
    2cb6:	de bf       	out	0x3e, r29	; 62
    2cb8:	0f be       	out	0x3f, r0	; 63
    2cba:	cd bf       	out	0x3d, r28	; 61
    2cbc:	9c 83       	std	Y+4, r25	; 0x04
    2cbe:	8b 83       	std	Y+3, r24	; 0x03
    2cc0:	7e 83       	std	Y+6, r23	; 0x06
    2cc2:	6d 83       	std	Y+5, r22	; 0x05
    2cc4:	58 87       	std	Y+8, r21	; 0x08
    2cc6:	4f 83       	std	Y+7, r20	; 0x07
    2cc8:	3a 87       	std	Y+10, r19	; 0x0a
    2cca:	29 87       	std	Y+9, r18	; 0x09
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
    2ccc:	eb 81       	ldd	r30, Y+3	; 0x03
    2cce:	fc 81       	ldd	r31, Y+4	; 0x04
    2cd0:	24 81       	ldd	r18, Z+4	; 0x04
    2cd2:	35 81       	ldd	r19, Z+5	; 0x05
    2cd4:	89 85       	ldd	r24, Y+9	; 0x09
    2cd6:	9a 85       	ldd	r25, Y+10	; 0x0a
    2cd8:	a9 01       	movw	r20, r18
    2cda:	48 1b       	sub	r20, r24
    2cdc:	59 0b       	sbc	r21, r25
    2cde:	ca 01       	movw	r24, r20
    2ce0:	2f 81       	ldd	r18, Y+7	; 0x07
    2ce2:	38 85       	ldd	r19, Y+8	; 0x08
    2ce4:	3e 87       	std	Y+14, r19	; 0x0e
    2ce6:	2d 87       	std	Y+13, r18	; 0x0d
    2ce8:	9c 87       	std	Y+12, r25	; 0x0c
    2cea:	8b 87       	std	Y+11, r24	; 0x0b
    2cec:	4b 85       	ldd	r20, Y+11	; 0x0b
    2cee:	5c 85       	ldd	r21, Y+12	; 0x0c
    2cf0:	8d 85       	ldd	r24, Y+13	; 0x0d
    2cf2:	9e 85       	ldd	r25, Y+14	; 0x0e
    2cf4:	84 17       	cp	r24, r20
    2cf6:	95 07       	cpc	r25, r21
    2cf8:	20 f4       	brcc	.+8      	; 0x2d02 <prvWriteBytesToBuffer+0x5a>
    2cfa:	2d 85       	ldd	r18, Y+13	; 0x0d
    2cfc:	3e 85       	ldd	r19, Y+14	; 0x0e
    2cfe:	3c 87       	std	Y+12, r19	; 0x0c
    2d00:	2b 87       	std	Y+11, r18	; 0x0b
    2d02:	4b 85       	ldd	r20, Y+11	; 0x0b
    2d04:	5c 85       	ldd	r21, Y+12	; 0x0c
    2d06:	5a 83       	std	Y+2, r21	; 0x02
    2d08:	49 83       	std	Y+1, r20	; 0x01

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2d0a:	eb 81       	ldd	r30, Y+3	; 0x03
    2d0c:	fc 81       	ldd	r31, Y+4	; 0x04
    2d0e:	24 85       	ldd	r18, Z+12	; 0x0c
    2d10:	35 85       	ldd	r19, Z+13	; 0x0d
    2d12:	89 85       	ldd	r24, Y+9	; 0x09
    2d14:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d16:	82 0f       	add	r24, r18
    2d18:	93 1f       	adc	r25, r19
    2d1a:	2d 81       	ldd	r18, Y+5	; 0x05
    2d1c:	3e 81       	ldd	r19, Y+6	; 0x06
    2d1e:	49 81       	ldd	r20, Y+1	; 0x01
    2d20:	5a 81       	ldd	r21, Y+2	; 0x02
    2d22:	b9 01       	movw	r22, r18
    2d24:	0e 94 1b 32 	call	0x6436	; 0x6436 <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
    2d28:	2f 81       	ldd	r18, Y+7	; 0x07
    2d2a:	38 85       	ldd	r19, Y+8	; 0x08
    2d2c:	89 81       	ldd	r24, Y+1	; 0x01
    2d2e:	9a 81       	ldd	r25, Y+2	; 0x02
    2d30:	82 17       	cp	r24, r18
    2d32:	93 07       	cpc	r25, r19
    2d34:	b0 f4       	brcc	.+44     	; 0x2d62 <prvWriteBytesToBuffer+0xba>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2d36:	eb 81       	ldd	r30, Y+3	; 0x03
    2d38:	fc 81       	ldd	r31, Y+4	; 0x04
    2d3a:	64 85       	ldd	r22, Z+12	; 0x0c
    2d3c:	75 85       	ldd	r23, Z+13	; 0x0d
    2d3e:	2d 81       	ldd	r18, Y+5	; 0x05
    2d40:	3e 81       	ldd	r19, Y+6	; 0x06
    2d42:	89 81       	ldd	r24, Y+1	; 0x01
    2d44:	9a 81       	ldd	r25, Y+2	; 0x02
    2d46:	a9 01       	movw	r20, r18
    2d48:	48 0f       	add	r20, r24
    2d4a:	59 1f       	adc	r21, r25
    2d4c:	2f 81       	ldd	r18, Y+7	; 0x07
    2d4e:	38 85       	ldd	r19, Y+8	; 0x08
    2d50:	89 81       	ldd	r24, Y+1	; 0x01
    2d52:	9a 81       	ldd	r25, Y+2	; 0x02
    2d54:	28 1b       	sub	r18, r24
    2d56:	39 0b       	sbc	r19, r25
    2d58:	cb 01       	movw	r24, r22
    2d5a:	ba 01       	movw	r22, r20
    2d5c:	a9 01       	movw	r20, r18
    2d5e:	0e 94 1b 32 	call	0x6436	; 0x6436 <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
    2d62:	29 85       	ldd	r18, Y+9	; 0x09
    2d64:	3a 85       	ldd	r19, Y+10	; 0x0a
    2d66:	8f 81       	ldd	r24, Y+7	; 0x07
    2d68:	98 85       	ldd	r25, Y+8	; 0x08
    2d6a:	82 0f       	add	r24, r18
    2d6c:	93 1f       	adc	r25, r19
    2d6e:	9a 87       	std	Y+10, r25	; 0x0a
    2d70:	89 87       	std	Y+9, r24	; 0x09

    if( xHead >= pxStreamBuffer->xLength )
    2d72:	eb 81       	ldd	r30, Y+3	; 0x03
    2d74:	fc 81       	ldd	r31, Y+4	; 0x04
    2d76:	24 81       	ldd	r18, Z+4	; 0x04
    2d78:	35 81       	ldd	r19, Z+5	; 0x05
    2d7a:	89 85       	ldd	r24, Y+9	; 0x09
    2d7c:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d7e:	82 17       	cp	r24, r18
    2d80:	93 07       	cpc	r25, r19
    2d82:	50 f0       	brcs	.+20     	; 0x2d98 <prvWriteBytesToBuffer+0xf0>
    {
        xHead -= pxStreamBuffer->xLength;
    2d84:	eb 81       	ldd	r30, Y+3	; 0x03
    2d86:	fc 81       	ldd	r31, Y+4	; 0x04
    2d88:	24 81       	ldd	r18, Z+4	; 0x04
    2d8a:	35 81       	ldd	r19, Z+5	; 0x05
    2d8c:	89 85       	ldd	r24, Y+9	; 0x09
    2d8e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d90:	82 1b       	sub	r24, r18
    2d92:	93 0b       	sbc	r25, r19
    2d94:	9a 87       	std	Y+10, r25	; 0x0a
    2d96:	89 87       	std	Y+9, r24	; 0x09
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
    2d98:	89 85       	ldd	r24, Y+9	; 0x09
    2d9a:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    2d9c:	2e 96       	adiw	r28, 0x0e	; 14
    2d9e:	0f b6       	in	r0, 0x3f	; 63
    2da0:	f8 94       	cli
    2da2:	de bf       	out	0x3e, r29	; 62
    2da4:	0f be       	out	0x3f, r0	; 63
    2da6:	cd bf       	out	0x3d, r28	; 61
    2da8:	cf 91       	pop	r28
    2daa:	df 91       	pop	r29
    2dac:	08 95       	ret

00002dae <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
    2dae:	df 93       	push	r29
    2db0:	cf 93       	push	r28
    2db2:	cd b7       	in	r28, 0x3d	; 61
    2db4:	de b7       	in	r29, 0x3e	; 62
    2db6:	2e 97       	sbiw	r28, 0x0e	; 14
    2db8:	0f b6       	in	r0, 0x3f	; 63
    2dba:	f8 94       	cli
    2dbc:	de bf       	out	0x3e, r29	; 62
    2dbe:	0f be       	out	0x3f, r0	; 63
    2dc0:	cd bf       	out	0x3d, r28	; 61
    2dc2:	9c 83       	std	Y+4, r25	; 0x04
    2dc4:	8b 83       	std	Y+3, r24	; 0x03
    2dc6:	7e 83       	std	Y+6, r23	; 0x06
    2dc8:	6d 83       	std	Y+5, r22	; 0x05
    2dca:	58 87       	std	Y+8, r21	; 0x08
    2dcc:	4f 83       	std	Y+7, r20	; 0x07
    2dce:	3a 87       	std	Y+10, r19	; 0x0a
    2dd0:	29 87       	std	Y+9, r18	; 0x09
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
    2dd2:	eb 81       	ldd	r30, Y+3	; 0x03
    2dd4:	fc 81       	ldd	r31, Y+4	; 0x04
    2dd6:	24 81       	ldd	r18, Z+4	; 0x04
    2dd8:	35 81       	ldd	r19, Z+5	; 0x05
    2dda:	89 85       	ldd	r24, Y+9	; 0x09
    2ddc:	9a 85       	ldd	r25, Y+10	; 0x0a
    2dde:	a9 01       	movw	r20, r18
    2de0:	48 1b       	sub	r20, r24
    2de2:	59 0b       	sbc	r21, r25
    2de4:	ca 01       	movw	r24, r20
    2de6:	2f 81       	ldd	r18, Y+7	; 0x07
    2de8:	38 85       	ldd	r19, Y+8	; 0x08
    2dea:	3e 87       	std	Y+14, r19	; 0x0e
    2dec:	2d 87       	std	Y+13, r18	; 0x0d
    2dee:	9c 87       	std	Y+12, r25	; 0x0c
    2df0:	8b 87       	std	Y+11, r24	; 0x0b
    2df2:	4b 85       	ldd	r20, Y+11	; 0x0b
    2df4:	5c 85       	ldd	r21, Y+12	; 0x0c
    2df6:	8d 85       	ldd	r24, Y+13	; 0x0d
    2df8:	9e 85       	ldd	r25, Y+14	; 0x0e
    2dfa:	84 17       	cp	r24, r20
    2dfc:	95 07       	cpc	r25, r21
    2dfe:	20 f4       	brcc	.+8      	; 0x2e08 <prvReadBytesFromBuffer+0x5a>
    2e00:	2d 85       	ldd	r18, Y+13	; 0x0d
    2e02:	3e 85       	ldd	r19, Y+14	; 0x0e
    2e04:	3c 87       	std	Y+12, r19	; 0x0c
    2e06:	2b 87       	std	Y+11, r18	; 0x0b
    2e08:	4b 85       	ldd	r20, Y+11	; 0x0b
    2e0a:	5c 85       	ldd	r21, Y+12	; 0x0c
    2e0c:	5a 83       	std	Y+2, r21	; 0x02
    2e0e:	49 83       	std	Y+1, r20	; 0x01

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2e10:	eb 81       	ldd	r30, Y+3	; 0x03
    2e12:	fc 81       	ldd	r31, Y+4	; 0x04
    2e14:	24 85       	ldd	r18, Z+12	; 0x0c
    2e16:	35 85       	ldd	r19, Z+13	; 0x0d
    2e18:	89 85       	ldd	r24, Y+9	; 0x09
    2e1a:	9a 85       	ldd	r25, Y+10	; 0x0a
    2e1c:	a9 01       	movw	r20, r18
    2e1e:	48 0f       	add	r20, r24
    2e20:	59 1f       	adc	r21, r25
    2e22:	8d 81       	ldd	r24, Y+5	; 0x05
    2e24:	9e 81       	ldd	r25, Y+6	; 0x06
    2e26:	29 81       	ldd	r18, Y+1	; 0x01
    2e28:	3a 81       	ldd	r19, Y+2	; 0x02
    2e2a:	ba 01       	movw	r22, r20
    2e2c:	a9 01       	movw	r20, r18
    2e2e:	0e 94 1b 32 	call	0x6436	; 0x6436 <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
    2e32:	2f 81       	ldd	r18, Y+7	; 0x07
    2e34:	38 85       	ldd	r19, Y+8	; 0x08
    2e36:	89 81       	ldd	r24, Y+1	; 0x01
    2e38:	9a 81       	ldd	r25, Y+2	; 0x02
    2e3a:	82 17       	cp	r24, r18
    2e3c:	93 07       	cpc	r25, r19
    2e3e:	b0 f4       	brcc	.+44     	; 0x2e6c <prvReadBytesFromBuffer+0xbe>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2e40:	2d 81       	ldd	r18, Y+5	; 0x05
    2e42:	3e 81       	ldd	r19, Y+6	; 0x06
    2e44:	89 81       	ldd	r24, Y+1	; 0x01
    2e46:	9a 81       	ldd	r25, Y+2	; 0x02
    2e48:	b9 01       	movw	r22, r18
    2e4a:	68 0f       	add	r22, r24
    2e4c:	79 1f       	adc	r23, r25
    2e4e:	eb 81       	ldd	r30, Y+3	; 0x03
    2e50:	fc 81       	ldd	r31, Y+4	; 0x04
    2e52:	44 85       	ldd	r20, Z+12	; 0x0c
    2e54:	55 85       	ldd	r21, Z+13	; 0x0d
    2e56:	2f 81       	ldd	r18, Y+7	; 0x07
    2e58:	38 85       	ldd	r19, Y+8	; 0x08
    2e5a:	89 81       	ldd	r24, Y+1	; 0x01
    2e5c:	9a 81       	ldd	r25, Y+2	; 0x02
    2e5e:	28 1b       	sub	r18, r24
    2e60:	39 0b       	sbc	r19, r25
    2e62:	cb 01       	movw	r24, r22
    2e64:	ba 01       	movw	r22, r20
    2e66:	a9 01       	movw	r20, r18
    2e68:	0e 94 1b 32 	call	0x6436	; 0x6436 <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
    2e6c:	29 85       	ldd	r18, Y+9	; 0x09
    2e6e:	3a 85       	ldd	r19, Y+10	; 0x0a
    2e70:	8f 81       	ldd	r24, Y+7	; 0x07
    2e72:	98 85       	ldd	r25, Y+8	; 0x08
    2e74:	82 0f       	add	r24, r18
    2e76:	93 1f       	adc	r25, r19
    2e78:	9a 87       	std	Y+10, r25	; 0x0a
    2e7a:	89 87       	std	Y+9, r24	; 0x09

    if( xTail >= pxStreamBuffer->xLength )
    2e7c:	eb 81       	ldd	r30, Y+3	; 0x03
    2e7e:	fc 81       	ldd	r31, Y+4	; 0x04
    2e80:	24 81       	ldd	r18, Z+4	; 0x04
    2e82:	35 81       	ldd	r19, Z+5	; 0x05
    2e84:	89 85       	ldd	r24, Y+9	; 0x09
    2e86:	9a 85       	ldd	r25, Y+10	; 0x0a
    2e88:	82 17       	cp	r24, r18
    2e8a:	93 07       	cpc	r25, r19
    2e8c:	50 f0       	brcs	.+20     	; 0x2ea2 <prvReadBytesFromBuffer+0xf4>
    {
        xTail -= pxStreamBuffer->xLength;
    2e8e:	eb 81       	ldd	r30, Y+3	; 0x03
    2e90:	fc 81       	ldd	r31, Y+4	; 0x04
    2e92:	24 81       	ldd	r18, Z+4	; 0x04
    2e94:	35 81       	ldd	r19, Z+5	; 0x05
    2e96:	89 85       	ldd	r24, Y+9	; 0x09
    2e98:	9a 85       	ldd	r25, Y+10	; 0x0a
    2e9a:	82 1b       	sub	r24, r18
    2e9c:	93 0b       	sbc	r25, r19
    2e9e:	9a 87       	std	Y+10, r25	; 0x0a
    2ea0:	89 87       	std	Y+9, r24	; 0x09
    }

    return xTail;
    2ea2:	89 85       	ldd	r24, Y+9	; 0x09
    2ea4:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    2ea6:	2e 96       	adiw	r28, 0x0e	; 14
    2ea8:	0f b6       	in	r0, 0x3f	; 63
    2eaa:	f8 94       	cli
    2eac:	de bf       	out	0x3e, r29	; 62
    2eae:	0f be       	out	0x3f, r0	; 63
    2eb0:	cd bf       	out	0x3d, r28	; 61
    2eb2:	cf 91       	pop	r28
    2eb4:	df 91       	pop	r29
    2eb6:	08 95       	ret

00002eb8 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    2eb8:	df 93       	push	r29
    2eba:	cf 93       	push	r28
    2ebc:	00 d0       	rcall	.+0      	; 0x2ebe <prvBytesInBuffer+0x6>
    2ebe:	00 d0       	rcall	.+0      	; 0x2ec0 <prvBytesInBuffer+0x8>
    2ec0:	cd b7       	in	r28, 0x3d	; 61
    2ec2:	de b7       	in	r29, 0x3e	; 62
    2ec4:	9c 83       	std	Y+4, r25	; 0x04
    2ec6:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2ec8:	eb 81       	ldd	r30, Y+3	; 0x03
    2eca:	fc 81       	ldd	r31, Y+4	; 0x04
    2ecc:	24 81       	ldd	r18, Z+4	; 0x04
    2ece:	35 81       	ldd	r19, Z+5	; 0x05
    2ed0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ed2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ed4:	82 81       	ldd	r24, Z+2	; 0x02
    2ed6:	93 81       	ldd	r25, Z+3	; 0x03
    2ed8:	82 0f       	add	r24, r18
    2eda:	93 1f       	adc	r25, r19
    2edc:	9a 83       	std	Y+2, r25	; 0x02
    2ede:	89 83       	std	Y+1, r24	; 0x01
    xCount -= pxStreamBuffer->xTail;
    2ee0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ee2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ee4:	20 81       	ld	r18, Z
    2ee6:	31 81       	ldd	r19, Z+1	; 0x01
    2ee8:	89 81       	ldd	r24, Y+1	; 0x01
    2eea:	9a 81       	ldd	r25, Y+2	; 0x02
    2eec:	82 1b       	sub	r24, r18
    2eee:	93 0b       	sbc	r25, r19
    2ef0:	9a 83       	std	Y+2, r25	; 0x02
    2ef2:	89 83       	std	Y+1, r24	; 0x01

    if( xCount >= pxStreamBuffer->xLength )
    2ef4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ef6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ef8:	24 81       	ldd	r18, Z+4	; 0x04
    2efa:	35 81       	ldd	r19, Z+5	; 0x05
    2efc:	89 81       	ldd	r24, Y+1	; 0x01
    2efe:	9a 81       	ldd	r25, Y+2	; 0x02
    2f00:	82 17       	cp	r24, r18
    2f02:	93 07       	cpc	r25, r19
    2f04:	50 f0       	brcs	.+20     	; 0x2f1a <prvBytesInBuffer+0x62>
    {
        xCount -= pxStreamBuffer->xLength;
    2f06:	eb 81       	ldd	r30, Y+3	; 0x03
    2f08:	fc 81       	ldd	r31, Y+4	; 0x04
    2f0a:	24 81       	ldd	r18, Z+4	; 0x04
    2f0c:	35 81       	ldd	r19, Z+5	; 0x05
    2f0e:	89 81       	ldd	r24, Y+1	; 0x01
    2f10:	9a 81       	ldd	r25, Y+2	; 0x02
    2f12:	82 1b       	sub	r24, r18
    2f14:	93 0b       	sbc	r25, r19
    2f16:	9a 83       	std	Y+2, r25	; 0x02
    2f18:	89 83       	std	Y+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xCount;
    2f1a:	89 81       	ldd	r24, Y+1	; 0x01
    2f1c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2f1e:	0f 90       	pop	r0
    2f20:	0f 90       	pop	r0
    2f22:	0f 90       	pop	r0
    2f24:	0f 90       	pop	r0
    2f26:	cf 91       	pop	r28
    2f28:	df 91       	pop	r29
    2f2a:	08 95       	ret

00002f2c <prvInitialiseNewStreamBuffer>:
                                          size_t xBufferSizeBytes,
                                          size_t xTriggerLevelBytes,
                                          uint8_t ucFlags,
                                          StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                          StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
{
    2f2c:	cf 92       	push	r12
    2f2e:	df 92       	push	r13
    2f30:	ef 92       	push	r14
    2f32:	ff 92       	push	r15
    2f34:	0f 93       	push	r16
    2f36:	df 93       	push	r29
    2f38:	cf 93       	push	r28
    2f3a:	cd b7       	in	r28, 0x3d	; 61
    2f3c:	de b7       	in	r29, 0x3e	; 62
    2f3e:	2d 97       	sbiw	r28, 0x0d	; 13
    2f40:	0f b6       	in	r0, 0x3f	; 63
    2f42:	f8 94       	cli
    2f44:	de bf       	out	0x3e, r29	; 62
    2f46:	0f be       	out	0x3f, r0	; 63
    2f48:	cd bf       	out	0x3d, r28	; 61
    2f4a:	9a 83       	std	Y+2, r25	; 0x02
    2f4c:	89 83       	std	Y+1, r24	; 0x01
    2f4e:	7c 83       	std	Y+4, r23	; 0x04
    2f50:	6b 83       	std	Y+3, r22	; 0x03
    2f52:	5e 83       	std	Y+6, r21	; 0x06
    2f54:	4d 83       	std	Y+5, r20	; 0x05
    2f56:	38 87       	std	Y+8, r19	; 0x08
    2f58:	2f 83       	std	Y+7, r18	; 0x07
    2f5a:	09 87       	std	Y+9, r16	; 0x09
    2f5c:	fb 86       	std	Y+11, r15	; 0x0b
    2f5e:	ea 86       	std	Y+10, r14	; 0x0a
    2f60:	dd 86       	std	Y+13, r13	; 0x0d
    2f62:	cc 86       	std	Y+12, r12	; 0x0c
        const BaseType_t xWriteValue = 0x55;
        configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
    } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    2f64:	89 81       	ldd	r24, Y+1	; 0x01
    2f66:	9a 81       	ldd	r25, Y+2	; 0x02
    2f68:	60 e0       	ldi	r22, 0x00	; 0
    2f6a:	70 e0       	ldi	r23, 0x00	; 0
    2f6c:	4f e0       	ldi	r20, 0x0F	; 15
    2f6e:	50 e0       	ldi	r21, 0x00	; 0
    2f70:	0e 94 24 32 	call	0x6448	; 0x6448 <memset>
    pxStreamBuffer->pucBuffer = pucBuffer;
    2f74:	e9 81       	ldd	r30, Y+1	; 0x01
    2f76:	fa 81       	ldd	r31, Y+2	; 0x02
    2f78:	8b 81       	ldd	r24, Y+3	; 0x03
    2f7a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f7c:	95 87       	std	Z+13, r25	; 0x0d
    2f7e:	84 87       	std	Z+12, r24	; 0x0c
    pxStreamBuffer->xLength = xBufferSizeBytes;
    2f80:	e9 81       	ldd	r30, Y+1	; 0x01
    2f82:	fa 81       	ldd	r31, Y+2	; 0x02
    2f84:	8d 81       	ldd	r24, Y+5	; 0x05
    2f86:	9e 81       	ldd	r25, Y+6	; 0x06
    2f88:	95 83       	std	Z+5, r25	; 0x05
    2f8a:	84 83       	std	Z+4, r24	; 0x04
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    2f8c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f8e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f90:	8f 81       	ldd	r24, Y+7	; 0x07
    2f92:	98 85       	ldd	r25, Y+8	; 0x08
    2f94:	97 83       	std	Z+7, r25	; 0x07
    2f96:	86 83       	std	Z+6, r24	; 0x06
    pxStreamBuffer->ucFlags = ucFlags;
    2f98:	e9 81       	ldd	r30, Y+1	; 0x01
    2f9a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f9c:	89 85       	ldd	r24, Y+9	; 0x09
    2f9e:	86 87       	std	Z+14, r24	; 0x0e
    {
        ( void ) pxSendCompletedCallback;
        ( void ) pxReceiveCompletedCallback;
    }
    #endif
}
    2fa0:	2d 96       	adiw	r28, 0x0d	; 13
    2fa2:	0f b6       	in	r0, 0x3f	; 63
    2fa4:	f8 94       	cli
    2fa6:	de bf       	out	0x3e, r29	; 62
    2fa8:	0f be       	out	0x3f, r0	; 63
    2faa:	cd bf       	out	0x3d, r28	; 61
    2fac:	cf 91       	pop	r28
    2fae:	df 91       	pop	r29
    2fb0:	0f 91       	pop	r16
    2fb2:	ff 90       	pop	r15
    2fb4:	ef 90       	pop	r14
    2fb6:	df 90       	pop	r13
    2fb8:	cf 90       	pop	r12
    2fba:	08 95       	ret

00002fbc <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    2fbc:	8f 92       	push	r8
    2fbe:	9f 92       	push	r9
    2fc0:	af 92       	push	r10
    2fc2:	bf 92       	push	r11
    2fc4:	cf 92       	push	r12
    2fc6:	df 92       	push	r13
    2fc8:	ef 92       	push	r14
    2fca:	ff 92       	push	r15
    2fcc:	0f 93       	push	r16
    2fce:	1f 93       	push	r17
    2fd0:	df 93       	push	r29
    2fd2:	cf 93       	push	r28
    2fd4:	cd b7       	in	r28, 0x3d	; 61
    2fd6:	de b7       	in	r29, 0x3e	; 62
    2fd8:	60 97       	sbiw	r28, 0x10	; 16
    2fda:	0f b6       	in	r0, 0x3f	; 63
    2fdc:	f8 94       	cli
    2fde:	de bf       	out	0x3e, r29	; 62
    2fe0:	0f be       	out	0x3f, r0	; 63
    2fe2:	cd bf       	out	0x3d, r28	; 61
    2fe4:	9f 83       	std	Y+7, r25	; 0x07
    2fe6:	8e 83       	std	Y+6, r24	; 0x06
    2fe8:	79 87       	std	Y+9, r23	; 0x09
    2fea:	68 87       	std	Y+8, r22	; 0x08
    2fec:	5b 87       	std	Y+11, r21	; 0x0b
    2fee:	4a 87       	std	Y+10, r20	; 0x0a
    2ff0:	3d 87       	std	Y+13, r19	; 0x0d
    2ff2:	2c 87       	std	Y+12, r18	; 0x0c
    2ff4:	0e 87       	std	Y+14, r16	; 0x0e
    2ff6:	f8 8a       	std	Y+16, r15	; 0x10
    2ff8:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
        {
            StackType_t * pxStack;

            /* Allocate space for the stack used by the task being created. */
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    2ffa:	8a 85       	ldd	r24, Y+10	; 0x0a
    2ffc:	9b 85       	ldd	r25, Y+11	; 0x0b
    2ffe:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    3002:	9a 83       	std	Y+2, r25	; 0x02
    3004:	89 83       	std	Y+1, r24	; 0x01

            if( pxStack != NULL )
    3006:	89 81       	ldd	r24, Y+1	; 0x01
    3008:	9a 81       	ldd	r25, Y+2	; 0x02
    300a:	00 97       	sbiw	r24, 0x00	; 0
    300c:	f1 f0       	breq	.+60     	; 0x304a <xTaskCreate+0x8e>
            {
                /* Allocate space for the TCB. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    300e:	86 e2       	ldi	r24, 0x26	; 38
    3010:	90 e0       	ldi	r25, 0x00	; 0
    3012:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    3016:	9d 83       	std	Y+5, r25	; 0x05
    3018:	8c 83       	std	Y+4, r24	; 0x04

                if( pxNewTCB != NULL )
    301a:	8c 81       	ldd	r24, Y+4	; 0x04
    301c:	9d 81       	ldd	r25, Y+5	; 0x05
    301e:	00 97       	sbiw	r24, 0x00	; 0
    3020:	79 f0       	breq	.+30     	; 0x3040 <xTaskCreate+0x84>
                {
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
    3022:	8c 81       	ldd	r24, Y+4	; 0x04
    3024:	9d 81       	ldd	r25, Y+5	; 0x05
    3026:	60 e0       	ldi	r22, 0x00	; 0
    3028:	70 e0       	ldi	r23, 0x00	; 0
    302a:	46 e2       	ldi	r20, 0x26	; 38
    302c:	50 e0       	ldi	r21, 0x00	; 0
    302e:	0e 94 24 32 	call	0x6448	; 0x6448 <memset>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
    3032:	ec 81       	ldd	r30, Y+4	; 0x04
    3034:	fd 81       	ldd	r31, Y+5	; 0x05
    3036:	89 81       	ldd	r24, Y+1	; 0x01
    3038:	9a 81       	ldd	r25, Y+2	; 0x02
    303a:	90 8f       	std	Z+24, r25	; 0x18
    303c:	87 8b       	std	Z+23, r24	; 0x17
    303e:	07 c0       	rjmp	.+14     	; 0x304e <xTaskCreate+0x92>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
    3040:	89 81       	ldd	r24, Y+1	; 0x01
    3042:	9a 81       	ldd	r25, Y+2	; 0x02
    3044:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
    3048:	02 c0       	rjmp	.+4      	; 0x304e <xTaskCreate+0x92>
                }
            }
            else
            {
                pxNewTCB = NULL;
    304a:	1d 82       	std	Y+5, r1	; 0x05
    304c:	1c 82       	std	Y+4, r1	; 0x04
            }
        }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    304e:	8c 81       	ldd	r24, Y+4	; 0x04
    3050:	9d 81       	ldd	r25, Y+5	; 0x05
    3052:	00 97       	sbiw	r24, 0x00	; 0
    3054:	e9 f0       	breq	.+58     	; 0x3090 <xTaskCreate+0xd4>
                 * task was created dynamically in case it is later deleted. */
                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3056:	8a 85       	ldd	r24, Y+10	; 0x0a
    3058:	9b 85       	ldd	r25, Y+11	; 0x0b
    305a:	9c 01       	movw	r18, r24
    305c:	40 e0       	ldi	r20, 0x00	; 0
    305e:	50 e0       	ldi	r21, 0x00	; 0
    3060:	8e 81       	ldd	r24, Y+6	; 0x06
    3062:	9f 81       	ldd	r25, Y+7	; 0x07
    3064:	68 85       	ldd	r22, Y+8	; 0x08
    3066:	79 85       	ldd	r23, Y+9	; 0x09
    3068:	ec 85       	ldd	r30, Y+12	; 0x0c
    306a:	fd 85       	ldd	r31, Y+13	; 0x0d
    306c:	af 85       	ldd	r26, Y+15	; 0x0f
    306e:	b8 89       	ldd	r27, Y+16	; 0x10
    3070:	ac 80       	ldd	r10, Y+4	; 0x04
    3072:	bd 80       	ldd	r11, Y+5	; 0x05
    3074:	8f 01       	movw	r16, r30
    3076:	ee 84       	ldd	r14, Y+14	; 0x0e
    3078:	6d 01       	movw	r12, r26
    307a:	88 24       	eor	r8, r8
    307c:	99 24       	eor	r9, r9
    307e:	0e 94 5e 18 	call	0x30bc	; 0x30bc <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    3082:	8c 81       	ldd	r24, Y+4	; 0x04
    3084:	9d 81       	ldd	r25, Y+5	; 0x05
    3086:	0e 94 0d 19 	call	0x321a	; 0x321a <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    308a:	81 e0       	ldi	r24, 0x01	; 1
    308c:	8b 83       	std	Y+3, r24	; 0x03
    308e:	02 c0       	rjmp	.+4      	; 0x3094 <xTaskCreate+0xd8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3090:	8f ef       	ldi	r24, 0xFF	; 255
    3092:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    3094:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    3096:	60 96       	adiw	r28, 0x10	; 16
    3098:	0f b6       	in	r0, 0x3f	; 63
    309a:	f8 94       	cli
    309c:	de bf       	out	0x3e, r29	; 62
    309e:	0f be       	out	0x3f, r0	; 63
    30a0:	cd bf       	out	0x3d, r28	; 61
    30a2:	cf 91       	pop	r28
    30a4:	df 91       	pop	r29
    30a6:	1f 91       	pop	r17
    30a8:	0f 91       	pop	r16
    30aa:	ff 90       	pop	r15
    30ac:	ef 90       	pop	r14
    30ae:	df 90       	pop	r13
    30b0:	cf 90       	pop	r12
    30b2:	bf 90       	pop	r11
    30b4:	af 90       	pop	r10
    30b6:	9f 90       	pop	r9
    30b8:	8f 90       	pop	r8
    30ba:	08 95       	ret

000030bc <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    30bc:	8f 92       	push	r8
    30be:	9f 92       	push	r9
    30c0:	af 92       	push	r10
    30c2:	bf 92       	push	r11
    30c4:	cf 92       	push	r12
    30c6:	df 92       	push	r13
    30c8:	ef 92       	push	r14
    30ca:	0f 93       	push	r16
    30cc:	1f 93       	push	r17
    30ce:	df 93       	push	r29
    30d0:	cf 93       	push	r28
    30d2:	cd b7       	in	r28, 0x3d	; 61
    30d4:	de b7       	in	r29, 0x3e	; 62
    30d6:	64 97       	sbiw	r28, 0x14	; 20
    30d8:	0f b6       	in	r0, 0x3f	; 63
    30da:	f8 94       	cli
    30dc:	de bf       	out	0x3e, r29	; 62
    30de:	0f be       	out	0x3f, r0	; 63
    30e0:	cd bf       	out	0x3d, r28	; 61
    30e2:	9d 83       	std	Y+5, r25	; 0x05
    30e4:	8c 83       	std	Y+4, r24	; 0x04
    30e6:	7f 83       	std	Y+7, r23	; 0x07
    30e8:	6e 83       	std	Y+6, r22	; 0x06
    30ea:	28 87       	std	Y+8, r18	; 0x08
    30ec:	39 87       	std	Y+9, r19	; 0x09
    30ee:	4a 87       	std	Y+10, r20	; 0x0a
    30f0:	5b 87       	std	Y+11, r21	; 0x0b
    30f2:	1d 87       	std	Y+13, r17	; 0x0d
    30f4:	0c 87       	std	Y+12, r16	; 0x0c
    30f6:	ee 86       	std	Y+14, r14	; 0x0e
    30f8:	d8 8a       	std	Y+16, r13	; 0x10
    30fa:	cf 86       	std	Y+15, r12	; 0x0f
    30fc:	ba 8a       	std	Y+18, r11	; 0x12
    30fe:	a9 8a       	std	Y+17, r10	; 0x11
    3100:	9c 8a       	std	Y+20, r9	; 0x14
    3102:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
    {
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3104:	e9 89       	ldd	r30, Y+17	; 0x11
    3106:	fa 89       	ldd	r31, Y+18	; 0x12
    3108:	27 89       	ldd	r18, Z+23	; 0x17
    310a:	30 8d       	ldd	r19, Z+24	; 0x18
    310c:	88 85       	ldd	r24, Y+8	; 0x08
    310e:	99 85       	ldd	r25, Y+9	; 0x09
    3110:	01 97       	sbiw	r24, 0x01	; 1
    3112:	82 0f       	add	r24, r18
    3114:	93 1f       	adc	r25, r19
    3116:	9b 83       	std	Y+3, r25	; 0x03
    3118:	8a 83       	std	Y+2, r24	; 0x02
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    311a:	8e 81       	ldd	r24, Y+6	; 0x06
    311c:	9f 81       	ldd	r25, Y+7	; 0x07
    311e:	00 97       	sbiw	r24, 0x00	; 0
    3120:	49 f1       	breq	.+82     	; 0x3174 <prvInitialiseNewTask+0xb8>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3122:	19 82       	std	Y+1, r1	; 0x01
    3124:	21 c0       	rjmp	.+66     	; 0x3168 <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3126:	89 81       	ldd	r24, Y+1	; 0x01
    3128:	48 2f       	mov	r20, r24
    312a:	50 e0       	ldi	r21, 0x00	; 0
    312c:	89 81       	ldd	r24, Y+1	; 0x01
    312e:	28 2f       	mov	r18, r24
    3130:	30 e0       	ldi	r19, 0x00	; 0
    3132:	8e 81       	ldd	r24, Y+6	; 0x06
    3134:	9f 81       	ldd	r25, Y+7	; 0x07
    3136:	fc 01       	movw	r30, r24
    3138:	e2 0f       	add	r30, r18
    313a:	f3 1f       	adc	r31, r19
    313c:	20 81       	ld	r18, Z
    313e:	89 89       	ldd	r24, Y+17	; 0x11
    3140:	9a 89       	ldd	r25, Y+18	; 0x12
    3142:	84 0f       	add	r24, r20
    3144:	95 1f       	adc	r25, r21
    3146:	fc 01       	movw	r30, r24
    3148:	79 96       	adiw	r30, 0x19	; 25
    314a:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    314c:	89 81       	ldd	r24, Y+1	; 0x01
    314e:	28 2f       	mov	r18, r24
    3150:	30 e0       	ldi	r19, 0x00	; 0
    3152:	8e 81       	ldd	r24, Y+6	; 0x06
    3154:	9f 81       	ldd	r25, Y+7	; 0x07
    3156:	fc 01       	movw	r30, r24
    3158:	e2 0f       	add	r30, r18
    315a:	f3 1f       	adc	r31, r19
    315c:	80 81       	ld	r24, Z
    315e:	88 23       	and	r24, r24
    3160:	31 f0       	breq	.+12     	; 0x316e <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3162:	89 81       	ldd	r24, Y+1	; 0x01
    3164:	8f 5f       	subi	r24, 0xFF	; 255
    3166:	89 83       	std	Y+1, r24	; 0x01
    3168:	89 81       	ldd	r24, Y+1	; 0x01
    316a:	88 30       	cpi	r24, 0x08	; 8
    316c:	e0 f2       	brcs	.-72     	; 0x3126 <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    316e:	e9 89       	ldd	r30, Y+17	; 0x11
    3170:	fa 89       	ldd	r31, Y+18	; 0x12
    3172:	10 a2       	std	Z+32, r1	; 0x20
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3174:	8e 85       	ldd	r24, Y+14	; 0x0e
    3176:	84 30       	cpi	r24, 0x04	; 4
    3178:	10 f0       	brcs	.+4      	; 0x317e <prvInitialiseNewTask+0xc2>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    317a:	83 e0       	ldi	r24, 0x03	; 3
    317c:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    317e:	e9 89       	ldd	r30, Y+17	; 0x11
    3180:	fa 89       	ldd	r31, Y+18	; 0x12
    3182:	8e 85       	ldd	r24, Y+14	; 0x0e
    3184:	86 8b       	std	Z+22, r24	; 0x16
    {
        pxNewTCB->uxBasePriority = uxPriority;
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3186:	89 89       	ldd	r24, Y+17	; 0x11
    3188:	9a 89       	ldd	r25, Y+18	; 0x12
    318a:	02 96       	adiw	r24, 0x02	; 2
    318c:	0e 94 0c 07 	call	0xe18	; 0xe18 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3190:	89 89       	ldd	r24, Y+17	; 0x11
    3192:	9a 89       	ldd	r25, Y+18	; 0x12
    3194:	0c 96       	adiw	r24, 0x0c	; 12
    3196:	0e 94 0c 07 	call	0xe18	; 0xe18 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    319a:	e9 89       	ldd	r30, Y+17	; 0x11
    319c:	fa 89       	ldd	r31, Y+18	; 0x12
    319e:	89 89       	ldd	r24, Y+17	; 0x11
    31a0:	9a 89       	ldd	r25, Y+18	; 0x12
    31a2:	91 87       	std	Z+9, r25	; 0x09
    31a4:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    31a6:	8e 85       	ldd	r24, Y+14	; 0x0e
    31a8:	28 2f       	mov	r18, r24
    31aa:	30 e0       	ldi	r19, 0x00	; 0
    31ac:	84 e0       	ldi	r24, 0x04	; 4
    31ae:	90 e0       	ldi	r25, 0x00	; 0
    31b0:	82 1b       	sub	r24, r18
    31b2:	93 0b       	sbc	r25, r19
    31b4:	e9 89       	ldd	r30, Y+17	; 0x11
    31b6:	fa 89       	ldd	r31, Y+18	; 0x12
    31b8:	95 87       	std	Z+13, r25	; 0x0d
    31ba:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    31bc:	e9 89       	ldd	r30, Y+17	; 0x11
    31be:	fa 89       	ldd	r31, Y+18	; 0x12
    31c0:	89 89       	ldd	r24, Y+17	; 0x11
    31c2:	9a 89       	ldd	r25, Y+18	; 0x12
    31c4:	93 8b       	std	Z+19, r25	; 0x13
    31c6:	82 8b       	std	Z+18, r24	; 0x12
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    31c8:	8a 81       	ldd	r24, Y+2	; 0x02
    31ca:	9b 81       	ldd	r25, Y+3	; 0x03
    31cc:	2c 81       	ldd	r18, Y+4	; 0x04
    31ce:	3d 81       	ldd	r19, Y+5	; 0x05
    31d0:	4c 85       	ldd	r20, Y+12	; 0x0c
    31d2:	5d 85       	ldd	r21, Y+13	; 0x0d
    31d4:	b9 01       	movw	r22, r18
    31d6:	0e 94 c9 00 	call	0x192	; 0x192 <pxPortInitialiseStack>
    31da:	e9 89       	ldd	r30, Y+17	; 0x11
    31dc:	fa 89       	ldd	r31, Y+18	; 0x12
    31de:	91 83       	std	Z+1, r25	; 0x01
    31e0:	80 83       	st	Z, r24
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
    }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    31e2:	8f 85       	ldd	r24, Y+15	; 0x0f
    31e4:	98 89       	ldd	r25, Y+16	; 0x10
    31e6:	00 97       	sbiw	r24, 0x00	; 0
    31e8:	31 f0       	breq	.+12     	; 0x31f6 <prvInitialiseNewTask+0x13a>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    31ea:	ef 85       	ldd	r30, Y+15	; 0x0f
    31ec:	f8 89       	ldd	r31, Y+16	; 0x10
    31ee:	89 89       	ldd	r24, Y+17	; 0x11
    31f0:	9a 89       	ldd	r25, Y+18	; 0x12
    31f2:	91 83       	std	Z+1, r25	; 0x01
    31f4:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    31f6:	64 96       	adiw	r28, 0x14	; 20
    31f8:	0f b6       	in	r0, 0x3f	; 63
    31fa:	f8 94       	cli
    31fc:	de bf       	out	0x3e, r29	; 62
    31fe:	0f be       	out	0x3f, r0	; 63
    3200:	cd bf       	out	0x3d, r28	; 61
    3202:	cf 91       	pop	r28
    3204:	df 91       	pop	r29
    3206:	1f 91       	pop	r17
    3208:	0f 91       	pop	r16
    320a:	ef 90       	pop	r14
    320c:	df 90       	pop	r13
    320e:	cf 90       	pop	r12
    3210:	bf 90       	pop	r11
    3212:	af 90       	pop	r10
    3214:	9f 90       	pop	r9
    3216:	8f 90       	pop	r8
    3218:	08 95       	ret

0000321a <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    321a:	df 93       	push	r29
    321c:	cf 93       	push	r28
    321e:	00 d0       	rcall	.+0      	; 0x3220 <prvAddNewTaskToReadyList+0x6>
    3220:	00 d0       	rcall	.+0      	; 0x3222 <prvAddNewTaskToReadyList+0x8>
    3222:	cd b7       	in	r28, 0x3d	; 61
    3224:	de b7       	in	r29, 0x3e	; 62
    3226:	9c 83       	std	Y+4, r25	; 0x04
    3228:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    322a:	0f b6       	in	r0, 0x3f	; 63
    322c:	f8 94       	cli
    322e:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    3230:	80 91 67 06 	lds	r24, 0x0667
    3234:	8f 5f       	subi	r24, 0xFF	; 255
    3236:	80 93 67 06 	sts	0x0667, r24

        if( pxCurrentTCB == NULL )
    323a:	80 91 64 06 	lds	r24, 0x0664
    323e:	90 91 65 06 	lds	r25, 0x0665
    3242:	00 97       	sbiw	r24, 0x00	; 0
    3244:	69 f4       	brne	.+26     	; 0x3260 <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    3246:	8b 81       	ldd	r24, Y+3	; 0x03
    3248:	9c 81       	ldd	r25, Y+4	; 0x04
    324a:	90 93 65 06 	sts	0x0665, r25
    324e:	80 93 64 06 	sts	0x0664, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3252:	80 91 67 06 	lds	r24, 0x0667
    3256:	81 30       	cpi	r24, 0x01	; 1
    3258:	b9 f4       	brne	.+46     	; 0x3288 <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    325a:	0e 94 f6 22 	call	0x45ec	; 0x45ec <prvInitialiseTaskLists>
    325e:	14 c0       	rjmp	.+40     	; 0x3288 <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    3260:	80 91 6b 06 	lds	r24, 0x066B
    3264:	88 23       	and	r24, r24
    3266:	81 f4       	brne	.+32     	; 0x3288 <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3268:	e0 91 64 06 	lds	r30, 0x0664
    326c:	f0 91 65 06 	lds	r31, 0x0665
    3270:	96 89       	ldd	r25, Z+22	; 0x16
    3272:	eb 81       	ldd	r30, Y+3	; 0x03
    3274:	fc 81       	ldd	r31, Y+4	; 0x04
    3276:	86 89       	ldd	r24, Z+22	; 0x16
    3278:	89 17       	cp	r24, r25
    327a:	30 f0       	brcs	.+12     	; 0x3288 <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    327c:	8b 81       	ldd	r24, Y+3	; 0x03
    327e:	9c 81       	ldd	r25, Y+4	; 0x04
    3280:	90 93 65 06 	sts	0x0665, r25
    3284:	80 93 64 06 	sts	0x0664, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    3288:	80 91 70 06 	lds	r24, 0x0670
    328c:	8f 5f       	subi	r24, 0xFF	; 255
    328e:	80 93 70 06 	sts	0x0670, r24
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    3292:	eb 81       	ldd	r30, Y+3	; 0x03
    3294:	fc 81       	ldd	r31, Y+4	; 0x04
    3296:	96 89       	ldd	r25, Z+22	; 0x16
    3298:	80 91 6a 06 	lds	r24, 0x066A
    329c:	89 17       	cp	r24, r25
    329e:	28 f4       	brcc	.+10     	; 0x32aa <prvAddNewTaskToReadyList+0x90>
    32a0:	eb 81       	ldd	r30, Y+3	; 0x03
    32a2:	fc 81       	ldd	r31, Y+4	; 0x04
    32a4:	86 89       	ldd	r24, Z+22	; 0x16
    32a6:	80 93 6a 06 	sts	0x066A, r24
    32aa:	eb 81       	ldd	r30, Y+3	; 0x03
    32ac:	fc 81       	ldd	r31, Y+4	; 0x04
    32ae:	86 89       	ldd	r24, Z+22	; 0x16
    32b0:	28 2f       	mov	r18, r24
    32b2:	30 e0       	ldi	r19, 0x00	; 0
    32b4:	c9 01       	movw	r24, r18
    32b6:	88 0f       	add	r24, r24
    32b8:	99 1f       	adc	r25, r25
    32ba:	88 0f       	add	r24, r24
    32bc:	99 1f       	adc	r25, r25
    32be:	88 0f       	add	r24, r24
    32c0:	99 1f       	adc	r25, r25
    32c2:	82 0f       	add	r24, r18
    32c4:	93 1f       	adc	r25, r19
    32c6:	fc 01       	movw	r30, r24
    32c8:	ea 58       	subi	r30, 0x8A	; 138
    32ca:	f9 4f       	sbci	r31, 0xF9	; 249
    32cc:	81 81       	ldd	r24, Z+1	; 0x01
    32ce:	92 81       	ldd	r25, Z+2	; 0x02
    32d0:	9a 83       	std	Y+2, r25	; 0x02
    32d2:	89 83       	std	Y+1, r24	; 0x01
    32d4:	eb 81       	ldd	r30, Y+3	; 0x03
    32d6:	fc 81       	ldd	r31, Y+4	; 0x04
    32d8:	89 81       	ldd	r24, Y+1	; 0x01
    32da:	9a 81       	ldd	r25, Y+2	; 0x02
    32dc:	95 83       	std	Z+5, r25	; 0x05
    32de:	84 83       	std	Z+4, r24	; 0x04
    32e0:	e9 81       	ldd	r30, Y+1	; 0x01
    32e2:	fa 81       	ldd	r31, Y+2	; 0x02
    32e4:	84 81       	ldd	r24, Z+4	; 0x04
    32e6:	95 81       	ldd	r25, Z+5	; 0x05
    32e8:	eb 81       	ldd	r30, Y+3	; 0x03
    32ea:	fc 81       	ldd	r31, Y+4	; 0x04
    32ec:	97 83       	std	Z+7, r25	; 0x07
    32ee:	86 83       	std	Z+6, r24	; 0x06
    32f0:	e9 81       	ldd	r30, Y+1	; 0x01
    32f2:	fa 81       	ldd	r31, Y+2	; 0x02
    32f4:	04 80       	ldd	r0, Z+4	; 0x04
    32f6:	f5 81       	ldd	r31, Z+5	; 0x05
    32f8:	e0 2d       	mov	r30, r0
    32fa:	8b 81       	ldd	r24, Y+3	; 0x03
    32fc:	9c 81       	ldd	r25, Y+4	; 0x04
    32fe:	02 96       	adiw	r24, 0x02	; 2
    3300:	93 83       	std	Z+3, r25	; 0x03
    3302:	82 83       	std	Z+2, r24	; 0x02
    3304:	8b 81       	ldd	r24, Y+3	; 0x03
    3306:	9c 81       	ldd	r25, Y+4	; 0x04
    3308:	02 96       	adiw	r24, 0x02	; 2
    330a:	e9 81       	ldd	r30, Y+1	; 0x01
    330c:	fa 81       	ldd	r31, Y+2	; 0x02
    330e:	95 83       	std	Z+5, r25	; 0x05
    3310:	84 83       	std	Z+4, r24	; 0x04
    3312:	eb 81       	ldd	r30, Y+3	; 0x03
    3314:	fc 81       	ldd	r31, Y+4	; 0x04
    3316:	86 89       	ldd	r24, Z+22	; 0x16
    3318:	28 2f       	mov	r18, r24
    331a:	30 e0       	ldi	r19, 0x00	; 0
    331c:	c9 01       	movw	r24, r18
    331e:	88 0f       	add	r24, r24
    3320:	99 1f       	adc	r25, r25
    3322:	88 0f       	add	r24, r24
    3324:	99 1f       	adc	r25, r25
    3326:	88 0f       	add	r24, r24
    3328:	99 1f       	adc	r25, r25
    332a:	82 0f       	add	r24, r18
    332c:	93 1f       	adc	r25, r19
    332e:	8a 58       	subi	r24, 0x8A	; 138
    3330:	99 4f       	sbci	r25, 0xF9	; 249
    3332:	eb 81       	ldd	r30, Y+3	; 0x03
    3334:	fc 81       	ldd	r31, Y+4	; 0x04
    3336:	93 87       	std	Z+11, r25	; 0x0b
    3338:	82 87       	std	Z+10, r24	; 0x0a
    333a:	eb 81       	ldd	r30, Y+3	; 0x03
    333c:	fc 81       	ldd	r31, Y+4	; 0x04
    333e:	86 89       	ldd	r24, Z+22	; 0x16
    3340:	28 2f       	mov	r18, r24
    3342:	30 e0       	ldi	r19, 0x00	; 0
    3344:	c9 01       	movw	r24, r18
    3346:	88 0f       	add	r24, r24
    3348:	99 1f       	adc	r25, r25
    334a:	88 0f       	add	r24, r24
    334c:	99 1f       	adc	r25, r25
    334e:	88 0f       	add	r24, r24
    3350:	99 1f       	adc	r25, r25
    3352:	82 0f       	add	r24, r18
    3354:	93 1f       	adc	r25, r19
    3356:	fc 01       	movw	r30, r24
    3358:	ea 58       	subi	r30, 0x8A	; 138
    335a:	f9 4f       	sbci	r31, 0xF9	; 249
    335c:	80 81       	ld	r24, Z
    335e:	8f 5f       	subi	r24, 0xFF	; 255
    3360:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    3362:	0f 90       	pop	r0
    3364:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    3366:	80 91 6b 06 	lds	r24, 0x066B
    336a:	88 23       	and	r24, r24
    336c:	61 f0       	breq	.+24     	; 0x3386 <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    336e:	e0 91 64 06 	lds	r30, 0x0664
    3372:	f0 91 65 06 	lds	r31, 0x0665
    3376:	96 89       	ldd	r25, Z+22	; 0x16
    3378:	eb 81       	ldd	r30, Y+3	; 0x03
    337a:	fc 81       	ldd	r31, Y+4	; 0x04
    337c:	86 89       	ldd	r24, Z+22	; 0x16
    337e:	98 17       	cp	r25, r24
    3380:	10 f4       	brcc	.+4      	; 0x3386 <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    3382:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3386:	0f 90       	pop	r0
    3388:	0f 90       	pop	r0
    338a:	0f 90       	pop	r0
    338c:	0f 90       	pop	r0
    338e:	cf 91       	pop	r28
    3390:	df 91       	pop	r29
    3392:	08 95       	ret

00003394 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    3394:	df 93       	push	r29
    3396:	cf 93       	push	r28
    3398:	00 d0       	rcall	.+0      	; 0x339a <vTaskDelete+0x6>
    339a:	00 d0       	rcall	.+0      	; 0x339c <vTaskDelete+0x8>
    339c:	00 d0       	rcall	.+0      	; 0x339e <vTaskDelete+0xa>
    339e:	cd b7       	in	r28, 0x3d	; 61
    33a0:	de b7       	in	r29, 0x3e	; 62
    33a2:	9c 83       	std	Y+4, r25	; 0x04
    33a4:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    33a6:	0f b6       	in	r0, 0x3f	; 63
    33a8:	f8 94       	cli
    33aa:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    33ac:	8b 81       	ldd	r24, Y+3	; 0x03
    33ae:	9c 81       	ldd	r25, Y+4	; 0x04
    33b0:	00 97       	sbiw	r24, 0x00	; 0
    33b2:	39 f4       	brne	.+14     	; 0x33c2 <vTaskDelete+0x2e>
    33b4:	80 91 64 06 	lds	r24, 0x0664
    33b8:	90 91 65 06 	lds	r25, 0x0665
    33bc:	9e 83       	std	Y+6, r25	; 0x06
    33be:	8d 83       	std	Y+5, r24	; 0x05
    33c0:	04 c0       	rjmp	.+8      	; 0x33ca <vTaskDelete+0x36>
    33c2:	8b 81       	ldd	r24, Y+3	; 0x03
    33c4:	9c 81       	ldd	r25, Y+4	; 0x04
    33c6:	9e 83       	std	Y+6, r25	; 0x06
    33c8:	8d 83       	std	Y+5, r24	; 0x05
    33ca:	8d 81       	ldd	r24, Y+5	; 0x05
    33cc:	9e 81       	ldd	r25, Y+6	; 0x06
    33ce:	9a 83       	std	Y+2, r25	; 0x02
    33d0:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    33d2:	89 81       	ldd	r24, Y+1	; 0x01
    33d4:	9a 81       	ldd	r25, Y+2	; 0x02
    33d6:	02 96       	adiw	r24, 0x02	; 2
    33d8:	0e 94 cc 07 	call	0xf98	; 0xf98 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    33dc:	e9 81       	ldd	r30, Y+1	; 0x01
    33de:	fa 81       	ldd	r31, Y+2	; 0x02
    33e0:	84 89       	ldd	r24, Z+20	; 0x14
    33e2:	95 89       	ldd	r25, Z+21	; 0x15
    33e4:	00 97       	sbiw	r24, 0x00	; 0
    33e6:	29 f0       	breq	.+10     	; 0x33f2 <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    33e8:	89 81       	ldd	r24, Y+1	; 0x01
    33ea:	9a 81       	ldd	r25, Y+2	; 0x02
    33ec:	0c 96       	adiw	r24, 0x0c	; 12
    33ee:	0e 94 cc 07 	call	0xf98	; 0xf98 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    33f2:	80 91 70 06 	lds	r24, 0x0670
    33f6:	8f 5f       	subi	r24, 0xFF	; 255
    33f8:	80 93 70 06 	sts	0x0670, r24

            if( pxTCB == pxCurrentTCB )
    33fc:	20 91 64 06 	lds	r18, 0x0664
    3400:	30 91 65 06 	lds	r19, 0x0665
    3404:	89 81       	ldd	r24, Y+1	; 0x01
    3406:	9a 81       	ldd	r25, Y+2	; 0x02
    3408:	82 17       	cp	r24, r18
    340a:	93 07       	cpc	r25, r19
    340c:	81 f4       	brne	.+32     	; 0x342e <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    340e:	89 81       	ldd	r24, Y+1	; 0x01
    3410:	9a 81       	ldd	r25, Y+2	; 0x02
    3412:	9c 01       	movw	r18, r24
    3414:	2e 5f       	subi	r18, 0xFE	; 254
    3416:	3f 4f       	sbci	r19, 0xFF	; 255
    3418:	89 eb       	ldi	r24, 0xB9	; 185
    341a:	96 e0       	ldi	r25, 0x06	; 6
    341c:	b9 01       	movw	r22, r18
    341e:	0e 94 1c 07 	call	0xe38	; 0xe38 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    3422:	80 91 66 06 	lds	r24, 0x0666
    3426:	8f 5f       	subi	r24, 0xFF	; 255
    3428:	80 93 66 06 	sts	0x0666, r24
    342c:	07 c0       	rjmp	.+14     	; 0x343c <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    342e:	80 91 67 06 	lds	r24, 0x0667
    3432:	81 50       	subi	r24, 0x01	; 1
    3434:	80 93 67 06 	sts	0x0667, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    3438:	0e 94 78 23 	call	0x46f0	; 0x46f0 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    343c:	0f 90       	pop	r0
    343e:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    3440:	20 91 64 06 	lds	r18, 0x0664
    3444:	30 91 65 06 	lds	r19, 0x0665
    3448:	89 81       	ldd	r24, Y+1	; 0x01
    344a:	9a 81       	ldd	r25, Y+2	; 0x02
    344c:	82 17       	cp	r24, r18
    344e:	93 07       	cpc	r25, r19
    3450:	21 f0       	breq	.+8      	; 0x345a <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    3452:	89 81       	ldd	r24, Y+1	; 0x01
    3454:	9a 81       	ldd	r25, Y+2	; 0x02
    3456:	0e 94 62 23 	call	0x46c4	; 0x46c4 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    345a:	80 91 6b 06 	lds	r24, 0x066B
    345e:	88 23       	and	r24, r24
    3460:	59 f0       	breq	.+22     	; 0x3478 <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    3462:	20 91 64 06 	lds	r18, 0x0664
    3466:	30 91 65 06 	lds	r19, 0x0665
    346a:	89 81       	ldd	r24, Y+1	; 0x01
    346c:	9a 81       	ldd	r25, Y+2	; 0x02
    346e:	82 17       	cp	r24, r18
    3470:	93 07       	cpc	r25, r19
    3472:	11 f4       	brne	.+4      	; 0x3478 <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    3474:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    3478:	26 96       	adiw	r28, 0x06	; 6
    347a:	0f b6       	in	r0, 0x3f	; 63
    347c:	f8 94       	cli
    347e:	de bf       	out	0x3e, r29	; 62
    3480:	0f be       	out	0x3f, r0	; 63
    3482:	cd bf       	out	0x3d, r28	; 61
    3484:	cf 91       	pop	r28
    3486:	df 91       	pop	r29
    3488:	08 95       	ret

0000348a <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    348a:	df 93       	push	r29
    348c:	cf 93       	push	r28
    348e:	cd b7       	in	r28, 0x3d	; 61
    3490:	de b7       	in	r29, 0x3e	; 62
    3492:	2a 97       	sbiw	r28, 0x0a	; 10
    3494:	0f b6       	in	r0, 0x3f	; 63
    3496:	f8 94       	cli
    3498:	de bf       	out	0x3e, r29	; 62
    349a:	0f be       	out	0x3f, r0	; 63
    349c:	cd bf       	out	0x3d, r28	; 61
    349e:	98 87       	std	Y+8, r25	; 0x08
    34a0:	8f 83       	std	Y+7, r24	; 0x07
    34a2:	7a 87       	std	Y+10, r23	; 0x0a
    34a4:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    34a6:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    34a8:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    34ac:	80 91 68 06 	lds	r24, 0x0668
    34b0:	90 91 69 06 	lds	r25, 0x0669
    34b4:	9a 83       	std	Y+2, r25	; 0x02
    34b6:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    34b8:	ef 81       	ldd	r30, Y+7	; 0x07
    34ba:	f8 85       	ldd	r31, Y+8	; 0x08
    34bc:	20 81       	ld	r18, Z
    34be:	31 81       	ldd	r19, Z+1	; 0x01
    34c0:	89 85       	ldd	r24, Y+9	; 0x09
    34c2:	9a 85       	ldd	r25, Y+10	; 0x0a
    34c4:	82 0f       	add	r24, r18
    34c6:	93 1f       	adc	r25, r19
    34c8:	9e 83       	std	Y+6, r25	; 0x06
    34ca:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    34cc:	ef 81       	ldd	r30, Y+7	; 0x07
    34ce:	f8 85       	ldd	r31, Y+8	; 0x08
    34d0:	20 81       	ld	r18, Z
    34d2:	31 81       	ldd	r19, Z+1	; 0x01
    34d4:	89 81       	ldd	r24, Y+1	; 0x01
    34d6:	9a 81       	ldd	r25, Y+2	; 0x02
    34d8:	82 17       	cp	r24, r18
    34da:	93 07       	cpc	r25, r19
    34dc:	98 f4       	brcc	.+38     	; 0x3504 <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    34de:	ef 81       	ldd	r30, Y+7	; 0x07
    34e0:	f8 85       	ldd	r31, Y+8	; 0x08
    34e2:	20 81       	ld	r18, Z
    34e4:	31 81       	ldd	r19, Z+1	; 0x01
    34e6:	8d 81       	ldd	r24, Y+5	; 0x05
    34e8:	9e 81       	ldd	r25, Y+6	; 0x06
    34ea:	82 17       	cp	r24, r18
    34ec:	93 07       	cpc	r25, r19
    34ee:	e0 f4       	brcc	.+56     	; 0x3528 <xTaskDelayUntil+0x9e>
    34f0:	2d 81       	ldd	r18, Y+5	; 0x05
    34f2:	3e 81       	ldd	r19, Y+6	; 0x06
    34f4:	89 81       	ldd	r24, Y+1	; 0x01
    34f6:	9a 81       	ldd	r25, Y+2	; 0x02
    34f8:	82 17       	cp	r24, r18
    34fa:	93 07       	cpc	r25, r19
    34fc:	a8 f4       	brcc	.+42     	; 0x3528 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    34fe:	81 e0       	ldi	r24, 0x01	; 1
    3500:	8b 83       	std	Y+3, r24	; 0x03
    3502:	12 c0       	rjmp	.+36     	; 0x3528 <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    3504:	ef 81       	ldd	r30, Y+7	; 0x07
    3506:	f8 85       	ldd	r31, Y+8	; 0x08
    3508:	20 81       	ld	r18, Z
    350a:	31 81       	ldd	r19, Z+1	; 0x01
    350c:	8d 81       	ldd	r24, Y+5	; 0x05
    350e:	9e 81       	ldd	r25, Y+6	; 0x06
    3510:	82 17       	cp	r24, r18
    3512:	93 07       	cpc	r25, r19
    3514:	38 f0       	brcs	.+14     	; 0x3524 <xTaskDelayUntil+0x9a>
    3516:	2d 81       	ldd	r18, Y+5	; 0x05
    3518:	3e 81       	ldd	r19, Y+6	; 0x06
    351a:	89 81       	ldd	r24, Y+1	; 0x01
    351c:	9a 81       	ldd	r25, Y+2	; 0x02
    351e:	82 17       	cp	r24, r18
    3520:	93 07       	cpc	r25, r19
    3522:	10 f4       	brcc	.+4      	; 0x3528 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    3524:	81 e0       	ldi	r24, 0x01	; 1
    3526:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    3528:	ef 81       	ldd	r30, Y+7	; 0x07
    352a:	f8 85       	ldd	r31, Y+8	; 0x08
    352c:	8d 81       	ldd	r24, Y+5	; 0x05
    352e:	9e 81       	ldd	r25, Y+6	; 0x06
    3530:	91 83       	std	Z+1, r25	; 0x01
    3532:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    3534:	8b 81       	ldd	r24, Y+3	; 0x03
    3536:	88 23       	and	r24, r24
    3538:	49 f0       	breq	.+18     	; 0x354c <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    353a:	8d 81       	ldd	r24, Y+5	; 0x05
    353c:	9e 81       	ldd	r25, Y+6	; 0x06
    353e:	29 81       	ldd	r18, Y+1	; 0x01
    3540:	3a 81       	ldd	r19, Y+2	; 0x02
    3542:	82 1b       	sub	r24, r18
    3544:	93 0b       	sbc	r25, r19
    3546:	60 e0       	ldi	r22, 0x00	; 0
    3548:	0e 94 71 2b 	call	0x56e2	; 0x56e2 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    354c:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
    3550:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3552:	8c 81       	ldd	r24, Y+4	; 0x04
    3554:	88 23       	and	r24, r24
    3556:	11 f4       	brne	.+4      	; 0x355c <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    3558:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    355c:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    355e:	2a 96       	adiw	r28, 0x0a	; 10
    3560:	0f b6       	in	r0, 0x3f	; 63
    3562:	f8 94       	cli
    3564:	de bf       	out	0x3e, r29	; 62
    3566:	0f be       	out	0x3f, r0	; 63
    3568:	cd bf       	out	0x3d, r28	; 61
    356a:	cf 91       	pop	r28
    356c:	df 91       	pop	r29
    356e:	08 95       	ret

00003570 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    3570:	df 93       	push	r29
    3572:	cf 93       	push	r28
    3574:	00 d0       	rcall	.+0      	; 0x3576 <vTaskDelay+0x6>
    3576:	0f 92       	push	r0
    3578:	cd b7       	in	r28, 0x3d	; 61
    357a:	de b7       	in	r29, 0x3e	; 62
    357c:	9b 83       	std	Y+3, r25	; 0x03
    357e:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    3580:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    3582:	8a 81       	ldd	r24, Y+2	; 0x02
    3584:	9b 81       	ldd	r25, Y+3	; 0x03
    3586:	00 97       	sbiw	r24, 0x00	; 0
    3588:	51 f0       	breq	.+20     	; 0x359e <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    358a:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    358e:	8a 81       	ldd	r24, Y+2	; 0x02
    3590:	9b 81       	ldd	r25, Y+3	; 0x03
    3592:	60 e0       	ldi	r22, 0x00	; 0
    3594:	0e 94 71 2b 	call	0x56e2	; 0x56e2 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    3598:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
    359c:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    359e:	89 81       	ldd	r24, Y+1	; 0x01
    35a0:	88 23       	and	r24, r24
    35a2:	11 f4       	brne	.+4      	; 0x35a8 <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    35a4:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    35a8:	0f 90       	pop	r0
    35aa:	0f 90       	pop	r0
    35ac:	0f 90       	pop	r0
    35ae:	cf 91       	pop	r28
    35b0:	df 91       	pop	r29
    35b2:	08 95       	ret

000035b4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    35b4:	ef 92       	push	r14
    35b6:	ff 92       	push	r15
    35b8:	0f 93       	push	r16
    35ba:	df 93       	push	r29
    35bc:	cf 93       	push	r28
    35be:	00 d0       	rcall	.+0      	; 0x35c0 <vTaskStartScheduler+0xc>
    35c0:	cd b7       	in	r28, 0x3d	; 61
    35c2:	de b7       	in	r29, 0x3e	; 62
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate( prvIdleTask,
    35c4:	86 ee       	ldi	r24, 0xE6	; 230
    35c6:	92 e2       	ldi	r25, 0x22	; 34
    35c8:	20 e6       	ldi	r18, 0x60	; 96
    35ca:	30 e0       	ldi	r19, 0x00	; 0
    35cc:	e3 e7       	ldi	r30, 0x73	; 115
    35ce:	f6 e0       	ldi	r31, 0x06	; 6
    35d0:	b9 01       	movw	r22, r18
    35d2:	45 e5       	ldi	r20, 0x55	; 85
    35d4:	50 e0       	ldi	r21, 0x00	; 0
    35d6:	20 e0       	ldi	r18, 0x00	; 0
    35d8:	30 e0       	ldi	r19, 0x00	; 0
    35da:	00 e0       	ldi	r16, 0x00	; 0
    35dc:	7f 01       	movw	r14, r30
    35de:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <xTaskCreate>
    35e2:	89 83       	std	Y+1, r24	; 0x01
    }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
    {
        if( xReturn == pdPASS )
    35e4:	89 81       	ldd	r24, Y+1	; 0x01
    35e6:	81 30       	cpi	r24, 0x01	; 1
    35e8:	19 f4       	brne	.+6      	; 0x35f0 <vTaskStartScheduler+0x3c>
        {
            xReturn = xTimerCreateTimerTask();
    35ea:	0e 94 d7 2b 	call	0x57ae	; 0x57ae <xTimerCreateTimerTask>
    35ee:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    35f0:	89 81       	ldd	r24, Y+1	; 0x01
    35f2:	81 30       	cpi	r24, 0x01	; 1
    35f4:	81 f4       	brne	.+32     	; 0x3616 <vTaskStartScheduler+0x62>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    35f6:	f8 94       	cli
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
    35f8:	8f ef       	ldi	r24, 0xFF	; 255
    35fa:	9f ef       	ldi	r25, 0xFF	; 255
    35fc:	90 93 72 06 	sts	0x0672, r25
    3600:	80 93 71 06 	sts	0x0671, r24
        xSchedulerRunning = pdTRUE;
    3604:	81 e0       	ldi	r24, 0x01	; 1
    3606:	80 93 6b 06 	sts	0x066B, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    360a:	10 92 69 06 	sts	0x0669, r1
    360e:	10 92 68 06 	sts	0x0668, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler();
    3612:	0e 94 4c 02 	call	0x498	; 0x498 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    3616:	80 91 82 00 	lds	r24, 0x0082
}
    361a:	0f 90       	pop	r0
    361c:	0f 90       	pop	r0
    361e:	cf 91       	pop	r28
    3620:	df 91       	pop	r29
    3622:	0f 91       	pop	r16
    3624:	ff 90       	pop	r15
    3626:	ef 90       	pop	r14
    3628:	08 95       	ret

0000362a <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    362a:	df 93       	push	r29
    362c:	cf 93       	push	r28
    362e:	cd b7       	in	r28, 0x3d	; 61
    3630:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    3632:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    3634:	10 92 6b 06 	sts	0x066B, r1
    vPortEndScheduler();
    3638:	0e 94 81 02 	call	0x502	; 0x502 <vPortEndScheduler>
}
    363c:	cf 91       	pop	r28
    363e:	df 91       	pop	r29
    3640:	08 95       	ret

00003642 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3642:	df 93       	push	r29
    3644:	cf 93       	push	r28
    3646:	cd b7       	in	r28, 0x3d	; 61
    3648:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    364a:	80 91 75 06 	lds	r24, 0x0675
    364e:	8f 5f       	subi	r24, 0xFF	; 255
    3650:	80 93 75 06 	sts	0x0675, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    3654:	cf 91       	pop	r28
    3656:	df 91       	pop	r29
    3658:	08 95       	ret

0000365a <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    365a:	df 93       	push	r29
    365c:	cf 93       	push	r28
    365e:	cd b7       	in	r28, 0x3d	; 61
    3660:	de b7       	in	r29, 0x3e	; 62
    3662:	2b 97       	sbiw	r28, 0x0b	; 11
    3664:	0f b6       	in	r0, 0x3f	; 63
    3666:	f8 94       	cli
    3668:	de bf       	out	0x3e, r29	; 62
    366a:	0f be       	out	0x3f, r0	; 63
    366c:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    366e:	1b 86       	std	Y+11, r1	; 0x0b
    3670:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    3672:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    3674:	0f b6       	in	r0, 0x3f	; 63
    3676:	f8 94       	cli
    3678:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    367a:	80 91 75 06 	lds	r24, 0x0675
    367e:	81 50       	subi	r24, 0x01	; 1
    3680:	80 93 75 06 	sts	0x0675, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3684:	80 91 75 06 	lds	r24, 0x0675
    3688:	88 23       	and	r24, r24
    368a:	09 f0       	breq	.+2      	; 0x368e <xTaskResumeAll+0x34>
    368c:	2a c1       	rjmp	.+596    	; 0x38e2 <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    368e:	80 91 67 06 	lds	r24, 0x0667
    3692:	88 23       	and	r24, r24
    3694:	09 f4       	brne	.+2      	; 0x3698 <xTaskResumeAll+0x3e>
    3696:	25 c1       	rjmp	.+586    	; 0x38e2 <xTaskResumeAll+0x288>
    3698:	f3 c0       	rjmp	.+486    	; 0x3880 <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    369a:	e0 91 b5 06 	lds	r30, 0x06B5
    369e:	f0 91 b6 06 	lds	r31, 0x06B6
    36a2:	86 81       	ldd	r24, Z+6	; 0x06
    36a4:	97 81       	ldd	r25, Z+7	; 0x07
    36a6:	9b 87       	std	Y+11, r25	; 0x0b
    36a8:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    36aa:	ea 85       	ldd	r30, Y+10	; 0x0a
    36ac:	fb 85       	ldd	r31, Y+11	; 0x0b
    36ae:	84 89       	ldd	r24, Z+20	; 0x14
    36b0:	95 89       	ldd	r25, Z+21	; 0x15
    36b2:	98 87       	std	Y+8, r25	; 0x08
    36b4:	8f 83       	std	Y+7, r24	; 0x07
    36b6:	ea 85       	ldd	r30, Y+10	; 0x0a
    36b8:	fb 85       	ldd	r31, Y+11	; 0x0b
    36ba:	a6 85       	ldd	r26, Z+14	; 0x0e
    36bc:	b7 85       	ldd	r27, Z+15	; 0x0f
    36be:	ea 85       	ldd	r30, Y+10	; 0x0a
    36c0:	fb 85       	ldd	r31, Y+11	; 0x0b
    36c2:	80 89       	ldd	r24, Z+16	; 0x10
    36c4:	91 89       	ldd	r25, Z+17	; 0x11
    36c6:	15 96       	adiw	r26, 0x05	; 5
    36c8:	9c 93       	st	X, r25
    36ca:	8e 93       	st	-X, r24
    36cc:	14 97       	sbiw	r26, 0x04	; 4
    36ce:	ea 85       	ldd	r30, Y+10	; 0x0a
    36d0:	fb 85       	ldd	r31, Y+11	; 0x0b
    36d2:	a0 89       	ldd	r26, Z+16	; 0x10
    36d4:	b1 89       	ldd	r27, Z+17	; 0x11
    36d6:	ea 85       	ldd	r30, Y+10	; 0x0a
    36d8:	fb 85       	ldd	r31, Y+11	; 0x0b
    36da:	86 85       	ldd	r24, Z+14	; 0x0e
    36dc:	97 85       	ldd	r25, Z+15	; 0x0f
    36de:	13 96       	adiw	r26, 0x03	; 3
    36e0:	9c 93       	st	X, r25
    36e2:	8e 93       	st	-X, r24
    36e4:	12 97       	sbiw	r26, 0x02	; 2
    36e6:	ef 81       	ldd	r30, Y+7	; 0x07
    36e8:	f8 85       	ldd	r31, Y+8	; 0x08
    36ea:	21 81       	ldd	r18, Z+1	; 0x01
    36ec:	32 81       	ldd	r19, Z+2	; 0x02
    36ee:	8a 85       	ldd	r24, Y+10	; 0x0a
    36f0:	9b 85       	ldd	r25, Y+11	; 0x0b
    36f2:	0c 96       	adiw	r24, 0x0c	; 12
    36f4:	28 17       	cp	r18, r24
    36f6:	39 07       	cpc	r19, r25
    36f8:	41 f4       	brne	.+16     	; 0x370a <xTaskResumeAll+0xb0>
    36fa:	ea 85       	ldd	r30, Y+10	; 0x0a
    36fc:	fb 85       	ldd	r31, Y+11	; 0x0b
    36fe:	80 89       	ldd	r24, Z+16	; 0x10
    3700:	91 89       	ldd	r25, Z+17	; 0x11
    3702:	ef 81       	ldd	r30, Y+7	; 0x07
    3704:	f8 85       	ldd	r31, Y+8	; 0x08
    3706:	92 83       	std	Z+2, r25	; 0x02
    3708:	81 83       	std	Z+1, r24	; 0x01
    370a:	ea 85       	ldd	r30, Y+10	; 0x0a
    370c:	fb 85       	ldd	r31, Y+11	; 0x0b
    370e:	15 8a       	std	Z+21, r1	; 0x15
    3710:	14 8a       	std	Z+20, r1	; 0x14
    3712:	ef 81       	ldd	r30, Y+7	; 0x07
    3714:	f8 85       	ldd	r31, Y+8	; 0x08
    3716:	80 81       	ld	r24, Z
    3718:	81 50       	subi	r24, 0x01	; 1
    371a:	ef 81       	ldd	r30, Y+7	; 0x07
    371c:	f8 85       	ldd	r31, Y+8	; 0x08
    371e:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3720:	ea 85       	ldd	r30, Y+10	; 0x0a
    3722:	fb 85       	ldd	r31, Y+11	; 0x0b
    3724:	82 85       	ldd	r24, Z+10	; 0x0a
    3726:	93 85       	ldd	r25, Z+11	; 0x0b
    3728:	9e 83       	std	Y+6, r25	; 0x06
    372a:	8d 83       	std	Y+5, r24	; 0x05
    372c:	ea 85       	ldd	r30, Y+10	; 0x0a
    372e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3730:	a4 81       	ldd	r26, Z+4	; 0x04
    3732:	b5 81       	ldd	r27, Z+5	; 0x05
    3734:	ea 85       	ldd	r30, Y+10	; 0x0a
    3736:	fb 85       	ldd	r31, Y+11	; 0x0b
    3738:	86 81       	ldd	r24, Z+6	; 0x06
    373a:	97 81       	ldd	r25, Z+7	; 0x07
    373c:	15 96       	adiw	r26, 0x05	; 5
    373e:	9c 93       	st	X, r25
    3740:	8e 93       	st	-X, r24
    3742:	14 97       	sbiw	r26, 0x04	; 4
    3744:	ea 85       	ldd	r30, Y+10	; 0x0a
    3746:	fb 85       	ldd	r31, Y+11	; 0x0b
    3748:	a6 81       	ldd	r26, Z+6	; 0x06
    374a:	b7 81       	ldd	r27, Z+7	; 0x07
    374c:	ea 85       	ldd	r30, Y+10	; 0x0a
    374e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3750:	84 81       	ldd	r24, Z+4	; 0x04
    3752:	95 81       	ldd	r25, Z+5	; 0x05
    3754:	13 96       	adiw	r26, 0x03	; 3
    3756:	9c 93       	st	X, r25
    3758:	8e 93       	st	-X, r24
    375a:	12 97       	sbiw	r26, 0x02	; 2
    375c:	ed 81       	ldd	r30, Y+5	; 0x05
    375e:	fe 81       	ldd	r31, Y+6	; 0x06
    3760:	21 81       	ldd	r18, Z+1	; 0x01
    3762:	32 81       	ldd	r19, Z+2	; 0x02
    3764:	8a 85       	ldd	r24, Y+10	; 0x0a
    3766:	9b 85       	ldd	r25, Y+11	; 0x0b
    3768:	02 96       	adiw	r24, 0x02	; 2
    376a:	28 17       	cp	r18, r24
    376c:	39 07       	cpc	r19, r25
    376e:	41 f4       	brne	.+16     	; 0x3780 <xTaskResumeAll+0x126>
    3770:	ea 85       	ldd	r30, Y+10	; 0x0a
    3772:	fb 85       	ldd	r31, Y+11	; 0x0b
    3774:	86 81       	ldd	r24, Z+6	; 0x06
    3776:	97 81       	ldd	r25, Z+7	; 0x07
    3778:	ed 81       	ldd	r30, Y+5	; 0x05
    377a:	fe 81       	ldd	r31, Y+6	; 0x06
    377c:	92 83       	std	Z+2, r25	; 0x02
    377e:	81 83       	std	Z+1, r24	; 0x01
    3780:	ea 85       	ldd	r30, Y+10	; 0x0a
    3782:	fb 85       	ldd	r31, Y+11	; 0x0b
    3784:	13 86       	std	Z+11, r1	; 0x0b
    3786:	12 86       	std	Z+10, r1	; 0x0a
    3788:	ed 81       	ldd	r30, Y+5	; 0x05
    378a:	fe 81       	ldd	r31, Y+6	; 0x06
    378c:	80 81       	ld	r24, Z
    378e:	81 50       	subi	r24, 0x01	; 1
    3790:	ed 81       	ldd	r30, Y+5	; 0x05
    3792:	fe 81       	ldd	r31, Y+6	; 0x06
    3794:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    3796:	ea 85       	ldd	r30, Y+10	; 0x0a
    3798:	fb 85       	ldd	r31, Y+11	; 0x0b
    379a:	96 89       	ldd	r25, Z+22	; 0x16
    379c:	80 91 6a 06 	lds	r24, 0x066A
    37a0:	89 17       	cp	r24, r25
    37a2:	28 f4       	brcc	.+10     	; 0x37ae <xTaskResumeAll+0x154>
    37a4:	ea 85       	ldd	r30, Y+10	; 0x0a
    37a6:	fb 85       	ldd	r31, Y+11	; 0x0b
    37a8:	86 89       	ldd	r24, Z+22	; 0x16
    37aa:	80 93 6a 06 	sts	0x066A, r24
    37ae:	ea 85       	ldd	r30, Y+10	; 0x0a
    37b0:	fb 85       	ldd	r31, Y+11	; 0x0b
    37b2:	86 89       	ldd	r24, Z+22	; 0x16
    37b4:	28 2f       	mov	r18, r24
    37b6:	30 e0       	ldi	r19, 0x00	; 0
    37b8:	c9 01       	movw	r24, r18
    37ba:	88 0f       	add	r24, r24
    37bc:	99 1f       	adc	r25, r25
    37be:	88 0f       	add	r24, r24
    37c0:	99 1f       	adc	r25, r25
    37c2:	88 0f       	add	r24, r24
    37c4:	99 1f       	adc	r25, r25
    37c6:	82 0f       	add	r24, r18
    37c8:	93 1f       	adc	r25, r19
    37ca:	fc 01       	movw	r30, r24
    37cc:	ea 58       	subi	r30, 0x8A	; 138
    37ce:	f9 4f       	sbci	r31, 0xF9	; 249
    37d0:	81 81       	ldd	r24, Z+1	; 0x01
    37d2:	92 81       	ldd	r25, Z+2	; 0x02
    37d4:	9c 83       	std	Y+4, r25	; 0x04
    37d6:	8b 83       	std	Y+3, r24	; 0x03
    37d8:	ea 85       	ldd	r30, Y+10	; 0x0a
    37da:	fb 85       	ldd	r31, Y+11	; 0x0b
    37dc:	8b 81       	ldd	r24, Y+3	; 0x03
    37de:	9c 81       	ldd	r25, Y+4	; 0x04
    37e0:	95 83       	std	Z+5, r25	; 0x05
    37e2:	84 83       	std	Z+4, r24	; 0x04
    37e4:	eb 81       	ldd	r30, Y+3	; 0x03
    37e6:	fc 81       	ldd	r31, Y+4	; 0x04
    37e8:	84 81       	ldd	r24, Z+4	; 0x04
    37ea:	95 81       	ldd	r25, Z+5	; 0x05
    37ec:	ea 85       	ldd	r30, Y+10	; 0x0a
    37ee:	fb 85       	ldd	r31, Y+11	; 0x0b
    37f0:	97 83       	std	Z+7, r25	; 0x07
    37f2:	86 83       	std	Z+6, r24	; 0x06
    37f4:	eb 81       	ldd	r30, Y+3	; 0x03
    37f6:	fc 81       	ldd	r31, Y+4	; 0x04
    37f8:	04 80       	ldd	r0, Z+4	; 0x04
    37fa:	f5 81       	ldd	r31, Z+5	; 0x05
    37fc:	e0 2d       	mov	r30, r0
    37fe:	8a 85       	ldd	r24, Y+10	; 0x0a
    3800:	9b 85       	ldd	r25, Y+11	; 0x0b
    3802:	02 96       	adiw	r24, 0x02	; 2
    3804:	93 83       	std	Z+3, r25	; 0x03
    3806:	82 83       	std	Z+2, r24	; 0x02
    3808:	8a 85       	ldd	r24, Y+10	; 0x0a
    380a:	9b 85       	ldd	r25, Y+11	; 0x0b
    380c:	02 96       	adiw	r24, 0x02	; 2
    380e:	eb 81       	ldd	r30, Y+3	; 0x03
    3810:	fc 81       	ldd	r31, Y+4	; 0x04
    3812:	95 83       	std	Z+5, r25	; 0x05
    3814:	84 83       	std	Z+4, r24	; 0x04
    3816:	ea 85       	ldd	r30, Y+10	; 0x0a
    3818:	fb 85       	ldd	r31, Y+11	; 0x0b
    381a:	86 89       	ldd	r24, Z+22	; 0x16
    381c:	28 2f       	mov	r18, r24
    381e:	30 e0       	ldi	r19, 0x00	; 0
    3820:	c9 01       	movw	r24, r18
    3822:	88 0f       	add	r24, r24
    3824:	99 1f       	adc	r25, r25
    3826:	88 0f       	add	r24, r24
    3828:	99 1f       	adc	r25, r25
    382a:	88 0f       	add	r24, r24
    382c:	99 1f       	adc	r25, r25
    382e:	82 0f       	add	r24, r18
    3830:	93 1f       	adc	r25, r19
    3832:	8a 58       	subi	r24, 0x8A	; 138
    3834:	99 4f       	sbci	r25, 0xF9	; 249
    3836:	ea 85       	ldd	r30, Y+10	; 0x0a
    3838:	fb 85       	ldd	r31, Y+11	; 0x0b
    383a:	93 87       	std	Z+11, r25	; 0x0b
    383c:	82 87       	std	Z+10, r24	; 0x0a
    383e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3840:	fb 85       	ldd	r31, Y+11	; 0x0b
    3842:	86 89       	ldd	r24, Z+22	; 0x16
    3844:	28 2f       	mov	r18, r24
    3846:	30 e0       	ldi	r19, 0x00	; 0
    3848:	c9 01       	movw	r24, r18
    384a:	88 0f       	add	r24, r24
    384c:	99 1f       	adc	r25, r25
    384e:	88 0f       	add	r24, r24
    3850:	99 1f       	adc	r25, r25
    3852:	88 0f       	add	r24, r24
    3854:	99 1f       	adc	r25, r25
    3856:	82 0f       	add	r24, r18
    3858:	93 1f       	adc	r25, r19
    385a:	fc 01       	movw	r30, r24
    385c:	ea 58       	subi	r30, 0x8A	; 138
    385e:	f9 4f       	sbci	r31, 0xF9	; 249
    3860:	80 81       	ld	r24, Z
    3862:	8f 5f       	subi	r24, 0xFF	; 255
    3864:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3866:	ea 85       	ldd	r30, Y+10	; 0x0a
    3868:	fb 85       	ldd	r31, Y+11	; 0x0b
    386a:	96 89       	ldd	r25, Z+22	; 0x16
    386c:	e0 91 64 06 	lds	r30, 0x0664
    3870:	f0 91 65 06 	lds	r31, 0x0665
    3874:	86 89       	ldd	r24, Z+22	; 0x16
    3876:	98 17       	cp	r25, r24
    3878:	18 f0       	brcs	.+6      	; 0x3880 <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    387a:	81 e0       	ldi	r24, 0x01	; 1
    387c:	80 93 6e 06 	sts	0x066E, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3880:	80 91 b0 06 	lds	r24, 0x06B0
    3884:	88 23       	and	r24, r24
    3886:	09 f0       	breq	.+2      	; 0x388a <xTaskResumeAll+0x230>
    3888:	08 cf       	rjmp	.-496    	; 0x369a <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    388a:	8a 85       	ldd	r24, Y+10	; 0x0a
    388c:	9b 85       	ldd	r25, Y+11	; 0x0b
    388e:	00 97       	sbiw	r24, 0x00	; 0
    3890:	11 f0       	breq	.+4      	; 0x3896 <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    3892:	0e 94 78 23 	call	0x46f0	; 0x46f0 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3896:	80 91 6c 06 	lds	r24, 0x066C
    389a:	90 91 6d 06 	lds	r25, 0x066D
    389e:	9a 83       	std	Y+2, r25	; 0x02
    38a0:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    38a2:	89 81       	ldd	r24, Y+1	; 0x01
    38a4:	9a 81       	ldd	r25, Y+2	; 0x02
    38a6:	00 97       	sbiw	r24, 0x00	; 0
    38a8:	a1 f0       	breq	.+40     	; 0x38d2 <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    38aa:	0e 94 ff 1c 	call	0x39fe	; 0x39fe <xTaskIncrementTick>
    38ae:	88 23       	and	r24, r24
    38b0:	19 f0       	breq	.+6      	; 0x38b8 <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    38b2:	81 e0       	ldi	r24, 0x01	; 1
    38b4:	80 93 6e 06 	sts	0x066E, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    38b8:	89 81       	ldd	r24, Y+1	; 0x01
    38ba:	9a 81       	ldd	r25, Y+2	; 0x02
    38bc:	01 97       	sbiw	r24, 0x01	; 1
    38be:	9a 83       	std	Y+2, r25	; 0x02
    38c0:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    38c2:	89 81       	ldd	r24, Y+1	; 0x01
    38c4:	9a 81       	ldd	r25, Y+2	; 0x02
    38c6:	00 97       	sbiw	r24, 0x00	; 0
    38c8:	81 f7       	brne	.-32     	; 0x38aa <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    38ca:	10 92 6d 06 	sts	0x066D, r1
    38ce:	10 92 6c 06 	sts	0x066C, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    38d2:	80 91 6e 06 	lds	r24, 0x066E
    38d6:	88 23       	and	r24, r24
    38d8:	21 f0       	breq	.+8      	; 0x38e2 <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                    {
                        xAlreadyYielded = pdTRUE;
    38da:	81 e0       	ldi	r24, 0x01	; 1
    38dc:	89 87       	std	Y+9, r24	; 0x09
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    38de:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    38e2:	0f 90       	pop	r0
    38e4:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    38e6:	89 85       	ldd	r24, Y+9	; 0x09
}
    38e8:	2b 96       	adiw	r28, 0x0b	; 11
    38ea:	0f b6       	in	r0, 0x3f	; 63
    38ec:	f8 94       	cli
    38ee:	de bf       	out	0x3e, r29	; 62
    38f0:	0f be       	out	0x3f, r0	; 63
    38f2:	cd bf       	out	0x3d, r28	; 61
    38f4:	cf 91       	pop	r28
    38f6:	df 91       	pop	r29
    38f8:	08 95       	ret

000038fa <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    38fa:	df 93       	push	r29
    38fc:	cf 93       	push	r28
    38fe:	00 d0       	rcall	.+0      	; 0x3900 <xTaskGetTickCount+0x6>
    3900:	cd b7       	in	r28, 0x3d	; 61
    3902:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    3904:	0f b6       	in	r0, 0x3f	; 63
    3906:	f8 94       	cli
    3908:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    390a:	80 91 68 06 	lds	r24, 0x0668
    390e:	90 91 69 06 	lds	r25, 0x0669
    3912:	9a 83       	std	Y+2, r25	; 0x02
    3914:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    3916:	0f 90       	pop	r0
    3918:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    391a:	89 81       	ldd	r24, Y+1	; 0x01
    391c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    391e:	0f 90       	pop	r0
    3920:	0f 90       	pop	r0
    3922:	cf 91       	pop	r28
    3924:	df 91       	pop	r29
    3926:	08 95       	ret

00003928 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3928:	df 93       	push	r29
    392a:	cf 93       	push	r28
    392c:	00 d0       	rcall	.+0      	; 0x392e <xTaskGetTickCountFromISR+0x6>
    392e:	0f 92       	push	r0
    3930:	cd b7       	in	r28, 0x3d	; 61
    3932:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    3934:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    3936:	80 91 68 06 	lds	r24, 0x0668
    393a:	90 91 69 06 	lds	r25, 0x0669
    393e:	9b 83       	std	Y+3, r25	; 0x03
    3940:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3942:	8a 81       	ldd	r24, Y+2	; 0x02
    3944:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3946:	0f 90       	pop	r0
    3948:	0f 90       	pop	r0
    394a:	0f 90       	pop	r0
    394c:	cf 91       	pop	r28
    394e:	df 91       	pop	r29
    3950:	08 95       	ret

00003952 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3952:	df 93       	push	r29
    3954:	cf 93       	push	r28
    3956:	cd b7       	in	r28, 0x3d	; 61
    3958:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    395a:	80 91 67 06 	lds	r24, 0x0667
}
    395e:	cf 91       	pop	r28
    3960:	df 91       	pop	r29
    3962:	08 95       	ret

00003964 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3964:	df 93       	push	r29
    3966:	cf 93       	push	r28
    3968:	00 d0       	rcall	.+0      	; 0x396a <pcTaskGetName+0x6>
    396a:	00 d0       	rcall	.+0      	; 0x396c <pcTaskGetName+0x8>
    396c:	00 d0       	rcall	.+0      	; 0x396e <pcTaskGetName+0xa>
    396e:	cd b7       	in	r28, 0x3d	; 61
    3970:	de b7       	in	r29, 0x3e	; 62
    3972:	9c 83       	std	Y+4, r25	; 0x04
    3974:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    3976:	8b 81       	ldd	r24, Y+3	; 0x03
    3978:	9c 81       	ldd	r25, Y+4	; 0x04
    397a:	00 97       	sbiw	r24, 0x00	; 0
    397c:	39 f4       	brne	.+14     	; 0x398c <pcTaskGetName+0x28>
    397e:	80 91 64 06 	lds	r24, 0x0664
    3982:	90 91 65 06 	lds	r25, 0x0665
    3986:	9e 83       	std	Y+6, r25	; 0x06
    3988:	8d 83       	std	Y+5, r24	; 0x05
    398a:	04 c0       	rjmp	.+8      	; 0x3994 <pcTaskGetName+0x30>
    398c:	8b 81       	ldd	r24, Y+3	; 0x03
    398e:	9c 81       	ldd	r25, Y+4	; 0x04
    3990:	9e 83       	std	Y+6, r25	; 0x06
    3992:	8d 83       	std	Y+5, r24	; 0x05
    3994:	8d 81       	ldd	r24, Y+5	; 0x05
    3996:	9e 81       	ldd	r25, Y+6	; 0x06
    3998:	9a 83       	std	Y+2, r25	; 0x02
    399a:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    399c:	89 81       	ldd	r24, Y+1	; 0x01
    399e:	9a 81       	ldd	r25, Y+2	; 0x02
    39a0:	49 96       	adiw	r24, 0x19	; 25
}
    39a2:	26 96       	adiw	r28, 0x06	; 6
    39a4:	0f b6       	in	r0, 0x3f	; 63
    39a6:	f8 94       	cli
    39a8:	de bf       	out	0x3e, r29	; 62
    39aa:	0f be       	out	0x3f, r0	; 63
    39ac:	cd bf       	out	0x3d, r28	; 61
    39ae:	cf 91       	pop	r28
    39b0:	df 91       	pop	r29
    39b2:	08 95       	ret

000039b4 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    39b4:	df 93       	push	r29
    39b6:	cf 93       	push	r28
    39b8:	00 d0       	rcall	.+0      	; 0x39ba <xTaskCatchUpTicks+0x6>
    39ba:	0f 92       	push	r0
    39bc:	cd b7       	in	r28, 0x3d	; 61
    39be:	de b7       	in	r29, 0x3e	; 62
    39c0:	9b 83       	std	Y+3, r25	; 0x03
    39c2:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    39c4:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskSuspendAll>

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
    39c8:	0f b6       	in	r0, 0x3f	; 63
    39ca:	f8 94       	cli
    39cc:	0f 92       	push	r0
    {
        xPendedTicks += xTicksToCatchUp;
    39ce:	20 91 6c 06 	lds	r18, 0x066C
    39d2:	30 91 6d 06 	lds	r19, 0x066D
    39d6:	8a 81       	ldd	r24, Y+2	; 0x02
    39d8:	9b 81       	ldd	r25, Y+3	; 0x03
    39da:	82 0f       	add	r24, r18
    39dc:	93 1f       	adc	r25, r19
    39de:	90 93 6d 06 	sts	0x066D, r25
    39e2:	80 93 6c 06 	sts	0x066C, r24
    }
    taskEXIT_CRITICAL();
    39e6:	0f 90       	pop	r0
    39e8:	0f be       	out	0x3f, r0	; 63
    xYieldOccurred = xTaskResumeAll();
    39ea:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
    39ee:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    39f0:	89 81       	ldd	r24, Y+1	; 0x01
}
    39f2:	0f 90       	pop	r0
    39f4:	0f 90       	pop	r0
    39f6:	0f 90       	pop	r0
    39f8:	cf 91       	pop	r28
    39fa:	df 91       	pop	r29
    39fc:	08 95       	ret

000039fe <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    39fe:	df 93       	push	r29
    3a00:	cf 93       	push	r28
    3a02:	cd b7       	in	r28, 0x3d	; 61
    3a04:	de b7       	in	r29, 0x3e	; 62
    3a06:	2f 97       	sbiw	r28, 0x0f	; 15
    3a08:	0f b6       	in	r0, 0x3f	; 63
    3a0a:	f8 94       	cli
    3a0c:	de bf       	out	0x3e, r29	; 62
    3a0e:	0f be       	out	0x3f, r0	; 63
    3a10:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    3a12:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3a14:	80 91 75 06 	lds	r24, 0x0675
    3a18:	88 23       	and	r24, r24
    3a1a:	09 f0       	breq	.+2      	; 0x3a1e <xTaskIncrementTick+0x20>
    3a1c:	74 c1       	rjmp	.+744    	; 0x3d06 <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    3a1e:	80 91 68 06 	lds	r24, 0x0668
    3a22:	90 91 69 06 	lds	r25, 0x0669
    3a26:	01 96       	adiw	r24, 0x01	; 1
    3a28:	9a 87       	std	Y+10, r25	; 0x0a
    3a2a:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    3a2c:	89 85       	ldd	r24, Y+9	; 0x09
    3a2e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3a30:	90 93 69 06 	sts	0x0669, r25
    3a34:	80 93 68 06 	sts	0x0668, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    3a38:	89 85       	ldd	r24, Y+9	; 0x09
    3a3a:	9a 85       	ldd	r25, Y+10	; 0x0a
    3a3c:	00 97       	sbiw	r24, 0x00	; 0
    3a3e:	d9 f4       	brne	.+54     	; 0x3a76 <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    3a40:	80 91 ac 06 	lds	r24, 0x06AC
    3a44:	90 91 ad 06 	lds	r25, 0x06AD
    3a48:	98 87       	std	Y+8, r25	; 0x08
    3a4a:	8f 83       	std	Y+7, r24	; 0x07
    3a4c:	80 91 ae 06 	lds	r24, 0x06AE
    3a50:	90 91 af 06 	lds	r25, 0x06AF
    3a54:	90 93 ad 06 	sts	0x06AD, r25
    3a58:	80 93 ac 06 	sts	0x06AC, r24
    3a5c:	8f 81       	ldd	r24, Y+7	; 0x07
    3a5e:	98 85       	ldd	r25, Y+8	; 0x08
    3a60:	90 93 af 06 	sts	0x06AF, r25
    3a64:	80 93 ae 06 	sts	0x06AE, r24
    3a68:	80 91 6f 06 	lds	r24, 0x066F
    3a6c:	8f 5f       	subi	r24, 0xFF	; 255
    3a6e:	80 93 6f 06 	sts	0x066F, r24
    3a72:	0e 94 78 23 	call	0x46f0	; 0x46f0 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    3a76:	20 91 71 06 	lds	r18, 0x0671
    3a7a:	30 91 72 06 	lds	r19, 0x0672
    3a7e:	89 85       	ldd	r24, Y+9	; 0x09
    3a80:	9a 85       	ldd	r25, Y+10	; 0x0a
    3a82:	82 17       	cp	r24, r18
    3a84:	93 07       	cpc	r25, r19
    3a86:	08 f4       	brcc	.+2      	; 0x3a8a <xTaskIncrementTick+0x8c>
    3a88:	1f c1       	rjmp	.+574    	; 0x3cc8 <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3a8a:	e0 91 ac 06 	lds	r30, 0x06AC
    3a8e:	f0 91 ad 06 	lds	r31, 0x06AD
    3a92:	80 81       	ld	r24, Z
    3a94:	88 23       	and	r24, r24
    3a96:	39 f4       	brne	.+14     	; 0x3aa6 <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3a98:	8f ef       	ldi	r24, 0xFF	; 255
    3a9a:	9f ef       	ldi	r25, 0xFF	; 255
    3a9c:	90 93 72 06 	sts	0x0672, r25
    3aa0:	80 93 71 06 	sts	0x0671, r24
    3aa4:	11 c1       	rjmp	.+546    	; 0x3cc8 <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3aa6:	e0 91 ac 06 	lds	r30, 0x06AC
    3aaa:	f0 91 ad 06 	lds	r31, 0x06AD
    3aae:	05 80       	ldd	r0, Z+5	; 0x05
    3ab0:	f6 81       	ldd	r31, Z+6	; 0x06
    3ab2:	e0 2d       	mov	r30, r0
    3ab4:	86 81       	ldd	r24, Z+6	; 0x06
    3ab6:	97 81       	ldd	r25, Z+7	; 0x07
    3ab8:	9f 87       	std	Y+15, r25	; 0x0f
    3aba:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    3abc:	ee 85       	ldd	r30, Y+14	; 0x0e
    3abe:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ac0:	82 81       	ldd	r24, Z+2	; 0x02
    3ac2:	93 81       	ldd	r25, Z+3	; 0x03
    3ac4:	9d 87       	std	Y+13, r25	; 0x0d
    3ac6:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    3ac8:	29 85       	ldd	r18, Y+9	; 0x09
    3aca:	3a 85       	ldd	r19, Y+10	; 0x0a
    3acc:	8c 85       	ldd	r24, Y+12	; 0x0c
    3ace:	9d 85       	ldd	r25, Y+13	; 0x0d
    3ad0:	28 17       	cp	r18, r24
    3ad2:	39 07       	cpc	r19, r25
    3ad4:	38 f4       	brcc	.+14     	; 0x3ae4 <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    3ad6:	8c 85       	ldd	r24, Y+12	; 0x0c
    3ad8:	9d 85       	ldd	r25, Y+13	; 0x0d
    3ada:	90 93 72 06 	sts	0x0672, r25
    3ade:	80 93 71 06 	sts	0x0671, r24
    3ae2:	f2 c0       	rjmp	.+484    	; 0x3cc8 <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3ae4:	ee 85       	ldd	r30, Y+14	; 0x0e
    3ae6:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ae8:	82 85       	ldd	r24, Z+10	; 0x0a
    3aea:	93 85       	ldd	r25, Z+11	; 0x0b
    3aec:	9e 83       	std	Y+6, r25	; 0x06
    3aee:	8d 83       	std	Y+5, r24	; 0x05
    3af0:	ee 85       	ldd	r30, Y+14	; 0x0e
    3af2:	ff 85       	ldd	r31, Y+15	; 0x0f
    3af4:	a4 81       	ldd	r26, Z+4	; 0x04
    3af6:	b5 81       	ldd	r27, Z+5	; 0x05
    3af8:	ee 85       	ldd	r30, Y+14	; 0x0e
    3afa:	ff 85       	ldd	r31, Y+15	; 0x0f
    3afc:	86 81       	ldd	r24, Z+6	; 0x06
    3afe:	97 81       	ldd	r25, Z+7	; 0x07
    3b00:	15 96       	adiw	r26, 0x05	; 5
    3b02:	9c 93       	st	X, r25
    3b04:	8e 93       	st	-X, r24
    3b06:	14 97       	sbiw	r26, 0x04	; 4
    3b08:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b0a:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b0c:	a6 81       	ldd	r26, Z+6	; 0x06
    3b0e:	b7 81       	ldd	r27, Z+7	; 0x07
    3b10:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b12:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b14:	84 81       	ldd	r24, Z+4	; 0x04
    3b16:	95 81       	ldd	r25, Z+5	; 0x05
    3b18:	13 96       	adiw	r26, 0x03	; 3
    3b1a:	9c 93       	st	X, r25
    3b1c:	8e 93       	st	-X, r24
    3b1e:	12 97       	sbiw	r26, 0x02	; 2
    3b20:	ed 81       	ldd	r30, Y+5	; 0x05
    3b22:	fe 81       	ldd	r31, Y+6	; 0x06
    3b24:	21 81       	ldd	r18, Z+1	; 0x01
    3b26:	32 81       	ldd	r19, Z+2	; 0x02
    3b28:	8e 85       	ldd	r24, Y+14	; 0x0e
    3b2a:	9f 85       	ldd	r25, Y+15	; 0x0f
    3b2c:	02 96       	adiw	r24, 0x02	; 2
    3b2e:	28 17       	cp	r18, r24
    3b30:	39 07       	cpc	r19, r25
    3b32:	41 f4       	brne	.+16     	; 0x3b44 <xTaskIncrementTick+0x146>
    3b34:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b36:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b38:	86 81       	ldd	r24, Z+6	; 0x06
    3b3a:	97 81       	ldd	r25, Z+7	; 0x07
    3b3c:	ed 81       	ldd	r30, Y+5	; 0x05
    3b3e:	fe 81       	ldd	r31, Y+6	; 0x06
    3b40:	92 83       	std	Z+2, r25	; 0x02
    3b42:	81 83       	std	Z+1, r24	; 0x01
    3b44:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b46:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b48:	13 86       	std	Z+11, r1	; 0x0b
    3b4a:	12 86       	std	Z+10, r1	; 0x0a
    3b4c:	ed 81       	ldd	r30, Y+5	; 0x05
    3b4e:	fe 81       	ldd	r31, Y+6	; 0x06
    3b50:	80 81       	ld	r24, Z
    3b52:	81 50       	subi	r24, 0x01	; 1
    3b54:	ed 81       	ldd	r30, Y+5	; 0x05
    3b56:	fe 81       	ldd	r31, Y+6	; 0x06
    3b58:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3b5a:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b5c:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b5e:	84 89       	ldd	r24, Z+20	; 0x14
    3b60:	95 89       	ldd	r25, Z+21	; 0x15
    3b62:	00 97       	sbiw	r24, 0x00	; 0
    3b64:	d9 f1       	breq	.+118    	; 0x3bdc <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3b66:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b68:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b6a:	84 89       	ldd	r24, Z+20	; 0x14
    3b6c:	95 89       	ldd	r25, Z+21	; 0x15
    3b6e:	9c 83       	std	Y+4, r25	; 0x04
    3b70:	8b 83       	std	Y+3, r24	; 0x03
    3b72:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b74:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b76:	a6 85       	ldd	r26, Z+14	; 0x0e
    3b78:	b7 85       	ldd	r27, Z+15	; 0x0f
    3b7a:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b7c:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b7e:	80 89       	ldd	r24, Z+16	; 0x10
    3b80:	91 89       	ldd	r25, Z+17	; 0x11
    3b82:	15 96       	adiw	r26, 0x05	; 5
    3b84:	9c 93       	st	X, r25
    3b86:	8e 93       	st	-X, r24
    3b88:	14 97       	sbiw	r26, 0x04	; 4
    3b8a:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b8c:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b8e:	a0 89       	ldd	r26, Z+16	; 0x10
    3b90:	b1 89       	ldd	r27, Z+17	; 0x11
    3b92:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b94:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b96:	86 85       	ldd	r24, Z+14	; 0x0e
    3b98:	97 85       	ldd	r25, Z+15	; 0x0f
    3b9a:	13 96       	adiw	r26, 0x03	; 3
    3b9c:	9c 93       	st	X, r25
    3b9e:	8e 93       	st	-X, r24
    3ba0:	12 97       	sbiw	r26, 0x02	; 2
    3ba2:	eb 81       	ldd	r30, Y+3	; 0x03
    3ba4:	fc 81       	ldd	r31, Y+4	; 0x04
    3ba6:	21 81       	ldd	r18, Z+1	; 0x01
    3ba8:	32 81       	ldd	r19, Z+2	; 0x02
    3baa:	8e 85       	ldd	r24, Y+14	; 0x0e
    3bac:	9f 85       	ldd	r25, Y+15	; 0x0f
    3bae:	0c 96       	adiw	r24, 0x0c	; 12
    3bb0:	28 17       	cp	r18, r24
    3bb2:	39 07       	cpc	r19, r25
    3bb4:	41 f4       	brne	.+16     	; 0x3bc6 <xTaskIncrementTick+0x1c8>
    3bb6:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bb8:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bba:	80 89       	ldd	r24, Z+16	; 0x10
    3bbc:	91 89       	ldd	r25, Z+17	; 0x11
    3bbe:	eb 81       	ldd	r30, Y+3	; 0x03
    3bc0:	fc 81       	ldd	r31, Y+4	; 0x04
    3bc2:	92 83       	std	Z+2, r25	; 0x02
    3bc4:	81 83       	std	Z+1, r24	; 0x01
    3bc6:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bc8:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bca:	15 8a       	std	Z+21, r1	; 0x15
    3bcc:	14 8a       	std	Z+20, r1	; 0x14
    3bce:	eb 81       	ldd	r30, Y+3	; 0x03
    3bd0:	fc 81       	ldd	r31, Y+4	; 0x04
    3bd2:	80 81       	ld	r24, Z
    3bd4:	81 50       	subi	r24, 0x01	; 1
    3bd6:	eb 81       	ldd	r30, Y+3	; 0x03
    3bd8:	fc 81       	ldd	r31, Y+4	; 0x04
    3bda:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    3bdc:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bde:	ff 85       	ldd	r31, Y+15	; 0x0f
    3be0:	96 89       	ldd	r25, Z+22	; 0x16
    3be2:	80 91 6a 06 	lds	r24, 0x066A
    3be6:	89 17       	cp	r24, r25
    3be8:	28 f4       	brcc	.+10     	; 0x3bf4 <xTaskIncrementTick+0x1f6>
    3bea:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bec:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bee:	86 89       	ldd	r24, Z+22	; 0x16
    3bf0:	80 93 6a 06 	sts	0x066A, r24
    3bf4:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bf6:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bf8:	86 89       	ldd	r24, Z+22	; 0x16
    3bfa:	28 2f       	mov	r18, r24
    3bfc:	30 e0       	ldi	r19, 0x00	; 0
    3bfe:	c9 01       	movw	r24, r18
    3c00:	88 0f       	add	r24, r24
    3c02:	99 1f       	adc	r25, r25
    3c04:	88 0f       	add	r24, r24
    3c06:	99 1f       	adc	r25, r25
    3c08:	88 0f       	add	r24, r24
    3c0a:	99 1f       	adc	r25, r25
    3c0c:	82 0f       	add	r24, r18
    3c0e:	93 1f       	adc	r25, r19
    3c10:	fc 01       	movw	r30, r24
    3c12:	ea 58       	subi	r30, 0x8A	; 138
    3c14:	f9 4f       	sbci	r31, 0xF9	; 249
    3c16:	81 81       	ldd	r24, Z+1	; 0x01
    3c18:	92 81       	ldd	r25, Z+2	; 0x02
    3c1a:	9a 83       	std	Y+2, r25	; 0x02
    3c1c:	89 83       	std	Y+1, r24	; 0x01
    3c1e:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c20:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c22:	89 81       	ldd	r24, Y+1	; 0x01
    3c24:	9a 81       	ldd	r25, Y+2	; 0x02
    3c26:	95 83       	std	Z+5, r25	; 0x05
    3c28:	84 83       	std	Z+4, r24	; 0x04
    3c2a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c2c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c2e:	84 81       	ldd	r24, Z+4	; 0x04
    3c30:	95 81       	ldd	r25, Z+5	; 0x05
    3c32:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c34:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c36:	97 83       	std	Z+7, r25	; 0x07
    3c38:	86 83       	std	Z+6, r24	; 0x06
    3c3a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c3c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c3e:	04 80       	ldd	r0, Z+4	; 0x04
    3c40:	f5 81       	ldd	r31, Z+5	; 0x05
    3c42:	e0 2d       	mov	r30, r0
    3c44:	8e 85       	ldd	r24, Y+14	; 0x0e
    3c46:	9f 85       	ldd	r25, Y+15	; 0x0f
    3c48:	02 96       	adiw	r24, 0x02	; 2
    3c4a:	93 83       	std	Z+3, r25	; 0x03
    3c4c:	82 83       	std	Z+2, r24	; 0x02
    3c4e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3c50:	9f 85       	ldd	r25, Y+15	; 0x0f
    3c52:	02 96       	adiw	r24, 0x02	; 2
    3c54:	e9 81       	ldd	r30, Y+1	; 0x01
    3c56:	fa 81       	ldd	r31, Y+2	; 0x02
    3c58:	95 83       	std	Z+5, r25	; 0x05
    3c5a:	84 83       	std	Z+4, r24	; 0x04
    3c5c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c5e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c60:	86 89       	ldd	r24, Z+22	; 0x16
    3c62:	28 2f       	mov	r18, r24
    3c64:	30 e0       	ldi	r19, 0x00	; 0
    3c66:	c9 01       	movw	r24, r18
    3c68:	88 0f       	add	r24, r24
    3c6a:	99 1f       	adc	r25, r25
    3c6c:	88 0f       	add	r24, r24
    3c6e:	99 1f       	adc	r25, r25
    3c70:	88 0f       	add	r24, r24
    3c72:	99 1f       	adc	r25, r25
    3c74:	82 0f       	add	r24, r18
    3c76:	93 1f       	adc	r25, r19
    3c78:	8a 58       	subi	r24, 0x8A	; 138
    3c7a:	99 4f       	sbci	r25, 0xF9	; 249
    3c7c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c7e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c80:	93 87       	std	Z+11, r25	; 0x0b
    3c82:	82 87       	std	Z+10, r24	; 0x0a
    3c84:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c86:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c88:	86 89       	ldd	r24, Z+22	; 0x16
    3c8a:	28 2f       	mov	r18, r24
    3c8c:	30 e0       	ldi	r19, 0x00	; 0
    3c8e:	c9 01       	movw	r24, r18
    3c90:	88 0f       	add	r24, r24
    3c92:	99 1f       	adc	r25, r25
    3c94:	88 0f       	add	r24, r24
    3c96:	99 1f       	adc	r25, r25
    3c98:	88 0f       	add	r24, r24
    3c9a:	99 1f       	adc	r25, r25
    3c9c:	82 0f       	add	r24, r18
    3c9e:	93 1f       	adc	r25, r19
    3ca0:	fc 01       	movw	r30, r24
    3ca2:	ea 58       	subi	r30, 0x8A	; 138
    3ca4:	f9 4f       	sbci	r31, 0xF9	; 249
    3ca6:	80 81       	ld	r24, Z
    3ca8:	8f 5f       	subi	r24, 0xFF	; 255
    3caa:	80 83       	st	Z, r24
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3cac:	ee 85       	ldd	r30, Y+14	; 0x0e
    3cae:	ff 85       	ldd	r31, Y+15	; 0x0f
    3cb0:	96 89       	ldd	r25, Z+22	; 0x16
    3cb2:	e0 91 64 06 	lds	r30, 0x0664
    3cb6:	f0 91 65 06 	lds	r31, 0x0665
    3cba:	86 89       	ldd	r24, Z+22	; 0x16
    3cbc:	89 17       	cp	r24, r25
    3cbe:	08 f0       	brcs	.+2      	; 0x3cc2 <xTaskIncrementTick+0x2c4>
    3cc0:	e4 ce       	rjmp	.-568    	; 0x3a8a <xTaskIncrementTick+0x8c>
                        {
                            xSwitchRequired = pdTRUE;
    3cc2:	81 e0       	ldi	r24, 0x01	; 1
    3cc4:	8b 87       	std	Y+11, r24	; 0x0b
    3cc6:	e1 ce       	rjmp	.-574    	; 0x3a8a <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3cc8:	e0 91 64 06 	lds	r30, 0x0664
    3ccc:	f0 91 65 06 	lds	r31, 0x0665
    3cd0:	86 89       	ldd	r24, Z+22	; 0x16
    3cd2:	28 2f       	mov	r18, r24
    3cd4:	30 e0       	ldi	r19, 0x00	; 0
    3cd6:	c9 01       	movw	r24, r18
    3cd8:	88 0f       	add	r24, r24
    3cda:	99 1f       	adc	r25, r25
    3cdc:	88 0f       	add	r24, r24
    3cde:	99 1f       	adc	r25, r25
    3ce0:	88 0f       	add	r24, r24
    3ce2:	99 1f       	adc	r25, r25
    3ce4:	82 0f       	add	r24, r18
    3ce6:	93 1f       	adc	r25, r19
    3ce8:	fc 01       	movw	r30, r24
    3cea:	ea 58       	subi	r30, 0x8A	; 138
    3cec:	f9 4f       	sbci	r31, 0xF9	; 249
    3cee:	80 81       	ld	r24, Z
    3cf0:	82 30       	cpi	r24, 0x02	; 2
    3cf2:	10 f0       	brcs	.+4      	; 0x3cf8 <xTaskIncrementTick+0x2fa>
            {
                xSwitchRequired = pdTRUE;
    3cf4:	81 e0       	ldi	r24, 0x01	; 1
    3cf6:	8b 87       	std	Y+11, r24	; 0x0b
        }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
        {
            if( xYieldPending != pdFALSE )
    3cf8:	80 91 6e 06 	lds	r24, 0x066E
    3cfc:	88 23       	and	r24, r24
    3cfe:	61 f0       	breq	.+24     	; 0x3d18 <xTaskIncrementTick+0x31a>
            {
                xSwitchRequired = pdTRUE;
    3d00:	81 e0       	ldi	r24, 0x01	; 1
    3d02:	8b 87       	std	Y+11, r24	; 0x0b
    3d04:	09 c0       	rjmp	.+18     	; 0x3d18 <xTaskIncrementTick+0x31a>
        }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    3d06:	80 91 6c 06 	lds	r24, 0x066C
    3d0a:	90 91 6d 06 	lds	r25, 0x066D
    3d0e:	01 96       	adiw	r24, 0x01	; 1
    3d10:	90 93 6d 06 	sts	0x066D, r25
    3d14:	80 93 6c 06 	sts	0x066C, r24
            vApplicationTickHook();
        }
        #endif
    }

    return xSwitchRequired;
    3d18:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    3d1a:	2f 96       	adiw	r28, 0x0f	; 15
    3d1c:	0f b6       	in	r0, 0x3f	; 63
    3d1e:	f8 94       	cli
    3d20:	de bf       	out	0x3e, r29	; 62
    3d22:	0f be       	out	0x3f, r0	; 63
    3d24:	cd bf       	out	0x3d, r28	; 61
    3d26:	cf 91       	pop	r28
    3d28:	df 91       	pop	r29
    3d2a:	08 95       	ret

00003d2c <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3d2c:	df 93       	push	r29
    3d2e:	cf 93       	push	r28
    3d30:	00 d0       	rcall	.+0      	; 0x3d32 <vTaskSwitchContext+0x6>
    3d32:	0f 92       	push	r0
    3d34:	cd b7       	in	r28, 0x3d	; 61
    3d36:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3d38:	80 91 75 06 	lds	r24, 0x0675
    3d3c:	88 23       	and	r24, r24
    3d3e:	21 f0       	breq	.+8      	; 0x3d48 <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    3d40:	81 e0       	ldi	r24, 0x01	; 1
    3d42:	80 93 6e 06 	sts	0x066E, r24
    3d46:	59 c0       	rjmp	.+178    	; 0x3dfa <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    3d48:	10 92 6e 06 	sts	0x066E, r1
        }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3d4c:	80 91 6a 06 	lds	r24, 0x066A
    3d50:	8b 83       	std	Y+3, r24	; 0x03
    3d52:	03 c0       	rjmp	.+6      	; 0x3d5a <vTaskSwitchContext+0x2e>
    3d54:	8b 81       	ldd	r24, Y+3	; 0x03
    3d56:	81 50       	subi	r24, 0x01	; 1
    3d58:	8b 83       	std	Y+3, r24	; 0x03
    3d5a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d5c:	28 2f       	mov	r18, r24
    3d5e:	30 e0       	ldi	r19, 0x00	; 0
    3d60:	c9 01       	movw	r24, r18
    3d62:	88 0f       	add	r24, r24
    3d64:	99 1f       	adc	r25, r25
    3d66:	88 0f       	add	r24, r24
    3d68:	99 1f       	adc	r25, r25
    3d6a:	88 0f       	add	r24, r24
    3d6c:	99 1f       	adc	r25, r25
    3d6e:	82 0f       	add	r24, r18
    3d70:	93 1f       	adc	r25, r19
    3d72:	fc 01       	movw	r30, r24
    3d74:	ea 58       	subi	r30, 0x8A	; 138
    3d76:	f9 4f       	sbci	r31, 0xF9	; 249
    3d78:	80 81       	ld	r24, Z
    3d7a:	88 23       	and	r24, r24
    3d7c:	59 f3       	breq	.-42     	; 0x3d54 <vTaskSwitchContext+0x28>
    3d7e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d80:	28 2f       	mov	r18, r24
    3d82:	30 e0       	ldi	r19, 0x00	; 0
    3d84:	c9 01       	movw	r24, r18
    3d86:	88 0f       	add	r24, r24
    3d88:	99 1f       	adc	r25, r25
    3d8a:	88 0f       	add	r24, r24
    3d8c:	99 1f       	adc	r25, r25
    3d8e:	88 0f       	add	r24, r24
    3d90:	99 1f       	adc	r25, r25
    3d92:	82 0f       	add	r24, r18
    3d94:	93 1f       	adc	r25, r19
    3d96:	8a 58       	subi	r24, 0x8A	; 138
    3d98:	99 4f       	sbci	r25, 0xF9	; 249
    3d9a:	9a 83       	std	Y+2, r25	; 0x02
    3d9c:	89 83       	std	Y+1, r24	; 0x01
    3d9e:	e9 81       	ldd	r30, Y+1	; 0x01
    3da0:	fa 81       	ldd	r31, Y+2	; 0x02
    3da2:	01 80       	ldd	r0, Z+1	; 0x01
    3da4:	f2 81       	ldd	r31, Z+2	; 0x02
    3da6:	e0 2d       	mov	r30, r0
    3da8:	82 81       	ldd	r24, Z+2	; 0x02
    3daa:	93 81       	ldd	r25, Z+3	; 0x03
    3dac:	e9 81       	ldd	r30, Y+1	; 0x01
    3dae:	fa 81       	ldd	r31, Y+2	; 0x02
    3db0:	92 83       	std	Z+2, r25	; 0x02
    3db2:	81 83       	std	Z+1, r24	; 0x01
    3db4:	e9 81       	ldd	r30, Y+1	; 0x01
    3db6:	fa 81       	ldd	r31, Y+2	; 0x02
    3db8:	21 81       	ldd	r18, Z+1	; 0x01
    3dba:	32 81       	ldd	r19, Z+2	; 0x02
    3dbc:	89 81       	ldd	r24, Y+1	; 0x01
    3dbe:	9a 81       	ldd	r25, Y+2	; 0x02
    3dc0:	03 96       	adiw	r24, 0x03	; 3
    3dc2:	28 17       	cp	r18, r24
    3dc4:	39 07       	cpc	r19, r25
    3dc6:	59 f4       	brne	.+22     	; 0x3dde <vTaskSwitchContext+0xb2>
    3dc8:	e9 81       	ldd	r30, Y+1	; 0x01
    3dca:	fa 81       	ldd	r31, Y+2	; 0x02
    3dcc:	01 80       	ldd	r0, Z+1	; 0x01
    3dce:	f2 81       	ldd	r31, Z+2	; 0x02
    3dd0:	e0 2d       	mov	r30, r0
    3dd2:	82 81       	ldd	r24, Z+2	; 0x02
    3dd4:	93 81       	ldd	r25, Z+3	; 0x03
    3dd6:	e9 81       	ldd	r30, Y+1	; 0x01
    3dd8:	fa 81       	ldd	r31, Y+2	; 0x02
    3dda:	92 83       	std	Z+2, r25	; 0x02
    3ddc:	81 83       	std	Z+1, r24	; 0x01
    3dde:	e9 81       	ldd	r30, Y+1	; 0x01
    3de0:	fa 81       	ldd	r31, Y+2	; 0x02
    3de2:	01 80       	ldd	r0, Z+1	; 0x01
    3de4:	f2 81       	ldd	r31, Z+2	; 0x02
    3de6:	e0 2d       	mov	r30, r0
    3de8:	86 81       	ldd	r24, Z+6	; 0x06
    3dea:	97 81       	ldd	r25, Z+7	; 0x07
    3dec:	90 93 65 06 	sts	0x0665, r25
    3df0:	80 93 64 06 	sts	0x0664, r24
    3df4:	8b 81       	ldd	r24, Y+3	; 0x03
    3df6:	80 93 6a 06 	sts	0x066A, r24
             * Block specific to this task. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif
    }
}
    3dfa:	0f 90       	pop	r0
    3dfc:	0f 90       	pop	r0
    3dfe:	0f 90       	pop	r0
    3e00:	cf 91       	pop	r28
    3e02:	df 91       	pop	r29
    3e04:	08 95       	ret

00003e06 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    3e06:	df 93       	push	r29
    3e08:	cf 93       	push	r28
    3e0a:	00 d0       	rcall	.+0      	; 0x3e0c <vTaskPlaceOnEventList+0x6>
    3e0c:	00 d0       	rcall	.+0      	; 0x3e0e <vTaskPlaceOnEventList+0x8>
    3e0e:	cd b7       	in	r28, 0x3d	; 61
    3e10:	de b7       	in	r29, 0x3e	; 62
    3e12:	9a 83       	std	Y+2, r25	; 0x02
    3e14:	89 83       	std	Y+1, r24	; 0x01
    3e16:	7c 83       	std	Y+4, r23	; 0x04
    3e18:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3e1a:	80 91 64 06 	lds	r24, 0x0664
    3e1e:	90 91 65 06 	lds	r25, 0x0665
    3e22:	9c 01       	movw	r18, r24
    3e24:	24 5f       	subi	r18, 0xF4	; 244
    3e26:	3f 4f       	sbci	r19, 0xFF	; 255
    3e28:	89 81       	ldd	r24, Y+1	; 0x01
    3e2a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e2c:	b9 01       	movw	r22, r18
    3e2e:	0e 94 60 07 	call	0xec0	; 0xec0 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3e32:	8b 81       	ldd	r24, Y+3	; 0x03
    3e34:	9c 81       	ldd	r25, Y+4	; 0x04
    3e36:	61 e0       	ldi	r22, 0x01	; 1
    3e38:	0e 94 71 2b 	call	0x56e2	; 0x56e2 <prvAddCurrentTaskToDelayedList>
}
    3e3c:	0f 90       	pop	r0
    3e3e:	0f 90       	pop	r0
    3e40:	0f 90       	pop	r0
    3e42:	0f 90       	pop	r0
    3e44:	cf 91       	pop	r28
    3e46:	df 91       	pop	r29
    3e48:	08 95       	ret

00003e4a <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    3e4a:	df 93       	push	r29
    3e4c:	cf 93       	push	r28
    3e4e:	cd b7       	in	r28, 0x3d	; 61
    3e50:	de b7       	in	r29, 0x3e	; 62
    3e52:	28 97       	sbiw	r28, 0x08	; 8
    3e54:	0f b6       	in	r0, 0x3f	; 63
    3e56:	f8 94       	cli
    3e58:	de bf       	out	0x3e, r29	; 62
    3e5a:	0f be       	out	0x3f, r0	; 63
    3e5c:	cd bf       	out	0x3d, r28	; 61
    3e5e:	9c 83       	std	Y+4, r25	; 0x04
    3e60:	8b 83       	std	Y+3, r24	; 0x03
    3e62:	7e 83       	std	Y+6, r23	; 0x06
    3e64:	6d 83       	std	Y+5, r22	; 0x05
    3e66:	58 87       	std	Y+8, r21	; 0x08
    3e68:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3e6a:	e0 91 64 06 	lds	r30, 0x0664
    3e6e:	f0 91 65 06 	lds	r31, 0x0665
    3e72:	8d 81       	ldd	r24, Y+5	; 0x05
    3e74:	9e 81       	ldd	r25, Y+6	; 0x06
    3e76:	90 68       	ori	r25, 0x80	; 128
    3e78:	95 87       	std	Z+13, r25	; 0x0d
    3e7a:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3e7c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e7e:	fc 81       	ldd	r31, Y+4	; 0x04
    3e80:	81 81       	ldd	r24, Z+1	; 0x01
    3e82:	92 81       	ldd	r25, Z+2	; 0x02
    3e84:	9a 83       	std	Y+2, r25	; 0x02
    3e86:	89 83       	std	Y+1, r24	; 0x01
    3e88:	e0 91 64 06 	lds	r30, 0x0664
    3e8c:	f0 91 65 06 	lds	r31, 0x0665
    3e90:	89 81       	ldd	r24, Y+1	; 0x01
    3e92:	9a 81       	ldd	r25, Y+2	; 0x02
    3e94:	97 87       	std	Z+15, r25	; 0x0f
    3e96:	86 87       	std	Z+14, r24	; 0x0e
    3e98:	a0 91 64 06 	lds	r26, 0x0664
    3e9c:	b0 91 65 06 	lds	r27, 0x0665
    3ea0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ea2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ea4:	84 81       	ldd	r24, Z+4	; 0x04
    3ea6:	95 81       	ldd	r25, Z+5	; 0x05
    3ea8:	51 96       	adiw	r26, 0x11	; 17
    3eaa:	9c 93       	st	X, r25
    3eac:	8e 93       	st	-X, r24
    3eae:	50 97       	sbiw	r26, 0x10	; 16
    3eb0:	e9 81       	ldd	r30, Y+1	; 0x01
    3eb2:	fa 81       	ldd	r31, Y+2	; 0x02
    3eb4:	04 80       	ldd	r0, Z+4	; 0x04
    3eb6:	f5 81       	ldd	r31, Z+5	; 0x05
    3eb8:	e0 2d       	mov	r30, r0
    3eba:	80 91 64 06 	lds	r24, 0x0664
    3ebe:	90 91 65 06 	lds	r25, 0x0665
    3ec2:	0c 96       	adiw	r24, 0x0c	; 12
    3ec4:	93 83       	std	Z+3, r25	; 0x03
    3ec6:	82 83       	std	Z+2, r24	; 0x02
    3ec8:	80 91 64 06 	lds	r24, 0x0664
    3ecc:	90 91 65 06 	lds	r25, 0x0665
    3ed0:	0c 96       	adiw	r24, 0x0c	; 12
    3ed2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ed4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ed6:	95 83       	std	Z+5, r25	; 0x05
    3ed8:	84 83       	std	Z+4, r24	; 0x04
    3eda:	e0 91 64 06 	lds	r30, 0x0664
    3ede:	f0 91 65 06 	lds	r31, 0x0665
    3ee2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ee4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ee6:	95 8b       	std	Z+21, r25	; 0x15
    3ee8:	84 8b       	std	Z+20, r24	; 0x14
    3eea:	eb 81       	ldd	r30, Y+3	; 0x03
    3eec:	fc 81       	ldd	r31, Y+4	; 0x04
    3eee:	80 81       	ld	r24, Z
    3ef0:	8f 5f       	subi	r24, 0xFF	; 255
    3ef2:	eb 81       	ldd	r30, Y+3	; 0x03
    3ef4:	fc 81       	ldd	r31, Y+4	; 0x04
    3ef6:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3ef8:	8f 81       	ldd	r24, Y+7	; 0x07
    3efa:	98 85       	ldd	r25, Y+8	; 0x08
    3efc:	61 e0       	ldi	r22, 0x01	; 1
    3efe:	0e 94 71 2b 	call	0x56e2	; 0x56e2 <prvAddCurrentTaskToDelayedList>
}
    3f02:	28 96       	adiw	r28, 0x08	; 8
    3f04:	0f b6       	in	r0, 0x3f	; 63
    3f06:	f8 94       	cli
    3f08:	de bf       	out	0x3e, r29	; 62
    3f0a:	0f be       	out	0x3f, r0	; 63
    3f0c:	cd bf       	out	0x3d, r28	; 61
    3f0e:	cf 91       	pop	r28
    3f10:	df 91       	pop	r29
    3f12:	08 95       	ret

00003f14 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
    3f14:	df 93       	push	r29
    3f16:	cf 93       	push	r28
    3f18:	cd b7       	in	r28, 0x3d	; 61
    3f1a:	de b7       	in	r29, 0x3e	; 62
    3f1c:	27 97       	sbiw	r28, 0x07	; 7
    3f1e:	0f b6       	in	r0, 0x3f	; 63
    3f20:	f8 94       	cli
    3f22:	de bf       	out	0x3e, r29	; 62
    3f24:	0f be       	out	0x3f, r0	; 63
    3f26:	cd bf       	out	0x3d, r28	; 61
    3f28:	9c 83       	std	Y+4, r25	; 0x04
    3f2a:	8b 83       	std	Y+3, r24	; 0x03
    3f2c:	7e 83       	std	Y+6, r23	; 0x06
    3f2e:	6d 83       	std	Y+5, r22	; 0x05
    3f30:	4f 83       	std	Y+7, r20	; 0x07

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3f32:	eb 81       	ldd	r30, Y+3	; 0x03
    3f34:	fc 81       	ldd	r31, Y+4	; 0x04
    3f36:	81 81       	ldd	r24, Z+1	; 0x01
    3f38:	92 81       	ldd	r25, Z+2	; 0x02
    3f3a:	9a 83       	std	Y+2, r25	; 0x02
    3f3c:	89 83       	std	Y+1, r24	; 0x01
    3f3e:	e0 91 64 06 	lds	r30, 0x0664
    3f42:	f0 91 65 06 	lds	r31, 0x0665
    3f46:	89 81       	ldd	r24, Y+1	; 0x01
    3f48:	9a 81       	ldd	r25, Y+2	; 0x02
    3f4a:	97 87       	std	Z+15, r25	; 0x0f
    3f4c:	86 87       	std	Z+14, r24	; 0x0e
    3f4e:	a0 91 64 06 	lds	r26, 0x0664
    3f52:	b0 91 65 06 	lds	r27, 0x0665
    3f56:	e9 81       	ldd	r30, Y+1	; 0x01
    3f58:	fa 81       	ldd	r31, Y+2	; 0x02
    3f5a:	84 81       	ldd	r24, Z+4	; 0x04
    3f5c:	95 81       	ldd	r25, Z+5	; 0x05
    3f5e:	51 96       	adiw	r26, 0x11	; 17
    3f60:	9c 93       	st	X, r25
    3f62:	8e 93       	st	-X, r24
    3f64:	50 97       	sbiw	r26, 0x10	; 16
    3f66:	e9 81       	ldd	r30, Y+1	; 0x01
    3f68:	fa 81       	ldd	r31, Y+2	; 0x02
    3f6a:	04 80       	ldd	r0, Z+4	; 0x04
    3f6c:	f5 81       	ldd	r31, Z+5	; 0x05
    3f6e:	e0 2d       	mov	r30, r0
    3f70:	80 91 64 06 	lds	r24, 0x0664
    3f74:	90 91 65 06 	lds	r25, 0x0665
    3f78:	0c 96       	adiw	r24, 0x0c	; 12
    3f7a:	93 83       	std	Z+3, r25	; 0x03
    3f7c:	82 83       	std	Z+2, r24	; 0x02
    3f7e:	80 91 64 06 	lds	r24, 0x0664
    3f82:	90 91 65 06 	lds	r25, 0x0665
    3f86:	0c 96       	adiw	r24, 0x0c	; 12
    3f88:	e9 81       	ldd	r30, Y+1	; 0x01
    3f8a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f8c:	95 83       	std	Z+5, r25	; 0x05
    3f8e:	84 83       	std	Z+4, r24	; 0x04
    3f90:	e0 91 64 06 	lds	r30, 0x0664
    3f94:	f0 91 65 06 	lds	r31, 0x0665
    3f98:	8b 81       	ldd	r24, Y+3	; 0x03
    3f9a:	9c 81       	ldd	r25, Y+4	; 0x04
    3f9c:	95 8b       	std	Z+21, r25	; 0x15
    3f9e:	84 8b       	std	Z+20, r24	; 0x14
    3fa0:	eb 81       	ldd	r30, Y+3	; 0x03
    3fa2:	fc 81       	ldd	r31, Y+4	; 0x04
    3fa4:	80 81       	ld	r24, Z
    3fa6:	8f 5f       	subi	r24, 0xFF	; 255
    3fa8:	eb 81       	ldd	r30, Y+3	; 0x03
    3faa:	fc 81       	ldd	r31, Y+4	; 0x04
    3fac:	80 83       	st	Z, r24

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
    3fae:	8f 81       	ldd	r24, Y+7	; 0x07
    3fb0:	88 23       	and	r24, r24
    3fb2:	21 f0       	breq	.+8      	; 0x3fbc <vTaskPlaceOnEventListRestricted+0xa8>
        {
            xTicksToWait = portMAX_DELAY;
    3fb4:	8f ef       	ldi	r24, 0xFF	; 255
    3fb6:	9f ef       	ldi	r25, 0xFF	; 255
    3fb8:	9e 83       	std	Y+6, r25	; 0x06
    3fba:	8d 83       	std	Y+5, r24	; 0x05
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    3fbc:	8d 81       	ldd	r24, Y+5	; 0x05
    3fbe:	9e 81       	ldd	r25, Y+6	; 0x06
    3fc0:	6f 81       	ldd	r22, Y+7	; 0x07
    3fc2:	0e 94 71 2b 	call	0x56e2	; 0x56e2 <prvAddCurrentTaskToDelayedList>
    }
    3fc6:	27 96       	adiw	r28, 0x07	; 7
    3fc8:	0f b6       	in	r0, 0x3f	; 63
    3fca:	f8 94       	cli
    3fcc:	de bf       	out	0x3e, r29	; 62
    3fce:	0f be       	out	0x3f, r0	; 63
    3fd0:	cd bf       	out	0x3d, r28	; 61
    3fd2:	cf 91       	pop	r28
    3fd4:	df 91       	pop	r29
    3fd6:	08 95       	ret

00003fd8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3fd8:	df 93       	push	r29
    3fda:	cf 93       	push	r28
    3fdc:	cd b7       	in	r28, 0x3d	; 61
    3fde:	de b7       	in	r29, 0x3e	; 62
    3fe0:	2d 97       	sbiw	r28, 0x0d	; 13
    3fe2:	0f b6       	in	r0, 0x3f	; 63
    3fe4:	f8 94       	cli
    3fe6:	de bf       	out	0x3e, r29	; 62
    3fe8:	0f be       	out	0x3f, r0	; 63
    3fea:	cd bf       	out	0x3d, r28	; 61
    3fec:	9d 87       	std	Y+13, r25	; 0x0d
    3fee:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3ff0:	ec 85       	ldd	r30, Y+12	; 0x0c
    3ff2:	fd 85       	ldd	r31, Y+13	; 0x0d
    3ff4:	05 80       	ldd	r0, Z+5	; 0x05
    3ff6:	f6 81       	ldd	r31, Z+6	; 0x06
    3ff8:	e0 2d       	mov	r30, r0
    3ffa:	86 81       	ldd	r24, Z+6	; 0x06
    3ffc:	97 81       	ldd	r25, Z+7	; 0x07
    3ffe:	9b 87       	std	Y+11, r25	; 0x0b
    4000:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    4002:	ea 85       	ldd	r30, Y+10	; 0x0a
    4004:	fb 85       	ldd	r31, Y+11	; 0x0b
    4006:	84 89       	ldd	r24, Z+20	; 0x14
    4008:	95 89       	ldd	r25, Z+21	; 0x15
    400a:	98 87       	std	Y+8, r25	; 0x08
    400c:	8f 83       	std	Y+7, r24	; 0x07
    400e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4010:	fb 85       	ldd	r31, Y+11	; 0x0b
    4012:	a6 85       	ldd	r26, Z+14	; 0x0e
    4014:	b7 85       	ldd	r27, Z+15	; 0x0f
    4016:	ea 85       	ldd	r30, Y+10	; 0x0a
    4018:	fb 85       	ldd	r31, Y+11	; 0x0b
    401a:	80 89       	ldd	r24, Z+16	; 0x10
    401c:	91 89       	ldd	r25, Z+17	; 0x11
    401e:	15 96       	adiw	r26, 0x05	; 5
    4020:	9c 93       	st	X, r25
    4022:	8e 93       	st	-X, r24
    4024:	14 97       	sbiw	r26, 0x04	; 4
    4026:	ea 85       	ldd	r30, Y+10	; 0x0a
    4028:	fb 85       	ldd	r31, Y+11	; 0x0b
    402a:	a0 89       	ldd	r26, Z+16	; 0x10
    402c:	b1 89       	ldd	r27, Z+17	; 0x11
    402e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4030:	fb 85       	ldd	r31, Y+11	; 0x0b
    4032:	86 85       	ldd	r24, Z+14	; 0x0e
    4034:	97 85       	ldd	r25, Z+15	; 0x0f
    4036:	13 96       	adiw	r26, 0x03	; 3
    4038:	9c 93       	st	X, r25
    403a:	8e 93       	st	-X, r24
    403c:	12 97       	sbiw	r26, 0x02	; 2
    403e:	ef 81       	ldd	r30, Y+7	; 0x07
    4040:	f8 85       	ldd	r31, Y+8	; 0x08
    4042:	21 81       	ldd	r18, Z+1	; 0x01
    4044:	32 81       	ldd	r19, Z+2	; 0x02
    4046:	8a 85       	ldd	r24, Y+10	; 0x0a
    4048:	9b 85       	ldd	r25, Y+11	; 0x0b
    404a:	0c 96       	adiw	r24, 0x0c	; 12
    404c:	28 17       	cp	r18, r24
    404e:	39 07       	cpc	r19, r25
    4050:	41 f4       	brne	.+16     	; 0x4062 <xTaskRemoveFromEventList+0x8a>
    4052:	ea 85       	ldd	r30, Y+10	; 0x0a
    4054:	fb 85       	ldd	r31, Y+11	; 0x0b
    4056:	80 89       	ldd	r24, Z+16	; 0x10
    4058:	91 89       	ldd	r25, Z+17	; 0x11
    405a:	ef 81       	ldd	r30, Y+7	; 0x07
    405c:	f8 85       	ldd	r31, Y+8	; 0x08
    405e:	92 83       	std	Z+2, r25	; 0x02
    4060:	81 83       	std	Z+1, r24	; 0x01
    4062:	ea 85       	ldd	r30, Y+10	; 0x0a
    4064:	fb 85       	ldd	r31, Y+11	; 0x0b
    4066:	15 8a       	std	Z+21, r1	; 0x15
    4068:	14 8a       	std	Z+20, r1	; 0x14
    406a:	ef 81       	ldd	r30, Y+7	; 0x07
    406c:	f8 85       	ldd	r31, Y+8	; 0x08
    406e:	80 81       	ld	r24, Z
    4070:	81 50       	subi	r24, 0x01	; 1
    4072:	ef 81       	ldd	r30, Y+7	; 0x07
    4074:	f8 85       	ldd	r31, Y+8	; 0x08
    4076:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4078:	80 91 75 06 	lds	r24, 0x0675
    407c:	88 23       	and	r24, r24
    407e:	09 f0       	breq	.+2      	; 0x4082 <xTaskRemoveFromEventList+0xaa>
    4080:	a4 c0       	rjmp	.+328    	; 0x41ca <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    4082:	ea 85       	ldd	r30, Y+10	; 0x0a
    4084:	fb 85       	ldd	r31, Y+11	; 0x0b
    4086:	82 85       	ldd	r24, Z+10	; 0x0a
    4088:	93 85       	ldd	r25, Z+11	; 0x0b
    408a:	9e 83       	std	Y+6, r25	; 0x06
    408c:	8d 83       	std	Y+5, r24	; 0x05
    408e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4090:	fb 85       	ldd	r31, Y+11	; 0x0b
    4092:	a4 81       	ldd	r26, Z+4	; 0x04
    4094:	b5 81       	ldd	r27, Z+5	; 0x05
    4096:	ea 85       	ldd	r30, Y+10	; 0x0a
    4098:	fb 85       	ldd	r31, Y+11	; 0x0b
    409a:	86 81       	ldd	r24, Z+6	; 0x06
    409c:	97 81       	ldd	r25, Z+7	; 0x07
    409e:	15 96       	adiw	r26, 0x05	; 5
    40a0:	9c 93       	st	X, r25
    40a2:	8e 93       	st	-X, r24
    40a4:	14 97       	sbiw	r26, 0x04	; 4
    40a6:	ea 85       	ldd	r30, Y+10	; 0x0a
    40a8:	fb 85       	ldd	r31, Y+11	; 0x0b
    40aa:	a6 81       	ldd	r26, Z+6	; 0x06
    40ac:	b7 81       	ldd	r27, Z+7	; 0x07
    40ae:	ea 85       	ldd	r30, Y+10	; 0x0a
    40b0:	fb 85       	ldd	r31, Y+11	; 0x0b
    40b2:	84 81       	ldd	r24, Z+4	; 0x04
    40b4:	95 81       	ldd	r25, Z+5	; 0x05
    40b6:	13 96       	adiw	r26, 0x03	; 3
    40b8:	9c 93       	st	X, r25
    40ba:	8e 93       	st	-X, r24
    40bc:	12 97       	sbiw	r26, 0x02	; 2
    40be:	ed 81       	ldd	r30, Y+5	; 0x05
    40c0:	fe 81       	ldd	r31, Y+6	; 0x06
    40c2:	21 81       	ldd	r18, Z+1	; 0x01
    40c4:	32 81       	ldd	r19, Z+2	; 0x02
    40c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    40c8:	9b 85       	ldd	r25, Y+11	; 0x0b
    40ca:	02 96       	adiw	r24, 0x02	; 2
    40cc:	28 17       	cp	r18, r24
    40ce:	39 07       	cpc	r19, r25
    40d0:	41 f4       	brne	.+16     	; 0x40e2 <xTaskRemoveFromEventList+0x10a>
    40d2:	ea 85       	ldd	r30, Y+10	; 0x0a
    40d4:	fb 85       	ldd	r31, Y+11	; 0x0b
    40d6:	86 81       	ldd	r24, Z+6	; 0x06
    40d8:	97 81       	ldd	r25, Z+7	; 0x07
    40da:	ed 81       	ldd	r30, Y+5	; 0x05
    40dc:	fe 81       	ldd	r31, Y+6	; 0x06
    40de:	92 83       	std	Z+2, r25	; 0x02
    40e0:	81 83       	std	Z+1, r24	; 0x01
    40e2:	ea 85       	ldd	r30, Y+10	; 0x0a
    40e4:	fb 85       	ldd	r31, Y+11	; 0x0b
    40e6:	13 86       	std	Z+11, r1	; 0x0b
    40e8:	12 86       	std	Z+10, r1	; 0x0a
    40ea:	ed 81       	ldd	r30, Y+5	; 0x05
    40ec:	fe 81       	ldd	r31, Y+6	; 0x06
    40ee:	80 81       	ld	r24, Z
    40f0:	81 50       	subi	r24, 0x01	; 1
    40f2:	ed 81       	ldd	r30, Y+5	; 0x05
    40f4:	fe 81       	ldd	r31, Y+6	; 0x06
    40f6:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    40f8:	ea 85       	ldd	r30, Y+10	; 0x0a
    40fa:	fb 85       	ldd	r31, Y+11	; 0x0b
    40fc:	96 89       	ldd	r25, Z+22	; 0x16
    40fe:	80 91 6a 06 	lds	r24, 0x066A
    4102:	89 17       	cp	r24, r25
    4104:	28 f4       	brcc	.+10     	; 0x4110 <xTaskRemoveFromEventList+0x138>
    4106:	ea 85       	ldd	r30, Y+10	; 0x0a
    4108:	fb 85       	ldd	r31, Y+11	; 0x0b
    410a:	86 89       	ldd	r24, Z+22	; 0x16
    410c:	80 93 6a 06 	sts	0x066A, r24
    4110:	ea 85       	ldd	r30, Y+10	; 0x0a
    4112:	fb 85       	ldd	r31, Y+11	; 0x0b
    4114:	86 89       	ldd	r24, Z+22	; 0x16
    4116:	28 2f       	mov	r18, r24
    4118:	30 e0       	ldi	r19, 0x00	; 0
    411a:	c9 01       	movw	r24, r18
    411c:	88 0f       	add	r24, r24
    411e:	99 1f       	adc	r25, r25
    4120:	88 0f       	add	r24, r24
    4122:	99 1f       	adc	r25, r25
    4124:	88 0f       	add	r24, r24
    4126:	99 1f       	adc	r25, r25
    4128:	82 0f       	add	r24, r18
    412a:	93 1f       	adc	r25, r19
    412c:	fc 01       	movw	r30, r24
    412e:	ea 58       	subi	r30, 0x8A	; 138
    4130:	f9 4f       	sbci	r31, 0xF9	; 249
    4132:	81 81       	ldd	r24, Z+1	; 0x01
    4134:	92 81       	ldd	r25, Z+2	; 0x02
    4136:	9c 83       	std	Y+4, r25	; 0x04
    4138:	8b 83       	std	Y+3, r24	; 0x03
    413a:	ea 85       	ldd	r30, Y+10	; 0x0a
    413c:	fb 85       	ldd	r31, Y+11	; 0x0b
    413e:	8b 81       	ldd	r24, Y+3	; 0x03
    4140:	9c 81       	ldd	r25, Y+4	; 0x04
    4142:	95 83       	std	Z+5, r25	; 0x05
    4144:	84 83       	std	Z+4, r24	; 0x04
    4146:	eb 81       	ldd	r30, Y+3	; 0x03
    4148:	fc 81       	ldd	r31, Y+4	; 0x04
    414a:	84 81       	ldd	r24, Z+4	; 0x04
    414c:	95 81       	ldd	r25, Z+5	; 0x05
    414e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4150:	fb 85       	ldd	r31, Y+11	; 0x0b
    4152:	97 83       	std	Z+7, r25	; 0x07
    4154:	86 83       	std	Z+6, r24	; 0x06
    4156:	eb 81       	ldd	r30, Y+3	; 0x03
    4158:	fc 81       	ldd	r31, Y+4	; 0x04
    415a:	04 80       	ldd	r0, Z+4	; 0x04
    415c:	f5 81       	ldd	r31, Z+5	; 0x05
    415e:	e0 2d       	mov	r30, r0
    4160:	8a 85       	ldd	r24, Y+10	; 0x0a
    4162:	9b 85       	ldd	r25, Y+11	; 0x0b
    4164:	02 96       	adiw	r24, 0x02	; 2
    4166:	93 83       	std	Z+3, r25	; 0x03
    4168:	82 83       	std	Z+2, r24	; 0x02
    416a:	8a 85       	ldd	r24, Y+10	; 0x0a
    416c:	9b 85       	ldd	r25, Y+11	; 0x0b
    416e:	02 96       	adiw	r24, 0x02	; 2
    4170:	eb 81       	ldd	r30, Y+3	; 0x03
    4172:	fc 81       	ldd	r31, Y+4	; 0x04
    4174:	95 83       	std	Z+5, r25	; 0x05
    4176:	84 83       	std	Z+4, r24	; 0x04
    4178:	ea 85       	ldd	r30, Y+10	; 0x0a
    417a:	fb 85       	ldd	r31, Y+11	; 0x0b
    417c:	86 89       	ldd	r24, Z+22	; 0x16
    417e:	28 2f       	mov	r18, r24
    4180:	30 e0       	ldi	r19, 0x00	; 0
    4182:	c9 01       	movw	r24, r18
    4184:	88 0f       	add	r24, r24
    4186:	99 1f       	adc	r25, r25
    4188:	88 0f       	add	r24, r24
    418a:	99 1f       	adc	r25, r25
    418c:	88 0f       	add	r24, r24
    418e:	99 1f       	adc	r25, r25
    4190:	82 0f       	add	r24, r18
    4192:	93 1f       	adc	r25, r19
    4194:	8a 58       	subi	r24, 0x8A	; 138
    4196:	99 4f       	sbci	r25, 0xF9	; 249
    4198:	ea 85       	ldd	r30, Y+10	; 0x0a
    419a:	fb 85       	ldd	r31, Y+11	; 0x0b
    419c:	93 87       	std	Z+11, r25	; 0x0b
    419e:	82 87       	std	Z+10, r24	; 0x0a
    41a0:	ea 85       	ldd	r30, Y+10	; 0x0a
    41a2:	fb 85       	ldd	r31, Y+11	; 0x0b
    41a4:	86 89       	ldd	r24, Z+22	; 0x16
    41a6:	28 2f       	mov	r18, r24
    41a8:	30 e0       	ldi	r19, 0x00	; 0
    41aa:	c9 01       	movw	r24, r18
    41ac:	88 0f       	add	r24, r24
    41ae:	99 1f       	adc	r25, r25
    41b0:	88 0f       	add	r24, r24
    41b2:	99 1f       	adc	r25, r25
    41b4:	88 0f       	add	r24, r24
    41b6:	99 1f       	adc	r25, r25
    41b8:	82 0f       	add	r24, r18
    41ba:	93 1f       	adc	r25, r19
    41bc:	fc 01       	movw	r30, r24
    41be:	ea 58       	subi	r30, 0x8A	; 138
    41c0:	f9 4f       	sbci	r31, 0xF9	; 249
    41c2:	80 81       	ld	r24, Z
    41c4:	8f 5f       	subi	r24, 0xFF	; 255
    41c6:	80 83       	st	Z, r24
    41c8:	30 c0       	rjmp	.+96     	; 0x422a <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    41ca:	80 91 b1 06 	lds	r24, 0x06B1
    41ce:	90 91 b2 06 	lds	r25, 0x06B2
    41d2:	9a 83       	std	Y+2, r25	; 0x02
    41d4:	89 83       	std	Y+1, r24	; 0x01
    41d6:	ea 85       	ldd	r30, Y+10	; 0x0a
    41d8:	fb 85       	ldd	r31, Y+11	; 0x0b
    41da:	89 81       	ldd	r24, Y+1	; 0x01
    41dc:	9a 81       	ldd	r25, Y+2	; 0x02
    41de:	97 87       	std	Z+15, r25	; 0x0f
    41e0:	86 87       	std	Z+14, r24	; 0x0e
    41e2:	e9 81       	ldd	r30, Y+1	; 0x01
    41e4:	fa 81       	ldd	r31, Y+2	; 0x02
    41e6:	84 81       	ldd	r24, Z+4	; 0x04
    41e8:	95 81       	ldd	r25, Z+5	; 0x05
    41ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    41ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    41ee:	91 8b       	std	Z+17, r25	; 0x11
    41f0:	80 8b       	std	Z+16, r24	; 0x10
    41f2:	e9 81       	ldd	r30, Y+1	; 0x01
    41f4:	fa 81       	ldd	r31, Y+2	; 0x02
    41f6:	04 80       	ldd	r0, Z+4	; 0x04
    41f8:	f5 81       	ldd	r31, Z+5	; 0x05
    41fa:	e0 2d       	mov	r30, r0
    41fc:	8a 85       	ldd	r24, Y+10	; 0x0a
    41fe:	9b 85       	ldd	r25, Y+11	; 0x0b
    4200:	0c 96       	adiw	r24, 0x0c	; 12
    4202:	93 83       	std	Z+3, r25	; 0x03
    4204:	82 83       	std	Z+2, r24	; 0x02
    4206:	8a 85       	ldd	r24, Y+10	; 0x0a
    4208:	9b 85       	ldd	r25, Y+11	; 0x0b
    420a:	0c 96       	adiw	r24, 0x0c	; 12
    420c:	e9 81       	ldd	r30, Y+1	; 0x01
    420e:	fa 81       	ldd	r31, Y+2	; 0x02
    4210:	95 83       	std	Z+5, r25	; 0x05
    4212:	84 83       	std	Z+4, r24	; 0x04
    4214:	ea 85       	ldd	r30, Y+10	; 0x0a
    4216:	fb 85       	ldd	r31, Y+11	; 0x0b
    4218:	80 eb       	ldi	r24, 0xB0	; 176
    421a:	96 e0       	ldi	r25, 0x06	; 6
    421c:	95 8b       	std	Z+21, r25	; 0x15
    421e:	84 8b       	std	Z+20, r24	; 0x14
    4220:	80 91 b0 06 	lds	r24, 0x06B0
    4224:	8f 5f       	subi	r24, 0xFF	; 255
    4226:	80 93 b0 06 	sts	0x06B0, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    422a:	ea 85       	ldd	r30, Y+10	; 0x0a
    422c:	fb 85       	ldd	r31, Y+11	; 0x0b
    422e:	96 89       	ldd	r25, Z+22	; 0x16
    4230:	e0 91 64 06 	lds	r30, 0x0664
    4234:	f0 91 65 06 	lds	r31, 0x0665
    4238:	86 89       	ldd	r24, Z+22	; 0x16
    423a:	89 17       	cp	r24, r25
    423c:	30 f4       	brcc	.+12     	; 0x424a <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    423e:	81 e0       	ldi	r24, 0x01	; 1
    4240:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    4242:	81 e0       	ldi	r24, 0x01	; 1
    4244:	80 93 6e 06 	sts	0x066E, r24
    4248:	01 c0       	rjmp	.+2      	; 0x424c <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    424a:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    424c:	89 85       	ldd	r24, Y+9	; 0x09
}
    424e:	2d 96       	adiw	r28, 0x0d	; 13
    4250:	0f b6       	in	r0, 0x3f	; 63
    4252:	f8 94       	cli
    4254:	de bf       	out	0x3e, r29	; 62
    4256:	0f be       	out	0x3f, r0	; 63
    4258:	cd bf       	out	0x3d, r28	; 61
    425a:	cf 91       	pop	r28
    425c:	df 91       	pop	r29
    425e:	08 95       	ret

00004260 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    4260:	df 93       	push	r29
    4262:	cf 93       	push	r28
    4264:	cd b7       	in	r28, 0x3d	; 61
    4266:	de b7       	in	r29, 0x3e	; 62
    4268:	2c 97       	sbiw	r28, 0x0c	; 12
    426a:	0f b6       	in	r0, 0x3f	; 63
    426c:	f8 94       	cli
    426e:	de bf       	out	0x3e, r29	; 62
    4270:	0f be       	out	0x3f, r0	; 63
    4272:	cd bf       	out	0x3d, r28	; 61
    4274:	9a 87       	std	Y+10, r25	; 0x0a
    4276:	89 87       	std	Y+9, r24	; 0x09
    4278:	7c 87       	std	Y+12, r23	; 0x0c
    427a:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    427c:	8b 85       	ldd	r24, Y+11	; 0x0b
    427e:	9c 85       	ldd	r25, Y+12	; 0x0c
    4280:	90 68       	ori	r25, 0x80	; 128
    4282:	e9 85       	ldd	r30, Y+9	; 0x09
    4284:	fa 85       	ldd	r31, Y+10	; 0x0a
    4286:	91 83       	std	Z+1, r25	; 0x01
    4288:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    428a:	e9 85       	ldd	r30, Y+9	; 0x09
    428c:	fa 85       	ldd	r31, Y+10	; 0x0a
    428e:	86 81       	ldd	r24, Z+6	; 0x06
    4290:	97 81       	ldd	r25, Z+7	; 0x07
    4292:	98 87       	std	Y+8, r25	; 0x08
    4294:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    4296:	e9 85       	ldd	r30, Y+9	; 0x09
    4298:	fa 85       	ldd	r31, Y+10	; 0x0a
    429a:	80 85       	ldd	r24, Z+8	; 0x08
    429c:	91 85       	ldd	r25, Z+9	; 0x09
    429e:	9e 83       	std	Y+6, r25	; 0x06
    42a0:	8d 83       	std	Y+5, r24	; 0x05
    42a2:	e9 85       	ldd	r30, Y+9	; 0x09
    42a4:	fa 85       	ldd	r31, Y+10	; 0x0a
    42a6:	a2 81       	ldd	r26, Z+2	; 0x02
    42a8:	b3 81       	ldd	r27, Z+3	; 0x03
    42aa:	e9 85       	ldd	r30, Y+9	; 0x09
    42ac:	fa 85       	ldd	r31, Y+10	; 0x0a
    42ae:	84 81       	ldd	r24, Z+4	; 0x04
    42b0:	95 81       	ldd	r25, Z+5	; 0x05
    42b2:	15 96       	adiw	r26, 0x05	; 5
    42b4:	9c 93       	st	X, r25
    42b6:	8e 93       	st	-X, r24
    42b8:	14 97       	sbiw	r26, 0x04	; 4
    42ba:	e9 85       	ldd	r30, Y+9	; 0x09
    42bc:	fa 85       	ldd	r31, Y+10	; 0x0a
    42be:	a4 81       	ldd	r26, Z+4	; 0x04
    42c0:	b5 81       	ldd	r27, Z+5	; 0x05
    42c2:	e9 85       	ldd	r30, Y+9	; 0x09
    42c4:	fa 85       	ldd	r31, Y+10	; 0x0a
    42c6:	82 81       	ldd	r24, Z+2	; 0x02
    42c8:	93 81       	ldd	r25, Z+3	; 0x03
    42ca:	13 96       	adiw	r26, 0x03	; 3
    42cc:	9c 93       	st	X, r25
    42ce:	8e 93       	st	-X, r24
    42d0:	12 97       	sbiw	r26, 0x02	; 2
    42d2:	ed 81       	ldd	r30, Y+5	; 0x05
    42d4:	fe 81       	ldd	r31, Y+6	; 0x06
    42d6:	21 81       	ldd	r18, Z+1	; 0x01
    42d8:	32 81       	ldd	r19, Z+2	; 0x02
    42da:	89 85       	ldd	r24, Y+9	; 0x09
    42dc:	9a 85       	ldd	r25, Y+10	; 0x0a
    42de:	28 17       	cp	r18, r24
    42e0:	39 07       	cpc	r19, r25
    42e2:	41 f4       	brne	.+16     	; 0x42f4 <vTaskRemoveFromUnorderedEventList+0x94>
    42e4:	e9 85       	ldd	r30, Y+9	; 0x09
    42e6:	fa 85       	ldd	r31, Y+10	; 0x0a
    42e8:	84 81       	ldd	r24, Z+4	; 0x04
    42ea:	95 81       	ldd	r25, Z+5	; 0x05
    42ec:	ed 81       	ldd	r30, Y+5	; 0x05
    42ee:	fe 81       	ldd	r31, Y+6	; 0x06
    42f0:	92 83       	std	Z+2, r25	; 0x02
    42f2:	81 83       	std	Z+1, r24	; 0x01
    42f4:	e9 85       	ldd	r30, Y+9	; 0x09
    42f6:	fa 85       	ldd	r31, Y+10	; 0x0a
    42f8:	11 86       	std	Z+9, r1	; 0x09
    42fa:	10 86       	std	Z+8, r1	; 0x08
    42fc:	ed 81       	ldd	r30, Y+5	; 0x05
    42fe:	fe 81       	ldd	r31, Y+6	; 0x06
    4300:	80 81       	ld	r24, Z
    4302:	81 50       	subi	r24, 0x01	; 1
    4304:	ed 81       	ldd	r30, Y+5	; 0x05
    4306:	fe 81       	ldd	r31, Y+6	; 0x06
    4308:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    430a:	ef 81       	ldd	r30, Y+7	; 0x07
    430c:	f8 85       	ldd	r31, Y+8	; 0x08
    430e:	82 85       	ldd	r24, Z+10	; 0x0a
    4310:	93 85       	ldd	r25, Z+11	; 0x0b
    4312:	9c 83       	std	Y+4, r25	; 0x04
    4314:	8b 83       	std	Y+3, r24	; 0x03
    4316:	ef 81       	ldd	r30, Y+7	; 0x07
    4318:	f8 85       	ldd	r31, Y+8	; 0x08
    431a:	a4 81       	ldd	r26, Z+4	; 0x04
    431c:	b5 81       	ldd	r27, Z+5	; 0x05
    431e:	ef 81       	ldd	r30, Y+7	; 0x07
    4320:	f8 85       	ldd	r31, Y+8	; 0x08
    4322:	86 81       	ldd	r24, Z+6	; 0x06
    4324:	97 81       	ldd	r25, Z+7	; 0x07
    4326:	15 96       	adiw	r26, 0x05	; 5
    4328:	9c 93       	st	X, r25
    432a:	8e 93       	st	-X, r24
    432c:	14 97       	sbiw	r26, 0x04	; 4
    432e:	ef 81       	ldd	r30, Y+7	; 0x07
    4330:	f8 85       	ldd	r31, Y+8	; 0x08
    4332:	a6 81       	ldd	r26, Z+6	; 0x06
    4334:	b7 81       	ldd	r27, Z+7	; 0x07
    4336:	ef 81       	ldd	r30, Y+7	; 0x07
    4338:	f8 85       	ldd	r31, Y+8	; 0x08
    433a:	84 81       	ldd	r24, Z+4	; 0x04
    433c:	95 81       	ldd	r25, Z+5	; 0x05
    433e:	13 96       	adiw	r26, 0x03	; 3
    4340:	9c 93       	st	X, r25
    4342:	8e 93       	st	-X, r24
    4344:	12 97       	sbiw	r26, 0x02	; 2
    4346:	eb 81       	ldd	r30, Y+3	; 0x03
    4348:	fc 81       	ldd	r31, Y+4	; 0x04
    434a:	21 81       	ldd	r18, Z+1	; 0x01
    434c:	32 81       	ldd	r19, Z+2	; 0x02
    434e:	8f 81       	ldd	r24, Y+7	; 0x07
    4350:	98 85       	ldd	r25, Y+8	; 0x08
    4352:	02 96       	adiw	r24, 0x02	; 2
    4354:	28 17       	cp	r18, r24
    4356:	39 07       	cpc	r19, r25
    4358:	41 f4       	brne	.+16     	; 0x436a <vTaskRemoveFromUnorderedEventList+0x10a>
    435a:	ef 81       	ldd	r30, Y+7	; 0x07
    435c:	f8 85       	ldd	r31, Y+8	; 0x08
    435e:	86 81       	ldd	r24, Z+6	; 0x06
    4360:	97 81       	ldd	r25, Z+7	; 0x07
    4362:	eb 81       	ldd	r30, Y+3	; 0x03
    4364:	fc 81       	ldd	r31, Y+4	; 0x04
    4366:	92 83       	std	Z+2, r25	; 0x02
    4368:	81 83       	std	Z+1, r24	; 0x01
    436a:	ef 81       	ldd	r30, Y+7	; 0x07
    436c:	f8 85       	ldd	r31, Y+8	; 0x08
    436e:	13 86       	std	Z+11, r1	; 0x0b
    4370:	12 86       	std	Z+10, r1	; 0x0a
    4372:	eb 81       	ldd	r30, Y+3	; 0x03
    4374:	fc 81       	ldd	r31, Y+4	; 0x04
    4376:	80 81       	ld	r24, Z
    4378:	81 50       	subi	r24, 0x01	; 1
    437a:	eb 81       	ldd	r30, Y+3	; 0x03
    437c:	fc 81       	ldd	r31, Y+4	; 0x04
    437e:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    4380:	ef 81       	ldd	r30, Y+7	; 0x07
    4382:	f8 85       	ldd	r31, Y+8	; 0x08
    4384:	96 89       	ldd	r25, Z+22	; 0x16
    4386:	80 91 6a 06 	lds	r24, 0x066A
    438a:	89 17       	cp	r24, r25
    438c:	28 f4       	brcc	.+10     	; 0x4398 <vTaskRemoveFromUnorderedEventList+0x138>
    438e:	ef 81       	ldd	r30, Y+7	; 0x07
    4390:	f8 85       	ldd	r31, Y+8	; 0x08
    4392:	86 89       	ldd	r24, Z+22	; 0x16
    4394:	80 93 6a 06 	sts	0x066A, r24
    4398:	ef 81       	ldd	r30, Y+7	; 0x07
    439a:	f8 85       	ldd	r31, Y+8	; 0x08
    439c:	86 89       	ldd	r24, Z+22	; 0x16
    439e:	28 2f       	mov	r18, r24
    43a0:	30 e0       	ldi	r19, 0x00	; 0
    43a2:	c9 01       	movw	r24, r18
    43a4:	88 0f       	add	r24, r24
    43a6:	99 1f       	adc	r25, r25
    43a8:	88 0f       	add	r24, r24
    43aa:	99 1f       	adc	r25, r25
    43ac:	88 0f       	add	r24, r24
    43ae:	99 1f       	adc	r25, r25
    43b0:	82 0f       	add	r24, r18
    43b2:	93 1f       	adc	r25, r19
    43b4:	fc 01       	movw	r30, r24
    43b6:	ea 58       	subi	r30, 0x8A	; 138
    43b8:	f9 4f       	sbci	r31, 0xF9	; 249
    43ba:	81 81       	ldd	r24, Z+1	; 0x01
    43bc:	92 81       	ldd	r25, Z+2	; 0x02
    43be:	9a 83       	std	Y+2, r25	; 0x02
    43c0:	89 83       	std	Y+1, r24	; 0x01
    43c2:	ef 81       	ldd	r30, Y+7	; 0x07
    43c4:	f8 85       	ldd	r31, Y+8	; 0x08
    43c6:	89 81       	ldd	r24, Y+1	; 0x01
    43c8:	9a 81       	ldd	r25, Y+2	; 0x02
    43ca:	95 83       	std	Z+5, r25	; 0x05
    43cc:	84 83       	std	Z+4, r24	; 0x04
    43ce:	e9 81       	ldd	r30, Y+1	; 0x01
    43d0:	fa 81       	ldd	r31, Y+2	; 0x02
    43d2:	84 81       	ldd	r24, Z+4	; 0x04
    43d4:	95 81       	ldd	r25, Z+5	; 0x05
    43d6:	ef 81       	ldd	r30, Y+7	; 0x07
    43d8:	f8 85       	ldd	r31, Y+8	; 0x08
    43da:	97 83       	std	Z+7, r25	; 0x07
    43dc:	86 83       	std	Z+6, r24	; 0x06
    43de:	e9 81       	ldd	r30, Y+1	; 0x01
    43e0:	fa 81       	ldd	r31, Y+2	; 0x02
    43e2:	04 80       	ldd	r0, Z+4	; 0x04
    43e4:	f5 81       	ldd	r31, Z+5	; 0x05
    43e6:	e0 2d       	mov	r30, r0
    43e8:	8f 81       	ldd	r24, Y+7	; 0x07
    43ea:	98 85       	ldd	r25, Y+8	; 0x08
    43ec:	02 96       	adiw	r24, 0x02	; 2
    43ee:	93 83       	std	Z+3, r25	; 0x03
    43f0:	82 83       	std	Z+2, r24	; 0x02
    43f2:	8f 81       	ldd	r24, Y+7	; 0x07
    43f4:	98 85       	ldd	r25, Y+8	; 0x08
    43f6:	02 96       	adiw	r24, 0x02	; 2
    43f8:	e9 81       	ldd	r30, Y+1	; 0x01
    43fa:	fa 81       	ldd	r31, Y+2	; 0x02
    43fc:	95 83       	std	Z+5, r25	; 0x05
    43fe:	84 83       	std	Z+4, r24	; 0x04
    4400:	ef 81       	ldd	r30, Y+7	; 0x07
    4402:	f8 85       	ldd	r31, Y+8	; 0x08
    4404:	86 89       	ldd	r24, Z+22	; 0x16
    4406:	28 2f       	mov	r18, r24
    4408:	30 e0       	ldi	r19, 0x00	; 0
    440a:	c9 01       	movw	r24, r18
    440c:	88 0f       	add	r24, r24
    440e:	99 1f       	adc	r25, r25
    4410:	88 0f       	add	r24, r24
    4412:	99 1f       	adc	r25, r25
    4414:	88 0f       	add	r24, r24
    4416:	99 1f       	adc	r25, r25
    4418:	82 0f       	add	r24, r18
    441a:	93 1f       	adc	r25, r19
    441c:	8a 58       	subi	r24, 0x8A	; 138
    441e:	99 4f       	sbci	r25, 0xF9	; 249
    4420:	ef 81       	ldd	r30, Y+7	; 0x07
    4422:	f8 85       	ldd	r31, Y+8	; 0x08
    4424:	93 87       	std	Z+11, r25	; 0x0b
    4426:	82 87       	std	Z+10, r24	; 0x0a
    4428:	ef 81       	ldd	r30, Y+7	; 0x07
    442a:	f8 85       	ldd	r31, Y+8	; 0x08
    442c:	86 89       	ldd	r24, Z+22	; 0x16
    442e:	28 2f       	mov	r18, r24
    4430:	30 e0       	ldi	r19, 0x00	; 0
    4432:	c9 01       	movw	r24, r18
    4434:	88 0f       	add	r24, r24
    4436:	99 1f       	adc	r25, r25
    4438:	88 0f       	add	r24, r24
    443a:	99 1f       	adc	r25, r25
    443c:	88 0f       	add	r24, r24
    443e:	99 1f       	adc	r25, r25
    4440:	82 0f       	add	r24, r18
    4442:	93 1f       	adc	r25, r19
    4444:	fc 01       	movw	r30, r24
    4446:	ea 58       	subi	r30, 0x8A	; 138
    4448:	f9 4f       	sbci	r31, 0xF9	; 249
    444a:	80 81       	ld	r24, Z
    444c:	8f 5f       	subi	r24, 0xFF	; 255
    444e:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4450:	ef 81       	ldd	r30, Y+7	; 0x07
    4452:	f8 85       	ldd	r31, Y+8	; 0x08
    4454:	96 89       	ldd	r25, Z+22	; 0x16
    4456:	e0 91 64 06 	lds	r30, 0x0664
    445a:	f0 91 65 06 	lds	r31, 0x0665
    445e:	86 89       	ldd	r24, Z+22	; 0x16
    4460:	89 17       	cp	r24, r25
    4462:	18 f4       	brcc	.+6      	; 0x446a <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    4464:	81 e0       	ldi	r24, 0x01	; 1
    4466:	80 93 6e 06 	sts	0x066E, r24
    }
}
    446a:	2c 96       	adiw	r28, 0x0c	; 12
    446c:	0f b6       	in	r0, 0x3f	; 63
    446e:	f8 94       	cli
    4470:	de bf       	out	0x3e, r29	; 62
    4472:	0f be       	out	0x3f, r0	; 63
    4474:	cd bf       	out	0x3d, r28	; 61
    4476:	cf 91       	pop	r28
    4478:	df 91       	pop	r29
    447a:	08 95       	ret

0000447c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    447c:	df 93       	push	r29
    447e:	cf 93       	push	r28
    4480:	00 d0       	rcall	.+0      	; 0x4482 <vTaskSetTimeOutState+0x6>
    4482:	cd b7       	in	r28, 0x3d	; 61
    4484:	de b7       	in	r29, 0x3e	; 62
    4486:	9a 83       	std	Y+2, r25	; 0x02
    4488:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    448a:	0f b6       	in	r0, 0x3f	; 63
    448c:	f8 94       	cli
    448e:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    4490:	80 91 6f 06 	lds	r24, 0x066F
    4494:	e9 81       	ldd	r30, Y+1	; 0x01
    4496:	fa 81       	ldd	r31, Y+2	; 0x02
    4498:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    449a:	80 91 68 06 	lds	r24, 0x0668
    449e:	90 91 69 06 	lds	r25, 0x0669
    44a2:	e9 81       	ldd	r30, Y+1	; 0x01
    44a4:	fa 81       	ldd	r31, Y+2	; 0x02
    44a6:	92 83       	std	Z+2, r25	; 0x02
    44a8:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    44aa:	0f 90       	pop	r0
    44ac:	0f be       	out	0x3f, r0	; 63
}
    44ae:	0f 90       	pop	r0
    44b0:	0f 90       	pop	r0
    44b2:	cf 91       	pop	r28
    44b4:	df 91       	pop	r29
    44b6:	08 95       	ret

000044b8 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    44b8:	df 93       	push	r29
    44ba:	cf 93       	push	r28
    44bc:	00 d0       	rcall	.+0      	; 0x44be <vTaskInternalSetTimeOutState+0x6>
    44be:	cd b7       	in	r28, 0x3d	; 61
    44c0:	de b7       	in	r29, 0x3e	; 62
    44c2:	9a 83       	std	Y+2, r25	; 0x02
    44c4:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    44c6:	80 91 6f 06 	lds	r24, 0x066F
    44ca:	e9 81       	ldd	r30, Y+1	; 0x01
    44cc:	fa 81       	ldd	r31, Y+2	; 0x02
    44ce:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    44d0:	80 91 68 06 	lds	r24, 0x0668
    44d4:	90 91 69 06 	lds	r25, 0x0669
    44d8:	e9 81       	ldd	r30, Y+1	; 0x01
    44da:	fa 81       	ldd	r31, Y+2	; 0x02
    44dc:	92 83       	std	Z+2, r25	; 0x02
    44de:	81 83       	std	Z+1, r24	; 0x01
}
    44e0:	0f 90       	pop	r0
    44e2:	0f 90       	pop	r0
    44e4:	cf 91       	pop	r28
    44e6:	df 91       	pop	r29
    44e8:	08 95       	ret

000044ea <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    44ea:	df 93       	push	r29
    44ec:	cf 93       	push	r28
    44ee:	cd b7       	in	r28, 0x3d	; 61
    44f0:	de b7       	in	r29, 0x3e	; 62
    44f2:	29 97       	sbiw	r28, 0x09	; 9
    44f4:	0f b6       	in	r0, 0x3f	; 63
    44f6:	f8 94       	cli
    44f8:	de bf       	out	0x3e, r29	; 62
    44fa:	0f be       	out	0x3f, r0	; 63
    44fc:	cd bf       	out	0x3d, r28	; 61
    44fe:	9f 83       	std	Y+7, r25	; 0x07
    4500:	8e 83       	std	Y+6, r24	; 0x06
    4502:	79 87       	std	Y+9, r23	; 0x09
    4504:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    4506:	0f b6       	in	r0, 0x3f	; 63
    4508:	f8 94       	cli
    450a:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    450c:	80 91 68 06 	lds	r24, 0x0668
    4510:	90 91 69 06 	lds	r25, 0x0669
    4514:	9c 83       	std	Y+4, r25	; 0x04
    4516:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4518:	ee 81       	ldd	r30, Y+6	; 0x06
    451a:	ff 81       	ldd	r31, Y+7	; 0x07
    451c:	21 81       	ldd	r18, Z+1	; 0x01
    451e:	32 81       	ldd	r19, Z+2	; 0x02
    4520:	8b 81       	ldd	r24, Y+3	; 0x03
    4522:	9c 81       	ldd	r25, Y+4	; 0x04
    4524:	82 1b       	sub	r24, r18
    4526:	93 0b       	sbc	r25, r19
    4528:	9a 83       	std	Y+2, r25	; 0x02
    452a:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    452c:	ee 81       	ldd	r30, Y+6	; 0x06
    452e:	ff 81       	ldd	r31, Y+7	; 0x07
    4530:	90 81       	ld	r25, Z
    4532:	80 91 6f 06 	lds	r24, 0x066F
    4536:	98 17       	cp	r25, r24
    4538:	81 f0       	breq	.+32     	; 0x455a <xTaskCheckForTimeOut+0x70>
    453a:	ee 81       	ldd	r30, Y+6	; 0x06
    453c:	ff 81       	ldd	r31, Y+7	; 0x07
    453e:	21 81       	ldd	r18, Z+1	; 0x01
    4540:	32 81       	ldd	r19, Z+2	; 0x02
    4542:	8b 81       	ldd	r24, Y+3	; 0x03
    4544:	9c 81       	ldd	r25, Y+4	; 0x04
    4546:	82 17       	cp	r24, r18
    4548:	93 07       	cpc	r25, r19
    454a:	38 f0       	brcs	.+14     	; 0x455a <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    454c:	81 e0       	ldi	r24, 0x01	; 1
    454e:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    4550:	e8 85       	ldd	r30, Y+8	; 0x08
    4552:	f9 85       	ldd	r31, Y+9	; 0x09
    4554:	11 82       	std	Z+1, r1	; 0x01
    4556:	10 82       	st	Z, r1
    4558:	23 c0       	rjmp	.+70     	; 0x45a0 <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    455a:	e8 85       	ldd	r30, Y+8	; 0x08
    455c:	f9 85       	ldd	r31, Y+9	; 0x09
    455e:	20 81       	ld	r18, Z
    4560:	31 81       	ldd	r19, Z+1	; 0x01
    4562:	89 81       	ldd	r24, Y+1	; 0x01
    4564:	9a 81       	ldd	r25, Y+2	; 0x02
    4566:	82 17       	cp	r24, r18
    4568:	93 07       	cpc	r25, r19
    456a:	a0 f4       	brcc	.+40     	; 0x4594 <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    456c:	e8 85       	ldd	r30, Y+8	; 0x08
    456e:	f9 85       	ldd	r31, Y+9	; 0x09
    4570:	20 81       	ld	r18, Z
    4572:	31 81       	ldd	r19, Z+1	; 0x01
    4574:	89 81       	ldd	r24, Y+1	; 0x01
    4576:	9a 81       	ldd	r25, Y+2	; 0x02
    4578:	a9 01       	movw	r20, r18
    457a:	48 1b       	sub	r20, r24
    457c:	59 0b       	sbc	r21, r25
    457e:	ca 01       	movw	r24, r20
    4580:	e8 85       	ldd	r30, Y+8	; 0x08
    4582:	f9 85       	ldd	r31, Y+9	; 0x09
    4584:	91 83       	std	Z+1, r25	; 0x01
    4586:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    4588:	8e 81       	ldd	r24, Y+6	; 0x06
    458a:	9f 81       	ldd	r25, Y+7	; 0x07
    458c:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    4590:	1d 82       	std	Y+5, r1	; 0x05
    4592:	06 c0       	rjmp	.+12     	; 0x45a0 <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    4594:	e8 85       	ldd	r30, Y+8	; 0x08
    4596:	f9 85       	ldd	r31, Y+9	; 0x09
    4598:	11 82       	std	Z+1, r1	; 0x01
    459a:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    459c:	81 e0       	ldi	r24, 0x01	; 1
    459e:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    45a0:	0f 90       	pop	r0
    45a2:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    45a4:	8d 81       	ldd	r24, Y+5	; 0x05
}
    45a6:	29 96       	adiw	r28, 0x09	; 9
    45a8:	0f b6       	in	r0, 0x3f	; 63
    45aa:	f8 94       	cli
    45ac:	de bf       	out	0x3e, r29	; 62
    45ae:	0f be       	out	0x3f, r0	; 63
    45b0:	cd bf       	out	0x3d, r28	; 61
    45b2:	cf 91       	pop	r28
    45b4:	df 91       	pop	r29
    45b6:	08 95       	ret

000045b8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    45b8:	df 93       	push	r29
    45ba:	cf 93       	push	r28
    45bc:	cd b7       	in	r28, 0x3d	; 61
    45be:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    45c0:	81 e0       	ldi	r24, 0x01	; 1
    45c2:	80 93 6e 06 	sts	0x066E, r24
}
    45c6:	cf 91       	pop	r28
    45c8:	df 91       	pop	r29
    45ca:	08 95       	ret

000045cc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    45cc:	df 93       	push	r29
    45ce:	cf 93       	push	r28
    45d0:	00 d0       	rcall	.+0      	; 0x45d2 <prvIdleTask+0x6>
    45d2:	cd b7       	in	r28, 0x3d	; 61
    45d4:	de b7       	in	r29, 0x3e	; 62
    45d6:	9a 83       	std	Y+2, r25	; 0x02
    45d8:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    45da:	0e 94 33 23 	call	0x4666	; 0x4666 <prvCheckTasksWaitingTermination>
             *
             * A critical region is not required here as we are just reading from
             * the list, and an occasional incorrect value will not matter.  If
             * the ready list at the idle priority contains more than one task
             * then a task other than the idle task is ready to execute. */
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    45de:	80 91 76 06 	lds	r24, 0x0676
    45e2:	82 30       	cpi	r24, 0x02	; 2
    45e4:	d0 f3       	brcs	.-12     	; 0x45da <prvIdleTask+0xe>
            {
                taskYIELD();
    45e6:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    45ea:	f7 cf       	rjmp	.-18     	; 0x45da <prvIdleTask+0xe>

000045ec <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    45ec:	df 93       	push	r29
    45ee:	cf 93       	push	r28
    45f0:	0f 92       	push	r0
    45f2:	cd b7       	in	r28, 0x3d	; 61
    45f4:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    45f6:	19 82       	std	Y+1, r1	; 0x01
    45f8:	13 c0       	rjmp	.+38     	; 0x4620 <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    45fa:	89 81       	ldd	r24, Y+1	; 0x01
    45fc:	28 2f       	mov	r18, r24
    45fe:	30 e0       	ldi	r19, 0x00	; 0
    4600:	c9 01       	movw	r24, r18
    4602:	88 0f       	add	r24, r24
    4604:	99 1f       	adc	r25, r25
    4606:	88 0f       	add	r24, r24
    4608:	99 1f       	adc	r25, r25
    460a:	88 0f       	add	r24, r24
    460c:	99 1f       	adc	r25, r25
    460e:	82 0f       	add	r24, r18
    4610:	93 1f       	adc	r25, r19
    4612:	8a 58       	subi	r24, 0x8A	; 138
    4614:	99 4f       	sbci	r25, 0xF9	; 249
    4616:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    461a:	89 81       	ldd	r24, Y+1	; 0x01
    461c:	8f 5f       	subi	r24, 0xFF	; 255
    461e:	89 83       	std	Y+1, r24	; 0x01
    4620:	89 81       	ldd	r24, Y+1	; 0x01
    4622:	84 30       	cpi	r24, 0x04	; 4
    4624:	50 f3       	brcs	.-44     	; 0x45fa <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    4626:	8a e9       	ldi	r24, 0x9A	; 154
    4628:	96 e0       	ldi	r25, 0x06	; 6
    462a:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    462e:	83 ea       	ldi	r24, 0xA3	; 163
    4630:	96 e0       	ldi	r25, 0x06	; 6
    4632:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    4636:	80 eb       	ldi	r24, 0xB0	; 176
    4638:	96 e0       	ldi	r25, 0x06	; 6
    463a:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
    463e:	89 eb       	ldi	r24, 0xB9	; 185
    4640:	96 e0       	ldi	r25, 0x06	; 6
    4642:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    4646:	8a e9       	ldi	r24, 0x9A	; 154
    4648:	96 e0       	ldi	r25, 0x06	; 6
    464a:	90 93 ad 06 	sts	0x06AD, r25
    464e:	80 93 ac 06 	sts	0x06AC, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4652:	83 ea       	ldi	r24, 0xA3	; 163
    4654:	96 e0       	ldi	r25, 0x06	; 6
    4656:	90 93 af 06 	sts	0x06AF, r25
    465a:	80 93 ae 06 	sts	0x06AE, r24
}
    465e:	0f 90       	pop	r0
    4660:	cf 91       	pop	r28
    4662:	df 91       	pop	r29
    4664:	08 95       	ret

00004666 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4666:	df 93       	push	r29
    4668:	cf 93       	push	r28
    466a:	00 d0       	rcall	.+0      	; 0x466c <prvCheckTasksWaitingTermination+0x6>
    466c:	cd b7       	in	r28, 0x3d	; 61
    466e:	de b7       	in	r29, 0x3e	; 62
    4670:	20 c0       	rjmp	.+64     	; 0x46b2 <prvCheckTasksWaitingTermination+0x4c>

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
        {
            taskENTER_CRITICAL();
    4672:	0f b6       	in	r0, 0x3f	; 63
    4674:	f8 94       	cli
    4676:	0f 92       	push	r0
            {
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4678:	e0 91 be 06 	lds	r30, 0x06BE
    467c:	f0 91 bf 06 	lds	r31, 0x06BF
    4680:	86 81       	ldd	r24, Z+6	; 0x06
    4682:	97 81       	ldd	r25, Z+7	; 0x07
    4684:	9a 83       	std	Y+2, r25	; 0x02
    4686:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4688:	89 81       	ldd	r24, Y+1	; 0x01
    468a:	9a 81       	ldd	r25, Y+2	; 0x02
    468c:	02 96       	adiw	r24, 0x02	; 2
    468e:	0e 94 cc 07 	call	0xf98	; 0xf98 <uxListRemove>
                --uxCurrentNumberOfTasks;
    4692:	80 91 67 06 	lds	r24, 0x0667
    4696:	81 50       	subi	r24, 0x01	; 1
    4698:	80 93 67 06 	sts	0x0667, r24
                --uxDeletedTasksWaitingCleanUp;
    469c:	80 91 66 06 	lds	r24, 0x0666
    46a0:	81 50       	subi	r24, 0x01	; 1
    46a2:	80 93 66 06 	sts	0x0666, r24
            }
            taskEXIT_CRITICAL();
    46a6:	0f 90       	pop	r0
    46a8:	0f be       	out	0x3f, r0	; 63

            prvDeleteTCB( pxTCB );
    46aa:	89 81       	ldd	r24, Y+1	; 0x01
    46ac:	9a 81       	ldd	r25, Y+2	; 0x02
    46ae:	0e 94 62 23 	call	0x46c4	; 0x46c4 <prvDeleteTCB>
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    46b2:	80 91 66 06 	lds	r24, 0x0666
    46b6:	88 23       	and	r24, r24
    46b8:	e1 f6       	brne	.-72     	; 0x4672 <prvCheckTasksWaitingTermination+0xc>

            prvDeleteTCB( pxTCB );
        }
    }
    #endif /* INCLUDE_vTaskDelete */
}
    46ba:	0f 90       	pop	r0
    46bc:	0f 90       	pop	r0
    46be:	cf 91       	pop	r28
    46c0:	df 91       	pop	r29
    46c2:	08 95       	ret

000046c4 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    46c4:	df 93       	push	r29
    46c6:	cf 93       	push	r28
    46c8:	00 d0       	rcall	.+0      	; 0x46ca <prvDeleteTCB+0x6>
    46ca:	cd b7       	in	r28, 0x3d	; 61
    46cc:	de b7       	in	r29, 0x3e	; 62
    46ce:	9a 83       	std	Y+2, r25	; 0x02
    46d0:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
    46d2:	e9 81       	ldd	r30, Y+1	; 0x01
    46d4:	fa 81       	ldd	r31, Y+2	; 0x02
    46d6:	87 89       	ldd	r24, Z+23	; 0x17
    46d8:	90 8d       	ldd	r25, Z+24	; 0x18
    46da:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
            vPortFree( pxTCB );
    46de:	89 81       	ldd	r24, Y+1	; 0x01
    46e0:	9a 81       	ldd	r25, Y+2	; 0x02
    46e2:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    46e6:	0f 90       	pop	r0
    46e8:	0f 90       	pop	r0
    46ea:	cf 91       	pop	r28
    46ec:	df 91       	pop	r29
    46ee:	08 95       	ret

000046f0 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    46f0:	df 93       	push	r29
    46f2:	cf 93       	push	r28
    46f4:	cd b7       	in	r28, 0x3d	; 61
    46f6:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    46f8:	e0 91 ac 06 	lds	r30, 0x06AC
    46fc:	f0 91 ad 06 	lds	r31, 0x06AD
    4700:	80 81       	ld	r24, Z
    4702:	88 23       	and	r24, r24
    4704:	39 f4       	brne	.+14     	; 0x4714 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    4706:	8f ef       	ldi	r24, 0xFF	; 255
    4708:	9f ef       	ldi	r25, 0xFF	; 255
    470a:	90 93 72 06 	sts	0x0672, r25
    470e:	80 93 71 06 	sts	0x0671, r24
    4712:	0d c0       	rjmp	.+26     	; 0x472e <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    4714:	e0 91 ac 06 	lds	r30, 0x06AC
    4718:	f0 91 ad 06 	lds	r31, 0x06AD
    471c:	05 80       	ldd	r0, Z+5	; 0x05
    471e:	f6 81       	ldd	r31, Z+6	; 0x06
    4720:	e0 2d       	mov	r30, r0
    4722:	80 81       	ld	r24, Z
    4724:	91 81       	ldd	r25, Z+1	; 0x01
    4726:	90 93 72 06 	sts	0x0672, r25
    472a:	80 93 71 06 	sts	0x0671, r24
    }
}
    472e:	cf 91       	pop	r28
    4730:	df 91       	pop	r29
    4732:	08 95       	ret

00004734 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
    4734:	df 93       	push	r29
    4736:	cf 93       	push	r28
    4738:	00 d0       	rcall	.+0      	; 0x473a <xTaskGetCurrentTaskHandle+0x6>
    473a:	cd b7       	in	r28, 0x3d	; 61
    473c:	de b7       	in	r29, 0x3e	; 62
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    473e:	80 91 64 06 	lds	r24, 0x0664
    4742:	90 91 65 06 	lds	r25, 0x0665
    4746:	9a 83       	std	Y+2, r25	; 0x02
    4748:	89 83       	std	Y+1, r24	; 0x01

        return xReturn;
    474a:	89 81       	ldd	r24, Y+1	; 0x01
    474c:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    474e:	0f 90       	pop	r0
    4750:	0f 90       	pop	r0
    4752:	cf 91       	pop	r28
    4754:	df 91       	pop	r29
    4756:	08 95       	ret

00004758 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
    4758:	df 93       	push	r29
    475a:	cf 93       	push	r28
    475c:	0f 92       	push	r0
    475e:	cd b7       	in	r28, 0x3d	; 61
    4760:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
    4762:	80 91 6b 06 	lds	r24, 0x066B
    4766:	88 23       	and	r24, r24
    4768:	19 f4       	brne	.+6      	; 0x4770 <xTaskGetSchedulerState+0x18>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
    476a:	81 e0       	ldi	r24, 0x01	; 1
    476c:	89 83       	std	Y+1, r24	; 0x01
    476e:	08 c0       	rjmp	.+16     	; 0x4780 <xTaskGetSchedulerState+0x28>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4770:	80 91 75 06 	lds	r24, 0x0675
    4774:	88 23       	and	r24, r24
    4776:	19 f4       	brne	.+6      	; 0x477e <xTaskGetSchedulerState+0x26>
            {
                xReturn = taskSCHEDULER_RUNNING;
    4778:	82 e0       	ldi	r24, 0x02	; 2
    477a:	89 83       	std	Y+1, r24	; 0x01
    477c:	01 c0       	rjmp	.+2      	; 0x4780 <xTaskGetSchedulerState+0x28>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
    477e:	19 82       	std	Y+1, r1	; 0x01
            }
        }

        return xReturn;
    4780:	89 81       	ldd	r24, Y+1	; 0x01
    }
    4782:	0f 90       	pop	r0
    4784:	cf 91       	pop	r28
    4786:	df 91       	pop	r29
    4788:	08 95       	ret

0000478a <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    478a:	df 93       	push	r29
    478c:	cf 93       	push	r28
    478e:	00 d0       	rcall	.+0      	; 0x4790 <uxTaskResetEventItemValue+0x6>
    4790:	cd b7       	in	r28, 0x3d	; 61
    4792:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4794:	e0 91 64 06 	lds	r30, 0x0664
    4798:	f0 91 65 06 	lds	r31, 0x0665
    479c:	84 85       	ldd	r24, Z+12	; 0x0c
    479e:	95 85       	ldd	r25, Z+13	; 0x0d
    47a0:	9a 83       	std	Y+2, r25	; 0x02
    47a2:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    47a4:	a0 91 64 06 	lds	r26, 0x0664
    47a8:	b0 91 65 06 	lds	r27, 0x0665
    47ac:	e0 91 64 06 	lds	r30, 0x0664
    47b0:	f0 91 65 06 	lds	r31, 0x0665
    47b4:	86 89       	ldd	r24, Z+22	; 0x16
    47b6:	28 2f       	mov	r18, r24
    47b8:	30 e0       	ldi	r19, 0x00	; 0
    47ba:	84 e0       	ldi	r24, 0x04	; 4
    47bc:	90 e0       	ldi	r25, 0x00	; 0
    47be:	82 1b       	sub	r24, r18
    47c0:	93 0b       	sbc	r25, r19
    47c2:	1d 96       	adiw	r26, 0x0d	; 13
    47c4:	9c 93       	st	X, r25
    47c6:	8e 93       	st	-X, r24
    47c8:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    47ca:	89 81       	ldd	r24, Y+1	; 0x01
    47cc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    47ce:	0f 90       	pop	r0
    47d0:	0f 90       	pop	r0
    47d2:	cf 91       	pop	r28
    47d4:	df 91       	pop	r29
    47d6:	08 95       	ret

000047d8 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    47d8:	df 93       	push	r29
    47da:	cf 93       	push	r28
    47dc:	cd b7       	in	r28, 0x3d	; 61
    47de:	de b7       	in	r29, 0x3e	; 62
    47e0:	28 97       	sbiw	r28, 0x08	; 8
    47e2:	0f b6       	in	r0, 0x3f	; 63
    47e4:	f8 94       	cli
    47e6:	de bf       	out	0x3e, r29	; 62
    47e8:	0f be       	out	0x3f, r0	; 63
    47ea:	cd bf       	out	0x3d, r28	; 61
    47ec:	8d 83       	std	Y+5, r24	; 0x05
    47ee:	6e 83       	std	Y+6, r22	; 0x06
    47f0:	58 87       	std	Y+8, r21	; 0x08
    47f2:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    47f4:	0f b6       	in	r0, 0x3f	; 63
    47f6:	f8 94       	cli
    47f8:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    47fa:	20 91 64 06 	lds	r18, 0x0664
    47fe:	30 91 65 06 	lds	r19, 0x0665
    4802:	8d 81       	ldd	r24, Y+5	; 0x05
    4804:	88 2f       	mov	r24, r24
    4806:	90 e0       	ldi	r25, 0x00	; 0
    4808:	88 0f       	add	r24, r24
    480a:	99 1f       	adc	r25, r25
    480c:	88 0f       	add	r24, r24
    480e:	99 1f       	adc	r25, r25
    4810:	82 0f       	add	r24, r18
    4812:	93 1f       	adc	r25, r19
    4814:	fc 01       	movw	r30, r24
    4816:	b1 96       	adiw	r30, 0x21	; 33
    4818:	80 81       	ld	r24, Z
    481a:	91 81       	ldd	r25, Z+1	; 0x01
    481c:	a2 81       	ldd	r26, Z+2	; 0x02
    481e:	b3 81       	ldd	r27, Z+3	; 0x03
    4820:	00 97       	sbiw	r24, 0x00	; 0
    4822:	a1 05       	cpc	r26, r1
    4824:	b1 05       	cpc	r27, r1
    4826:	c1 f4       	brne	.+48     	; 0x4858 <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4828:	20 91 64 06 	lds	r18, 0x0664
    482c:	30 91 65 06 	lds	r19, 0x0665
    4830:	8d 81       	ldd	r24, Y+5	; 0x05
    4832:	88 2f       	mov	r24, r24
    4834:	90 e0       	ldi	r25, 0x00	; 0
    4836:	82 0f       	add	r24, r18
    4838:	93 1f       	adc	r25, r19
    483a:	fc 01       	movw	r30, r24
    483c:	b5 96       	adiw	r30, 0x25	; 37
    483e:	81 e0       	ldi	r24, 0x01	; 1
    4840:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4842:	8f 81       	ldd	r24, Y+7	; 0x07
    4844:	98 85       	ldd	r25, Y+8	; 0x08
    4846:	00 97       	sbiw	r24, 0x00	; 0
    4848:	39 f0       	breq	.+14     	; 0x4858 <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    484a:	8f 81       	ldd	r24, Y+7	; 0x07
    484c:	98 85       	ldd	r25, Y+8	; 0x08
    484e:	61 e0       	ldi	r22, 0x01	; 1
    4850:	0e 94 71 2b 	call	0x56e2	; 0x56e2 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4854:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4858:	0f 90       	pop	r0
    485a:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    485c:	0f b6       	in	r0, 0x3f	; 63
    485e:	f8 94       	cli
    4860:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    4862:	20 91 64 06 	lds	r18, 0x0664
    4866:	30 91 65 06 	lds	r19, 0x0665
    486a:	8d 81       	ldd	r24, Y+5	; 0x05
    486c:	88 2f       	mov	r24, r24
    486e:	90 e0       	ldi	r25, 0x00	; 0
    4870:	88 0f       	add	r24, r24
    4872:	99 1f       	adc	r25, r25
    4874:	88 0f       	add	r24, r24
    4876:	99 1f       	adc	r25, r25
    4878:	82 0f       	add	r24, r18
    487a:	93 1f       	adc	r25, r19
    487c:	fc 01       	movw	r30, r24
    487e:	b1 96       	adiw	r30, 0x21	; 33
    4880:	80 81       	ld	r24, Z
    4882:	91 81       	ldd	r25, Z+1	; 0x01
    4884:	a2 81       	ldd	r26, Z+2	; 0x02
    4886:	b3 81       	ldd	r27, Z+3	; 0x03
    4888:	89 83       	std	Y+1, r24	; 0x01
    488a:	9a 83       	std	Y+2, r25	; 0x02
    488c:	ab 83       	std	Y+3, r26	; 0x03
    488e:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    4890:	89 81       	ldd	r24, Y+1	; 0x01
    4892:	9a 81       	ldd	r25, Y+2	; 0x02
    4894:	ab 81       	ldd	r26, Y+3	; 0x03
    4896:	bc 81       	ldd	r27, Y+4	; 0x04
    4898:	00 97       	sbiw	r24, 0x00	; 0
    489a:	a1 05       	cpc	r26, r1
    489c:	b1 05       	cpc	r27, r1
    489e:	a9 f1       	breq	.+106    	; 0x490a <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    48a0:	8e 81       	ldd	r24, Y+6	; 0x06
    48a2:	88 23       	and	r24, r24
    48a4:	a1 f0       	breq	.+40     	; 0x48ce <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    48a6:	20 91 64 06 	lds	r18, 0x0664
    48aa:	30 91 65 06 	lds	r19, 0x0665
    48ae:	8d 81       	ldd	r24, Y+5	; 0x05
    48b0:	88 2f       	mov	r24, r24
    48b2:	90 e0       	ldi	r25, 0x00	; 0
    48b4:	88 0f       	add	r24, r24
    48b6:	99 1f       	adc	r25, r25
    48b8:	88 0f       	add	r24, r24
    48ba:	99 1f       	adc	r25, r25
    48bc:	82 0f       	add	r24, r18
    48be:	93 1f       	adc	r25, r19
    48c0:	fc 01       	movw	r30, r24
    48c2:	b1 96       	adiw	r30, 0x21	; 33
    48c4:	10 82       	st	Z, r1
    48c6:	11 82       	std	Z+1, r1	; 0x01
    48c8:	12 82       	std	Z+2, r1	; 0x02
    48ca:	13 82       	std	Z+3, r1	; 0x03
    48cc:	1e c0       	rjmp	.+60     	; 0x490a <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    48ce:	e0 91 64 06 	lds	r30, 0x0664
    48d2:	f0 91 65 06 	lds	r31, 0x0665
    48d6:	8d 81       	ldd	r24, Y+5	; 0x05
    48d8:	68 2f       	mov	r22, r24
    48da:	70 e0       	ldi	r23, 0x00	; 0
    48dc:	89 81       	ldd	r24, Y+1	; 0x01
    48de:	9a 81       	ldd	r25, Y+2	; 0x02
    48e0:	ab 81       	ldd	r26, Y+3	; 0x03
    48e2:	bc 81       	ldd	r27, Y+4	; 0x04
    48e4:	9c 01       	movw	r18, r24
    48e6:	ad 01       	movw	r20, r26
    48e8:	21 50       	subi	r18, 0x01	; 1
    48ea:	30 40       	sbci	r19, 0x00	; 0
    48ec:	40 40       	sbci	r20, 0x00	; 0
    48ee:	50 40       	sbci	r21, 0x00	; 0
    48f0:	cb 01       	movw	r24, r22
    48f2:	88 0f       	add	r24, r24
    48f4:	99 1f       	adc	r25, r25
    48f6:	88 0f       	add	r24, r24
    48f8:	99 1f       	adc	r25, r25
    48fa:	8e 0f       	add	r24, r30
    48fc:	9f 1f       	adc	r25, r31
    48fe:	fc 01       	movw	r30, r24
    4900:	b1 96       	adiw	r30, 0x21	; 33
    4902:	20 83       	st	Z, r18
    4904:	31 83       	std	Z+1, r19	; 0x01
    4906:	42 83       	std	Z+2, r20	; 0x02
    4908:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    490a:	20 91 64 06 	lds	r18, 0x0664
    490e:	30 91 65 06 	lds	r19, 0x0665
    4912:	8d 81       	ldd	r24, Y+5	; 0x05
    4914:	88 2f       	mov	r24, r24
    4916:	90 e0       	ldi	r25, 0x00	; 0
    4918:	82 0f       	add	r24, r18
    491a:	93 1f       	adc	r25, r19
    491c:	fc 01       	movw	r30, r24
    491e:	b5 96       	adiw	r30, 0x25	; 37
    4920:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    4922:	0f 90       	pop	r0
    4924:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    4926:	89 81       	ldd	r24, Y+1	; 0x01
    4928:	9a 81       	ldd	r25, Y+2	; 0x02
    492a:	ab 81       	ldd	r26, Y+3	; 0x03
    492c:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    492e:	bc 01       	movw	r22, r24
    4930:	cd 01       	movw	r24, r26
    4932:	28 96       	adiw	r28, 0x08	; 8
    4934:	0f b6       	in	r0, 0x3f	; 63
    4936:	f8 94       	cli
    4938:	de bf       	out	0x3e, r29	; 62
    493a:	0f be       	out	0x3f, r0	; 63
    493c:	cd bf       	out	0x3d, r28	; 61
    493e:	cf 91       	pop	r28
    4940:	df 91       	pop	r29
    4942:	08 95       	ret

00004944 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    4944:	cf 92       	push	r12
    4946:	df 92       	push	r13
    4948:	ef 92       	push	r14
    494a:	ff 92       	push	r15
    494c:	0f 93       	push	r16
    494e:	1f 93       	push	r17
    4950:	df 93       	push	r29
    4952:	cf 93       	push	r28
    4954:	cd b7       	in	r28, 0x3d	; 61
    4956:	de b7       	in	r29, 0x3e	; 62
    4958:	2e 97       	sbiw	r28, 0x0e	; 14
    495a:	0f b6       	in	r0, 0x3f	; 63
    495c:	f8 94       	cli
    495e:	de bf       	out	0x3e, r29	; 62
    4960:	0f be       	out	0x3f, r0	; 63
    4962:	cd bf       	out	0x3d, r28	; 61
    4964:	8a 83       	std	Y+2, r24	; 0x02
    4966:	4b 83       	std	Y+3, r20	; 0x03
    4968:	5c 83       	std	Y+4, r21	; 0x04
    496a:	6d 83       	std	Y+5, r22	; 0x05
    496c:	7e 83       	std	Y+6, r23	; 0x06
    496e:	0f 83       	std	Y+7, r16	; 0x07
    4970:	18 87       	std	Y+8, r17	; 0x08
    4972:	29 87       	std	Y+9, r18	; 0x09
    4974:	3a 87       	std	Y+10, r19	; 0x0a
    4976:	fc 86       	std	Y+12, r15	; 0x0c
    4978:	eb 86       	std	Y+11, r14	; 0x0b
    497a:	de 86       	std	Y+14, r13	; 0x0e
    497c:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    497e:	0f b6       	in	r0, 0x3f	; 63
    4980:	f8 94       	cli
    4982:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4984:	20 91 64 06 	lds	r18, 0x0664
    4988:	30 91 65 06 	lds	r19, 0x0665
    498c:	8a 81       	ldd	r24, Y+2	; 0x02
    498e:	88 2f       	mov	r24, r24
    4990:	90 e0       	ldi	r25, 0x00	; 0
    4992:	82 0f       	add	r24, r18
    4994:	93 1f       	adc	r25, r19
    4996:	fc 01       	movw	r30, r24
    4998:	b5 96       	adiw	r30, 0x25	; 37
    499a:	80 81       	ld	r24, Z
    499c:	82 30       	cpi	r24, 0x02	; 2
    499e:	09 f4       	brne	.+2      	; 0x49a2 <xTaskGenericNotifyWait+0x5e>
    49a0:	47 c0       	rjmp	.+142    	; 0x4a30 <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    49a2:	60 91 64 06 	lds	r22, 0x0664
    49a6:	70 91 65 06 	lds	r23, 0x0665
    49aa:	8a 81       	ldd	r24, Y+2	; 0x02
    49ac:	08 2f       	mov	r16, r24
    49ae:	10 e0       	ldi	r17, 0x00	; 0
    49b0:	8a 81       	ldd	r24, Y+2	; 0x02
    49b2:	88 2f       	mov	r24, r24
    49b4:	90 e0       	ldi	r25, 0x00	; 0
    49b6:	88 0f       	add	r24, r24
    49b8:	99 1f       	adc	r25, r25
    49ba:	88 0f       	add	r24, r24
    49bc:	99 1f       	adc	r25, r25
    49be:	86 0f       	add	r24, r22
    49c0:	97 1f       	adc	r25, r23
    49c2:	fc 01       	movw	r30, r24
    49c4:	b1 96       	adiw	r30, 0x21	; 33
    49c6:	20 81       	ld	r18, Z
    49c8:	31 81       	ldd	r19, Z+1	; 0x01
    49ca:	42 81       	ldd	r20, Z+2	; 0x02
    49cc:	53 81       	ldd	r21, Z+3	; 0x03
    49ce:	8b 81       	ldd	r24, Y+3	; 0x03
    49d0:	9c 81       	ldd	r25, Y+4	; 0x04
    49d2:	ad 81       	ldd	r26, Y+5	; 0x05
    49d4:	be 81       	ldd	r27, Y+6	; 0x06
    49d6:	80 95       	com	r24
    49d8:	90 95       	com	r25
    49da:	a0 95       	com	r26
    49dc:	b0 95       	com	r27
    49de:	28 23       	and	r18, r24
    49e0:	39 23       	and	r19, r25
    49e2:	4a 23       	and	r20, r26
    49e4:	5b 23       	and	r21, r27
    49e6:	c8 01       	movw	r24, r16
    49e8:	88 0f       	add	r24, r24
    49ea:	99 1f       	adc	r25, r25
    49ec:	88 0f       	add	r24, r24
    49ee:	99 1f       	adc	r25, r25
    49f0:	86 0f       	add	r24, r22
    49f2:	97 1f       	adc	r25, r23
    49f4:	fc 01       	movw	r30, r24
    49f6:	b1 96       	adiw	r30, 0x21	; 33
    49f8:	20 83       	st	Z, r18
    49fa:	31 83       	std	Z+1, r19	; 0x01
    49fc:	42 83       	std	Z+2, r20	; 0x02
    49fe:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4a00:	20 91 64 06 	lds	r18, 0x0664
    4a04:	30 91 65 06 	lds	r19, 0x0665
    4a08:	8a 81       	ldd	r24, Y+2	; 0x02
    4a0a:	88 2f       	mov	r24, r24
    4a0c:	90 e0       	ldi	r25, 0x00	; 0
    4a0e:	82 0f       	add	r24, r18
    4a10:	93 1f       	adc	r25, r19
    4a12:	fc 01       	movw	r30, r24
    4a14:	b5 96       	adiw	r30, 0x25	; 37
    4a16:	81 e0       	ldi	r24, 0x01	; 1
    4a18:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4a1a:	8d 85       	ldd	r24, Y+13	; 0x0d
    4a1c:	9e 85       	ldd	r25, Y+14	; 0x0e
    4a1e:	00 97       	sbiw	r24, 0x00	; 0
    4a20:	39 f0       	breq	.+14     	; 0x4a30 <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4a22:	8d 85       	ldd	r24, Y+13	; 0x0d
    4a24:	9e 85       	ldd	r25, Y+14	; 0x0e
    4a26:	61 e0       	ldi	r22, 0x01	; 1
    4a28:	0e 94 71 2b 	call	0x56e2	; 0x56e2 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4a2c:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4a30:	0f 90       	pop	r0
    4a32:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4a34:	0f b6       	in	r0, 0x3f	; 63
    4a36:	f8 94       	cli
    4a38:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    4a3a:	8b 85       	ldd	r24, Y+11	; 0x0b
    4a3c:	9c 85       	ldd	r25, Y+12	; 0x0c
    4a3e:	00 97       	sbiw	r24, 0x00	; 0
    4a40:	c9 f0       	breq	.+50     	; 0x4a74 <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    4a42:	20 91 64 06 	lds	r18, 0x0664
    4a46:	30 91 65 06 	lds	r19, 0x0665
    4a4a:	8a 81       	ldd	r24, Y+2	; 0x02
    4a4c:	88 2f       	mov	r24, r24
    4a4e:	90 e0       	ldi	r25, 0x00	; 0
    4a50:	88 0f       	add	r24, r24
    4a52:	99 1f       	adc	r25, r25
    4a54:	88 0f       	add	r24, r24
    4a56:	99 1f       	adc	r25, r25
    4a58:	82 0f       	add	r24, r18
    4a5a:	93 1f       	adc	r25, r19
    4a5c:	fc 01       	movw	r30, r24
    4a5e:	b1 96       	adiw	r30, 0x21	; 33
    4a60:	80 81       	ld	r24, Z
    4a62:	91 81       	ldd	r25, Z+1	; 0x01
    4a64:	a2 81       	ldd	r26, Z+2	; 0x02
    4a66:	b3 81       	ldd	r27, Z+3	; 0x03
    4a68:	eb 85       	ldd	r30, Y+11	; 0x0b
    4a6a:	fc 85       	ldd	r31, Y+12	; 0x0c
    4a6c:	80 83       	st	Z, r24
    4a6e:	91 83       	std	Z+1, r25	; 0x01
    4a70:	a2 83       	std	Z+2, r26	; 0x02
    4a72:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4a74:	20 91 64 06 	lds	r18, 0x0664
    4a78:	30 91 65 06 	lds	r19, 0x0665
    4a7c:	8a 81       	ldd	r24, Y+2	; 0x02
    4a7e:	88 2f       	mov	r24, r24
    4a80:	90 e0       	ldi	r25, 0x00	; 0
    4a82:	82 0f       	add	r24, r18
    4a84:	93 1f       	adc	r25, r19
    4a86:	fc 01       	movw	r30, r24
    4a88:	b5 96       	adiw	r30, 0x25	; 37
    4a8a:	80 81       	ld	r24, Z
    4a8c:	82 30       	cpi	r24, 0x02	; 2
    4a8e:	11 f0       	breq	.+4      	; 0x4a94 <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    4a90:	19 82       	std	Y+1, r1	; 0x01
    4a92:	31 c0       	rjmp	.+98     	; 0x4af6 <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    4a94:	60 91 64 06 	lds	r22, 0x0664
    4a98:	70 91 65 06 	lds	r23, 0x0665
    4a9c:	8a 81       	ldd	r24, Y+2	; 0x02
    4a9e:	08 2f       	mov	r16, r24
    4aa0:	10 e0       	ldi	r17, 0x00	; 0
    4aa2:	8a 81       	ldd	r24, Y+2	; 0x02
    4aa4:	88 2f       	mov	r24, r24
    4aa6:	90 e0       	ldi	r25, 0x00	; 0
    4aa8:	88 0f       	add	r24, r24
    4aaa:	99 1f       	adc	r25, r25
    4aac:	88 0f       	add	r24, r24
    4aae:	99 1f       	adc	r25, r25
    4ab0:	86 0f       	add	r24, r22
    4ab2:	97 1f       	adc	r25, r23
    4ab4:	fc 01       	movw	r30, r24
    4ab6:	b1 96       	adiw	r30, 0x21	; 33
    4ab8:	20 81       	ld	r18, Z
    4aba:	31 81       	ldd	r19, Z+1	; 0x01
    4abc:	42 81       	ldd	r20, Z+2	; 0x02
    4abe:	53 81       	ldd	r21, Z+3	; 0x03
    4ac0:	8f 81       	ldd	r24, Y+7	; 0x07
    4ac2:	98 85       	ldd	r25, Y+8	; 0x08
    4ac4:	a9 85       	ldd	r26, Y+9	; 0x09
    4ac6:	ba 85       	ldd	r27, Y+10	; 0x0a
    4ac8:	80 95       	com	r24
    4aca:	90 95       	com	r25
    4acc:	a0 95       	com	r26
    4ace:	b0 95       	com	r27
    4ad0:	28 23       	and	r18, r24
    4ad2:	39 23       	and	r19, r25
    4ad4:	4a 23       	and	r20, r26
    4ad6:	5b 23       	and	r21, r27
    4ad8:	c8 01       	movw	r24, r16
    4ada:	88 0f       	add	r24, r24
    4adc:	99 1f       	adc	r25, r25
    4ade:	88 0f       	add	r24, r24
    4ae0:	99 1f       	adc	r25, r25
    4ae2:	86 0f       	add	r24, r22
    4ae4:	97 1f       	adc	r25, r23
    4ae6:	fc 01       	movw	r30, r24
    4ae8:	b1 96       	adiw	r30, 0x21	; 33
    4aea:	20 83       	st	Z, r18
    4aec:	31 83       	std	Z+1, r19	; 0x01
    4aee:	42 83       	std	Z+2, r20	; 0x02
    4af0:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    4af2:	81 e0       	ldi	r24, 0x01	; 1
    4af4:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4af6:	20 91 64 06 	lds	r18, 0x0664
    4afa:	30 91 65 06 	lds	r19, 0x0665
    4afe:	8a 81       	ldd	r24, Y+2	; 0x02
    4b00:	88 2f       	mov	r24, r24
    4b02:	90 e0       	ldi	r25, 0x00	; 0
    4b04:	82 0f       	add	r24, r18
    4b06:	93 1f       	adc	r25, r19
    4b08:	fc 01       	movw	r30, r24
    4b0a:	b5 96       	adiw	r30, 0x25	; 37
    4b0c:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    4b0e:	0f 90       	pop	r0
    4b10:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4b12:	89 81       	ldd	r24, Y+1	; 0x01
    }
    4b14:	2e 96       	adiw	r28, 0x0e	; 14
    4b16:	0f b6       	in	r0, 0x3f	; 63
    4b18:	f8 94       	cli
    4b1a:	de bf       	out	0x3e, r29	; 62
    4b1c:	0f be       	out	0x3f, r0	; 63
    4b1e:	cd bf       	out	0x3d, r28	; 61
    4b20:	cf 91       	pop	r28
    4b22:	df 91       	pop	r29
    4b24:	1f 91       	pop	r17
    4b26:	0f 91       	pop	r16
    4b28:	ff 90       	pop	r15
    4b2a:	ef 90       	pop	r14
    4b2c:	df 90       	pop	r13
    4b2e:	cf 90       	pop	r12
    4b30:	08 95       	ret

00004b32 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    4b32:	ef 92       	push	r14
    4b34:	ff 92       	push	r15
    4b36:	0f 93       	push	r16
    4b38:	1f 93       	push	r17
    4b3a:	df 93       	push	r29
    4b3c:	cf 93       	push	r28
    4b3e:	cd b7       	in	r28, 0x3d	; 61
    4b40:	de b7       	in	r29, 0x3e	; 62
    4b42:	64 97       	sbiw	r28, 0x14	; 20
    4b44:	0f b6       	in	r0, 0x3f	; 63
    4b46:	f8 94       	cli
    4b48:	de bf       	out	0x3e, r29	; 62
    4b4a:	0f be       	out	0x3f, r0	; 63
    4b4c:	cd bf       	out	0x3d, r28	; 61
    4b4e:	9a 87       	std	Y+10, r25	; 0x0a
    4b50:	89 87       	std	Y+9, r24	; 0x09
    4b52:	6b 87       	std	Y+11, r22	; 0x0b
    4b54:	2c 87       	std	Y+12, r18	; 0x0c
    4b56:	3d 87       	std	Y+13, r19	; 0x0d
    4b58:	4e 87       	std	Y+14, r20	; 0x0e
    4b5a:	5f 87       	std	Y+15, r21	; 0x0f
    4b5c:	08 8b       	std	Y+16, r16	; 0x10
    4b5e:	fa 8a       	std	Y+18, r15	; 0x12
    4b60:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    4b62:	81 e0       	ldi	r24, 0x01	; 1
    4b64:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    4b66:	89 85       	ldd	r24, Y+9	; 0x09
    4b68:	9a 85       	ldd	r25, Y+10	; 0x0a
    4b6a:	98 87       	std	Y+8, r25	; 0x08
    4b6c:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    4b6e:	0f b6       	in	r0, 0x3f	; 63
    4b70:	f8 94       	cli
    4b72:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    4b74:	89 89       	ldd	r24, Y+17	; 0x11
    4b76:	9a 89       	ldd	r25, Y+18	; 0x12
    4b78:	00 97       	sbiw	r24, 0x00	; 0
    4b7a:	b9 f0       	breq	.+46     	; 0x4baa <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    4b7c:	8b 85       	ldd	r24, Y+11	; 0x0b
    4b7e:	88 2f       	mov	r24, r24
    4b80:	90 e0       	ldi	r25, 0x00	; 0
    4b82:	2f 81       	ldd	r18, Y+7	; 0x07
    4b84:	38 85       	ldd	r19, Y+8	; 0x08
    4b86:	88 0f       	add	r24, r24
    4b88:	99 1f       	adc	r25, r25
    4b8a:	88 0f       	add	r24, r24
    4b8c:	99 1f       	adc	r25, r25
    4b8e:	82 0f       	add	r24, r18
    4b90:	93 1f       	adc	r25, r19
    4b92:	fc 01       	movw	r30, r24
    4b94:	b1 96       	adiw	r30, 0x21	; 33
    4b96:	80 81       	ld	r24, Z
    4b98:	91 81       	ldd	r25, Z+1	; 0x01
    4b9a:	a2 81       	ldd	r26, Z+2	; 0x02
    4b9c:	b3 81       	ldd	r27, Z+3	; 0x03
    4b9e:	e9 89       	ldd	r30, Y+17	; 0x11
    4ba0:	fa 89       	ldd	r31, Y+18	; 0x12
    4ba2:	80 83       	st	Z, r24
    4ba4:	91 83       	std	Z+1, r25	; 0x01
    4ba6:	a2 83       	std	Z+2, r26	; 0x02
    4ba8:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4baa:	8b 85       	ldd	r24, Y+11	; 0x0b
    4bac:	28 2f       	mov	r18, r24
    4bae:	30 e0       	ldi	r19, 0x00	; 0
    4bb0:	8f 81       	ldd	r24, Y+7	; 0x07
    4bb2:	98 85       	ldd	r25, Y+8	; 0x08
    4bb4:	82 0f       	add	r24, r18
    4bb6:	93 1f       	adc	r25, r19
    4bb8:	fc 01       	movw	r30, r24
    4bba:	b5 96       	adiw	r30, 0x25	; 37
    4bbc:	80 81       	ld	r24, Z
    4bbe:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4bc0:	8b 85       	ldd	r24, Y+11	; 0x0b
    4bc2:	28 2f       	mov	r18, r24
    4bc4:	30 e0       	ldi	r19, 0x00	; 0
    4bc6:	8f 81       	ldd	r24, Y+7	; 0x07
    4bc8:	98 85       	ldd	r25, Y+8	; 0x08
    4bca:	82 0f       	add	r24, r18
    4bcc:	93 1f       	adc	r25, r19
    4bce:	fc 01       	movw	r30, r24
    4bd0:	b5 96       	adiw	r30, 0x25	; 37
    4bd2:	82 e0       	ldi	r24, 0x02	; 2
    4bd4:	80 83       	st	Z, r24

            switch( eAction )
    4bd6:	88 89       	ldd	r24, Y+16	; 0x10
    4bd8:	28 2f       	mov	r18, r24
    4bda:	30 e0       	ldi	r19, 0x00	; 0
    4bdc:	3c 8b       	std	Y+20, r19	; 0x14
    4bde:	2b 8b       	std	Y+19, r18	; 0x13
    4be0:	8b 89       	ldd	r24, Y+19	; 0x13
    4be2:	9c 89       	ldd	r25, Y+20	; 0x14
    4be4:	82 30       	cpi	r24, 0x02	; 2
    4be6:	91 05       	cpc	r25, r1
    4be8:	09 f4       	brne	.+2      	; 0x4bec <xTaskGenericNotify+0xba>
    4bea:	46 c0       	rjmp	.+140    	; 0x4c78 <xTaskGenericNotify+0x146>
    4bec:	2b 89       	ldd	r18, Y+19	; 0x13
    4bee:	3c 89       	ldd	r19, Y+20	; 0x14
    4bf0:	23 30       	cpi	r18, 0x03	; 3
    4bf2:	31 05       	cpc	r19, r1
    4bf4:	34 f4       	brge	.+12     	; 0x4c02 <xTaskGenericNotify+0xd0>
    4bf6:	8b 89       	ldd	r24, Y+19	; 0x13
    4bf8:	9c 89       	ldd	r25, Y+20	; 0x14
    4bfa:	81 30       	cpi	r24, 0x01	; 1
    4bfc:	91 05       	cpc	r25, r1
    4bfe:	71 f0       	breq	.+28     	; 0x4c1c <xTaskGenericNotify+0xea>
    4c00:	93 c0       	rjmp	.+294    	; 0x4d28 <xTaskGenericNotify+0x1f6>
    4c02:	2b 89       	ldd	r18, Y+19	; 0x13
    4c04:	3c 89       	ldd	r19, Y+20	; 0x14
    4c06:	23 30       	cpi	r18, 0x03	; 3
    4c08:	31 05       	cpc	r19, r1
    4c0a:	09 f4       	brne	.+2      	; 0x4c0e <xTaskGenericNotify+0xdc>
    4c0c:	5d c0       	rjmp	.+186    	; 0x4cc8 <xTaskGenericNotify+0x196>
    4c0e:	8b 89       	ldd	r24, Y+19	; 0x13
    4c10:	9c 89       	ldd	r25, Y+20	; 0x14
    4c12:	84 30       	cpi	r24, 0x04	; 4
    4c14:	91 05       	cpc	r25, r1
    4c16:	09 f4       	brne	.+2      	; 0x4c1a <xTaskGenericNotify+0xe8>
    4c18:	6d c0       	rjmp	.+218    	; 0x4cf4 <xTaskGenericNotify+0x1c2>
    4c1a:	86 c0       	rjmp	.+268    	; 0x4d28 <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    4c1c:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c1e:	08 2f       	mov	r16, r24
    4c20:	10 e0       	ldi	r17, 0x00	; 0
    4c22:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c24:	88 2f       	mov	r24, r24
    4c26:	90 e0       	ldi	r25, 0x00	; 0
    4c28:	2f 81       	ldd	r18, Y+7	; 0x07
    4c2a:	38 85       	ldd	r19, Y+8	; 0x08
    4c2c:	88 0f       	add	r24, r24
    4c2e:	99 1f       	adc	r25, r25
    4c30:	88 0f       	add	r24, r24
    4c32:	99 1f       	adc	r25, r25
    4c34:	82 0f       	add	r24, r18
    4c36:	93 1f       	adc	r25, r19
    4c38:	fc 01       	movw	r30, r24
    4c3a:	b1 96       	adiw	r30, 0x21	; 33
    4c3c:	20 81       	ld	r18, Z
    4c3e:	31 81       	ldd	r19, Z+1	; 0x01
    4c40:	42 81       	ldd	r20, Z+2	; 0x02
    4c42:	53 81       	ldd	r21, Z+3	; 0x03
    4c44:	8c 85       	ldd	r24, Y+12	; 0x0c
    4c46:	9d 85       	ldd	r25, Y+13	; 0x0d
    4c48:	ae 85       	ldd	r26, Y+14	; 0x0e
    4c4a:	bf 85       	ldd	r27, Y+15	; 0x0f
    4c4c:	ba 01       	movw	r22, r20
    4c4e:	a9 01       	movw	r20, r18
    4c50:	48 2b       	or	r20, r24
    4c52:	59 2b       	or	r21, r25
    4c54:	6a 2b       	or	r22, r26
    4c56:	7b 2b       	or	r23, r27
    4c58:	2f 81       	ldd	r18, Y+7	; 0x07
    4c5a:	38 85       	ldd	r19, Y+8	; 0x08
    4c5c:	c8 01       	movw	r24, r16
    4c5e:	88 0f       	add	r24, r24
    4c60:	99 1f       	adc	r25, r25
    4c62:	88 0f       	add	r24, r24
    4c64:	99 1f       	adc	r25, r25
    4c66:	82 0f       	add	r24, r18
    4c68:	93 1f       	adc	r25, r19
    4c6a:	fc 01       	movw	r30, r24
    4c6c:	b1 96       	adiw	r30, 0x21	; 33
    4c6e:	40 83       	st	Z, r20
    4c70:	51 83       	std	Z+1, r21	; 0x01
    4c72:	62 83       	std	Z+2, r22	; 0x02
    4c74:	73 83       	std	Z+3, r23	; 0x03
    4c76:	58 c0       	rjmp	.+176    	; 0x4d28 <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    4c78:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c7a:	08 2f       	mov	r16, r24
    4c7c:	10 e0       	ldi	r17, 0x00	; 0
    4c7e:	2f 81       	ldd	r18, Y+7	; 0x07
    4c80:	38 85       	ldd	r19, Y+8	; 0x08
    4c82:	c8 01       	movw	r24, r16
    4c84:	88 0f       	add	r24, r24
    4c86:	99 1f       	adc	r25, r25
    4c88:	88 0f       	add	r24, r24
    4c8a:	99 1f       	adc	r25, r25
    4c8c:	82 0f       	add	r24, r18
    4c8e:	93 1f       	adc	r25, r19
    4c90:	fc 01       	movw	r30, r24
    4c92:	b1 96       	adiw	r30, 0x21	; 33
    4c94:	80 81       	ld	r24, Z
    4c96:	91 81       	ldd	r25, Z+1	; 0x01
    4c98:	a2 81       	ldd	r26, Z+2	; 0x02
    4c9a:	b3 81       	ldd	r27, Z+3	; 0x03
    4c9c:	ac 01       	movw	r20, r24
    4c9e:	bd 01       	movw	r22, r26
    4ca0:	4f 5f       	subi	r20, 0xFF	; 255
    4ca2:	5f 4f       	sbci	r21, 0xFF	; 255
    4ca4:	6f 4f       	sbci	r22, 0xFF	; 255
    4ca6:	7f 4f       	sbci	r23, 0xFF	; 255
    4ca8:	2f 81       	ldd	r18, Y+7	; 0x07
    4caa:	38 85       	ldd	r19, Y+8	; 0x08
    4cac:	c8 01       	movw	r24, r16
    4cae:	88 0f       	add	r24, r24
    4cb0:	99 1f       	adc	r25, r25
    4cb2:	88 0f       	add	r24, r24
    4cb4:	99 1f       	adc	r25, r25
    4cb6:	82 0f       	add	r24, r18
    4cb8:	93 1f       	adc	r25, r19
    4cba:	fc 01       	movw	r30, r24
    4cbc:	b1 96       	adiw	r30, 0x21	; 33
    4cbe:	40 83       	st	Z, r20
    4cc0:	51 83       	std	Z+1, r21	; 0x01
    4cc2:	62 83       	std	Z+2, r22	; 0x02
    4cc4:	73 83       	std	Z+3, r23	; 0x03
    4cc6:	30 c0       	rjmp	.+96     	; 0x4d28 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4cc8:	8b 85       	ldd	r24, Y+11	; 0x0b
    4cca:	88 2f       	mov	r24, r24
    4ccc:	90 e0       	ldi	r25, 0x00	; 0
    4cce:	2f 81       	ldd	r18, Y+7	; 0x07
    4cd0:	38 85       	ldd	r19, Y+8	; 0x08
    4cd2:	88 0f       	add	r24, r24
    4cd4:	99 1f       	adc	r25, r25
    4cd6:	88 0f       	add	r24, r24
    4cd8:	99 1f       	adc	r25, r25
    4cda:	82 0f       	add	r24, r18
    4cdc:	93 1f       	adc	r25, r19
    4cde:	fc 01       	movw	r30, r24
    4ce0:	b1 96       	adiw	r30, 0x21	; 33
    4ce2:	8c 85       	ldd	r24, Y+12	; 0x0c
    4ce4:	9d 85       	ldd	r25, Y+13	; 0x0d
    4ce6:	ae 85       	ldd	r26, Y+14	; 0x0e
    4ce8:	bf 85       	ldd	r27, Y+15	; 0x0f
    4cea:	80 83       	st	Z, r24
    4cec:	91 83       	std	Z+1, r25	; 0x01
    4cee:	a2 83       	std	Z+2, r26	; 0x02
    4cf0:	b3 83       	std	Z+3, r27	; 0x03
    4cf2:	1a c0       	rjmp	.+52     	; 0x4d28 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4cf4:	8d 81       	ldd	r24, Y+5	; 0x05
    4cf6:	82 30       	cpi	r24, 0x02	; 2
    4cf8:	b1 f0       	breq	.+44     	; 0x4d26 <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4cfa:	8b 85       	ldd	r24, Y+11	; 0x0b
    4cfc:	88 2f       	mov	r24, r24
    4cfe:	90 e0       	ldi	r25, 0x00	; 0
    4d00:	2f 81       	ldd	r18, Y+7	; 0x07
    4d02:	38 85       	ldd	r19, Y+8	; 0x08
    4d04:	88 0f       	add	r24, r24
    4d06:	99 1f       	adc	r25, r25
    4d08:	88 0f       	add	r24, r24
    4d0a:	99 1f       	adc	r25, r25
    4d0c:	82 0f       	add	r24, r18
    4d0e:	93 1f       	adc	r25, r19
    4d10:	fc 01       	movw	r30, r24
    4d12:	b1 96       	adiw	r30, 0x21	; 33
    4d14:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d16:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d18:	ae 85       	ldd	r26, Y+14	; 0x0e
    4d1a:	bf 85       	ldd	r27, Y+15	; 0x0f
    4d1c:	80 83       	st	Z, r24
    4d1e:	91 83       	std	Z+1, r25	; 0x01
    4d20:	a2 83       	std	Z+2, r26	; 0x02
    4d22:	b3 83       	std	Z+3, r27	; 0x03
    4d24:	01 c0       	rjmp	.+2      	; 0x4d28 <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    4d26:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4d28:	8d 81       	ldd	r24, Y+5	; 0x05
    4d2a:	81 30       	cpi	r24, 0x01	; 1
    4d2c:	09 f0       	breq	.+2      	; 0x4d30 <xTaskGenericNotify+0x1fe>
    4d2e:	af c0       	rjmp	.+350    	; 0x4e8e <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4d30:	ef 81       	ldd	r30, Y+7	; 0x07
    4d32:	f8 85       	ldd	r31, Y+8	; 0x08
    4d34:	82 85       	ldd	r24, Z+10	; 0x0a
    4d36:	93 85       	ldd	r25, Z+11	; 0x0b
    4d38:	9c 83       	std	Y+4, r25	; 0x04
    4d3a:	8b 83       	std	Y+3, r24	; 0x03
    4d3c:	ef 81       	ldd	r30, Y+7	; 0x07
    4d3e:	f8 85       	ldd	r31, Y+8	; 0x08
    4d40:	a4 81       	ldd	r26, Z+4	; 0x04
    4d42:	b5 81       	ldd	r27, Z+5	; 0x05
    4d44:	ef 81       	ldd	r30, Y+7	; 0x07
    4d46:	f8 85       	ldd	r31, Y+8	; 0x08
    4d48:	86 81       	ldd	r24, Z+6	; 0x06
    4d4a:	97 81       	ldd	r25, Z+7	; 0x07
    4d4c:	15 96       	adiw	r26, 0x05	; 5
    4d4e:	9c 93       	st	X, r25
    4d50:	8e 93       	st	-X, r24
    4d52:	14 97       	sbiw	r26, 0x04	; 4
    4d54:	ef 81       	ldd	r30, Y+7	; 0x07
    4d56:	f8 85       	ldd	r31, Y+8	; 0x08
    4d58:	a6 81       	ldd	r26, Z+6	; 0x06
    4d5a:	b7 81       	ldd	r27, Z+7	; 0x07
    4d5c:	ef 81       	ldd	r30, Y+7	; 0x07
    4d5e:	f8 85       	ldd	r31, Y+8	; 0x08
    4d60:	84 81       	ldd	r24, Z+4	; 0x04
    4d62:	95 81       	ldd	r25, Z+5	; 0x05
    4d64:	13 96       	adiw	r26, 0x03	; 3
    4d66:	9c 93       	st	X, r25
    4d68:	8e 93       	st	-X, r24
    4d6a:	12 97       	sbiw	r26, 0x02	; 2
    4d6c:	eb 81       	ldd	r30, Y+3	; 0x03
    4d6e:	fc 81       	ldd	r31, Y+4	; 0x04
    4d70:	21 81       	ldd	r18, Z+1	; 0x01
    4d72:	32 81       	ldd	r19, Z+2	; 0x02
    4d74:	8f 81       	ldd	r24, Y+7	; 0x07
    4d76:	98 85       	ldd	r25, Y+8	; 0x08
    4d78:	02 96       	adiw	r24, 0x02	; 2
    4d7a:	28 17       	cp	r18, r24
    4d7c:	39 07       	cpc	r19, r25
    4d7e:	41 f4       	brne	.+16     	; 0x4d90 <xTaskGenericNotify+0x25e>
    4d80:	ef 81       	ldd	r30, Y+7	; 0x07
    4d82:	f8 85       	ldd	r31, Y+8	; 0x08
    4d84:	86 81       	ldd	r24, Z+6	; 0x06
    4d86:	97 81       	ldd	r25, Z+7	; 0x07
    4d88:	eb 81       	ldd	r30, Y+3	; 0x03
    4d8a:	fc 81       	ldd	r31, Y+4	; 0x04
    4d8c:	92 83       	std	Z+2, r25	; 0x02
    4d8e:	81 83       	std	Z+1, r24	; 0x01
    4d90:	ef 81       	ldd	r30, Y+7	; 0x07
    4d92:	f8 85       	ldd	r31, Y+8	; 0x08
    4d94:	13 86       	std	Z+11, r1	; 0x0b
    4d96:	12 86       	std	Z+10, r1	; 0x0a
    4d98:	eb 81       	ldd	r30, Y+3	; 0x03
    4d9a:	fc 81       	ldd	r31, Y+4	; 0x04
    4d9c:	80 81       	ld	r24, Z
    4d9e:	81 50       	subi	r24, 0x01	; 1
    4da0:	eb 81       	ldd	r30, Y+3	; 0x03
    4da2:	fc 81       	ldd	r31, Y+4	; 0x04
    4da4:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    4da6:	ef 81       	ldd	r30, Y+7	; 0x07
    4da8:	f8 85       	ldd	r31, Y+8	; 0x08
    4daa:	96 89       	ldd	r25, Z+22	; 0x16
    4dac:	80 91 6a 06 	lds	r24, 0x066A
    4db0:	89 17       	cp	r24, r25
    4db2:	28 f4       	brcc	.+10     	; 0x4dbe <xTaskGenericNotify+0x28c>
    4db4:	ef 81       	ldd	r30, Y+7	; 0x07
    4db6:	f8 85       	ldd	r31, Y+8	; 0x08
    4db8:	86 89       	ldd	r24, Z+22	; 0x16
    4dba:	80 93 6a 06 	sts	0x066A, r24
    4dbe:	ef 81       	ldd	r30, Y+7	; 0x07
    4dc0:	f8 85       	ldd	r31, Y+8	; 0x08
    4dc2:	86 89       	ldd	r24, Z+22	; 0x16
    4dc4:	28 2f       	mov	r18, r24
    4dc6:	30 e0       	ldi	r19, 0x00	; 0
    4dc8:	c9 01       	movw	r24, r18
    4dca:	88 0f       	add	r24, r24
    4dcc:	99 1f       	adc	r25, r25
    4dce:	88 0f       	add	r24, r24
    4dd0:	99 1f       	adc	r25, r25
    4dd2:	88 0f       	add	r24, r24
    4dd4:	99 1f       	adc	r25, r25
    4dd6:	82 0f       	add	r24, r18
    4dd8:	93 1f       	adc	r25, r19
    4dda:	fc 01       	movw	r30, r24
    4ddc:	ea 58       	subi	r30, 0x8A	; 138
    4dde:	f9 4f       	sbci	r31, 0xF9	; 249
    4de0:	81 81       	ldd	r24, Z+1	; 0x01
    4de2:	92 81       	ldd	r25, Z+2	; 0x02
    4de4:	9a 83       	std	Y+2, r25	; 0x02
    4de6:	89 83       	std	Y+1, r24	; 0x01
    4de8:	ef 81       	ldd	r30, Y+7	; 0x07
    4dea:	f8 85       	ldd	r31, Y+8	; 0x08
    4dec:	89 81       	ldd	r24, Y+1	; 0x01
    4dee:	9a 81       	ldd	r25, Y+2	; 0x02
    4df0:	95 83       	std	Z+5, r25	; 0x05
    4df2:	84 83       	std	Z+4, r24	; 0x04
    4df4:	e9 81       	ldd	r30, Y+1	; 0x01
    4df6:	fa 81       	ldd	r31, Y+2	; 0x02
    4df8:	84 81       	ldd	r24, Z+4	; 0x04
    4dfa:	95 81       	ldd	r25, Z+5	; 0x05
    4dfc:	ef 81       	ldd	r30, Y+7	; 0x07
    4dfe:	f8 85       	ldd	r31, Y+8	; 0x08
    4e00:	97 83       	std	Z+7, r25	; 0x07
    4e02:	86 83       	std	Z+6, r24	; 0x06
    4e04:	e9 81       	ldd	r30, Y+1	; 0x01
    4e06:	fa 81       	ldd	r31, Y+2	; 0x02
    4e08:	04 80       	ldd	r0, Z+4	; 0x04
    4e0a:	f5 81       	ldd	r31, Z+5	; 0x05
    4e0c:	e0 2d       	mov	r30, r0
    4e0e:	8f 81       	ldd	r24, Y+7	; 0x07
    4e10:	98 85       	ldd	r25, Y+8	; 0x08
    4e12:	02 96       	adiw	r24, 0x02	; 2
    4e14:	93 83       	std	Z+3, r25	; 0x03
    4e16:	82 83       	std	Z+2, r24	; 0x02
    4e18:	8f 81       	ldd	r24, Y+7	; 0x07
    4e1a:	98 85       	ldd	r25, Y+8	; 0x08
    4e1c:	02 96       	adiw	r24, 0x02	; 2
    4e1e:	e9 81       	ldd	r30, Y+1	; 0x01
    4e20:	fa 81       	ldd	r31, Y+2	; 0x02
    4e22:	95 83       	std	Z+5, r25	; 0x05
    4e24:	84 83       	std	Z+4, r24	; 0x04
    4e26:	ef 81       	ldd	r30, Y+7	; 0x07
    4e28:	f8 85       	ldd	r31, Y+8	; 0x08
    4e2a:	86 89       	ldd	r24, Z+22	; 0x16
    4e2c:	28 2f       	mov	r18, r24
    4e2e:	30 e0       	ldi	r19, 0x00	; 0
    4e30:	c9 01       	movw	r24, r18
    4e32:	88 0f       	add	r24, r24
    4e34:	99 1f       	adc	r25, r25
    4e36:	88 0f       	add	r24, r24
    4e38:	99 1f       	adc	r25, r25
    4e3a:	88 0f       	add	r24, r24
    4e3c:	99 1f       	adc	r25, r25
    4e3e:	82 0f       	add	r24, r18
    4e40:	93 1f       	adc	r25, r19
    4e42:	8a 58       	subi	r24, 0x8A	; 138
    4e44:	99 4f       	sbci	r25, 0xF9	; 249
    4e46:	ef 81       	ldd	r30, Y+7	; 0x07
    4e48:	f8 85       	ldd	r31, Y+8	; 0x08
    4e4a:	93 87       	std	Z+11, r25	; 0x0b
    4e4c:	82 87       	std	Z+10, r24	; 0x0a
    4e4e:	ef 81       	ldd	r30, Y+7	; 0x07
    4e50:	f8 85       	ldd	r31, Y+8	; 0x08
    4e52:	86 89       	ldd	r24, Z+22	; 0x16
    4e54:	28 2f       	mov	r18, r24
    4e56:	30 e0       	ldi	r19, 0x00	; 0
    4e58:	c9 01       	movw	r24, r18
    4e5a:	88 0f       	add	r24, r24
    4e5c:	99 1f       	adc	r25, r25
    4e5e:	88 0f       	add	r24, r24
    4e60:	99 1f       	adc	r25, r25
    4e62:	88 0f       	add	r24, r24
    4e64:	99 1f       	adc	r25, r25
    4e66:	82 0f       	add	r24, r18
    4e68:	93 1f       	adc	r25, r19
    4e6a:	fc 01       	movw	r30, r24
    4e6c:	ea 58       	subi	r30, 0x8A	; 138
    4e6e:	f9 4f       	sbci	r31, 0xF9	; 249
    4e70:	80 81       	ld	r24, Z
    4e72:	8f 5f       	subi	r24, 0xFF	; 255
    4e74:	80 83       	st	Z, r24
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4e76:	ef 81       	ldd	r30, Y+7	; 0x07
    4e78:	f8 85       	ldd	r31, Y+8	; 0x08
    4e7a:	96 89       	ldd	r25, Z+22	; 0x16
    4e7c:	e0 91 64 06 	lds	r30, 0x0664
    4e80:	f0 91 65 06 	lds	r31, 0x0665
    4e84:	86 89       	ldd	r24, Z+22	; 0x16
    4e86:	89 17       	cp	r24, r25
    4e88:	10 f4       	brcc	.+4      	; 0x4e8e <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    4e8a:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4e8e:	0f 90       	pop	r0
    4e90:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4e92:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    4e94:	64 96       	adiw	r28, 0x14	; 20
    4e96:	0f b6       	in	r0, 0x3f	; 63
    4e98:	f8 94       	cli
    4e9a:	de bf       	out	0x3e, r29	; 62
    4e9c:	0f be       	out	0x3f, r0	; 63
    4e9e:	cd bf       	out	0x3d, r28	; 61
    4ea0:	cf 91       	pop	r28
    4ea2:	df 91       	pop	r29
    4ea4:	1f 91       	pop	r17
    4ea6:	0f 91       	pop	r16
    4ea8:	ff 90       	pop	r15
    4eaa:	ef 90       	pop	r14
    4eac:	08 95       	ret

00004eae <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    4eae:	cf 92       	push	r12
    4eb0:	df 92       	push	r13
    4eb2:	ef 92       	push	r14
    4eb4:	ff 92       	push	r15
    4eb6:	0f 93       	push	r16
    4eb8:	1f 93       	push	r17
    4eba:	df 93       	push	r29
    4ebc:	cf 93       	push	r28
    4ebe:	cd b7       	in	r28, 0x3d	; 61
    4ec0:	de b7       	in	r29, 0x3e	; 62
    4ec2:	69 97       	sbiw	r28, 0x19	; 25
    4ec4:	0f b6       	in	r0, 0x3f	; 63
    4ec6:	f8 94       	cli
    4ec8:	de bf       	out	0x3e, r29	; 62
    4eca:	0f be       	out	0x3f, r0	; 63
    4ecc:	cd bf       	out	0x3d, r28	; 61
    4ece:	9d 87       	std	Y+13, r25	; 0x0d
    4ed0:	8c 87       	std	Y+12, r24	; 0x0c
    4ed2:	6e 87       	std	Y+14, r22	; 0x0e
    4ed4:	2f 87       	std	Y+15, r18	; 0x0f
    4ed6:	38 8b       	std	Y+16, r19	; 0x10
    4ed8:	49 8b       	std	Y+17, r20	; 0x11
    4eda:	5a 8b       	std	Y+18, r21	; 0x12
    4edc:	0b 8b       	std	Y+19, r16	; 0x13
    4ede:	fd 8a       	std	Y+21, r15	; 0x15
    4ee0:	ec 8a       	std	Y+20, r14	; 0x14
    4ee2:	df 8a       	std	Y+23, r13	; 0x17
    4ee4:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    4ee6:	81 e0       	ldi	r24, 0x01	; 1
    4ee8:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    4eea:	8c 85       	ldd	r24, Y+12	; 0x0c
    4eec:	9d 85       	ldd	r25, Y+13	; 0x0d
    4eee:	9b 87       	std	Y+11, r25	; 0x0b
    4ef0:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4ef2:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    4ef4:	8c 89       	ldd	r24, Y+20	; 0x14
    4ef6:	9d 89       	ldd	r25, Y+21	; 0x15
    4ef8:	00 97       	sbiw	r24, 0x00	; 0
    4efa:	b9 f0       	breq	.+46     	; 0x4f2a <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    4efc:	8e 85       	ldd	r24, Y+14	; 0x0e
    4efe:	88 2f       	mov	r24, r24
    4f00:	90 e0       	ldi	r25, 0x00	; 0
    4f02:	2a 85       	ldd	r18, Y+10	; 0x0a
    4f04:	3b 85       	ldd	r19, Y+11	; 0x0b
    4f06:	88 0f       	add	r24, r24
    4f08:	99 1f       	adc	r25, r25
    4f0a:	88 0f       	add	r24, r24
    4f0c:	99 1f       	adc	r25, r25
    4f0e:	82 0f       	add	r24, r18
    4f10:	93 1f       	adc	r25, r19
    4f12:	fc 01       	movw	r30, r24
    4f14:	b1 96       	adiw	r30, 0x21	; 33
    4f16:	80 81       	ld	r24, Z
    4f18:	91 81       	ldd	r25, Z+1	; 0x01
    4f1a:	a2 81       	ldd	r26, Z+2	; 0x02
    4f1c:	b3 81       	ldd	r27, Z+3	; 0x03
    4f1e:	ec 89       	ldd	r30, Y+20	; 0x14
    4f20:	fd 89       	ldd	r31, Y+21	; 0x15
    4f22:	80 83       	st	Z, r24
    4f24:	91 83       	std	Z+1, r25	; 0x01
    4f26:	a2 83       	std	Z+2, r26	; 0x02
    4f28:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4f2a:	8e 85       	ldd	r24, Y+14	; 0x0e
    4f2c:	28 2f       	mov	r18, r24
    4f2e:	30 e0       	ldi	r19, 0x00	; 0
    4f30:	8a 85       	ldd	r24, Y+10	; 0x0a
    4f32:	9b 85       	ldd	r25, Y+11	; 0x0b
    4f34:	82 0f       	add	r24, r18
    4f36:	93 1f       	adc	r25, r19
    4f38:	fc 01       	movw	r30, r24
    4f3a:	b5 96       	adiw	r30, 0x25	; 37
    4f3c:	80 81       	ld	r24, Z
    4f3e:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4f40:	8e 85       	ldd	r24, Y+14	; 0x0e
    4f42:	28 2f       	mov	r18, r24
    4f44:	30 e0       	ldi	r19, 0x00	; 0
    4f46:	8a 85       	ldd	r24, Y+10	; 0x0a
    4f48:	9b 85       	ldd	r25, Y+11	; 0x0b
    4f4a:	82 0f       	add	r24, r18
    4f4c:	93 1f       	adc	r25, r19
    4f4e:	fc 01       	movw	r30, r24
    4f50:	b5 96       	adiw	r30, 0x25	; 37
    4f52:	82 e0       	ldi	r24, 0x02	; 2
    4f54:	80 83       	st	Z, r24

            switch( eAction )
    4f56:	8b 89       	ldd	r24, Y+19	; 0x13
    4f58:	28 2f       	mov	r18, r24
    4f5a:	30 e0       	ldi	r19, 0x00	; 0
    4f5c:	39 8f       	std	Y+25, r19	; 0x19
    4f5e:	28 8f       	std	Y+24, r18	; 0x18
    4f60:	88 8d       	ldd	r24, Y+24	; 0x18
    4f62:	99 8d       	ldd	r25, Y+25	; 0x19
    4f64:	82 30       	cpi	r24, 0x02	; 2
    4f66:	91 05       	cpc	r25, r1
    4f68:	09 f4       	brne	.+2      	; 0x4f6c <xTaskGenericNotifyFromISR+0xbe>
    4f6a:	46 c0       	rjmp	.+140    	; 0x4ff8 <xTaskGenericNotifyFromISR+0x14a>
    4f6c:	28 8d       	ldd	r18, Y+24	; 0x18
    4f6e:	39 8d       	ldd	r19, Y+25	; 0x19
    4f70:	23 30       	cpi	r18, 0x03	; 3
    4f72:	31 05       	cpc	r19, r1
    4f74:	34 f4       	brge	.+12     	; 0x4f82 <xTaskGenericNotifyFromISR+0xd4>
    4f76:	88 8d       	ldd	r24, Y+24	; 0x18
    4f78:	99 8d       	ldd	r25, Y+25	; 0x19
    4f7a:	81 30       	cpi	r24, 0x01	; 1
    4f7c:	91 05       	cpc	r25, r1
    4f7e:	71 f0       	breq	.+28     	; 0x4f9c <xTaskGenericNotifyFromISR+0xee>
    4f80:	93 c0       	rjmp	.+294    	; 0x50a8 <xTaskGenericNotifyFromISR+0x1fa>
    4f82:	28 8d       	ldd	r18, Y+24	; 0x18
    4f84:	39 8d       	ldd	r19, Y+25	; 0x19
    4f86:	23 30       	cpi	r18, 0x03	; 3
    4f88:	31 05       	cpc	r19, r1
    4f8a:	09 f4       	brne	.+2      	; 0x4f8e <xTaskGenericNotifyFromISR+0xe0>
    4f8c:	5d c0       	rjmp	.+186    	; 0x5048 <xTaskGenericNotifyFromISR+0x19a>
    4f8e:	88 8d       	ldd	r24, Y+24	; 0x18
    4f90:	99 8d       	ldd	r25, Y+25	; 0x19
    4f92:	84 30       	cpi	r24, 0x04	; 4
    4f94:	91 05       	cpc	r25, r1
    4f96:	09 f4       	brne	.+2      	; 0x4f9a <xTaskGenericNotifyFromISR+0xec>
    4f98:	6d c0       	rjmp	.+218    	; 0x5074 <xTaskGenericNotifyFromISR+0x1c6>
    4f9a:	86 c0       	rjmp	.+268    	; 0x50a8 <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    4f9c:	8e 85       	ldd	r24, Y+14	; 0x0e
    4f9e:	08 2f       	mov	r16, r24
    4fa0:	10 e0       	ldi	r17, 0x00	; 0
    4fa2:	8e 85       	ldd	r24, Y+14	; 0x0e
    4fa4:	88 2f       	mov	r24, r24
    4fa6:	90 e0       	ldi	r25, 0x00	; 0
    4fa8:	2a 85       	ldd	r18, Y+10	; 0x0a
    4faa:	3b 85       	ldd	r19, Y+11	; 0x0b
    4fac:	88 0f       	add	r24, r24
    4fae:	99 1f       	adc	r25, r25
    4fb0:	88 0f       	add	r24, r24
    4fb2:	99 1f       	adc	r25, r25
    4fb4:	82 0f       	add	r24, r18
    4fb6:	93 1f       	adc	r25, r19
    4fb8:	fc 01       	movw	r30, r24
    4fba:	b1 96       	adiw	r30, 0x21	; 33
    4fbc:	20 81       	ld	r18, Z
    4fbe:	31 81       	ldd	r19, Z+1	; 0x01
    4fc0:	42 81       	ldd	r20, Z+2	; 0x02
    4fc2:	53 81       	ldd	r21, Z+3	; 0x03
    4fc4:	8f 85       	ldd	r24, Y+15	; 0x0f
    4fc6:	98 89       	ldd	r25, Y+16	; 0x10
    4fc8:	a9 89       	ldd	r26, Y+17	; 0x11
    4fca:	ba 89       	ldd	r27, Y+18	; 0x12
    4fcc:	ba 01       	movw	r22, r20
    4fce:	a9 01       	movw	r20, r18
    4fd0:	48 2b       	or	r20, r24
    4fd2:	59 2b       	or	r21, r25
    4fd4:	6a 2b       	or	r22, r26
    4fd6:	7b 2b       	or	r23, r27
    4fd8:	2a 85       	ldd	r18, Y+10	; 0x0a
    4fda:	3b 85       	ldd	r19, Y+11	; 0x0b
    4fdc:	c8 01       	movw	r24, r16
    4fde:	88 0f       	add	r24, r24
    4fe0:	99 1f       	adc	r25, r25
    4fe2:	88 0f       	add	r24, r24
    4fe4:	99 1f       	adc	r25, r25
    4fe6:	82 0f       	add	r24, r18
    4fe8:	93 1f       	adc	r25, r19
    4fea:	fc 01       	movw	r30, r24
    4fec:	b1 96       	adiw	r30, 0x21	; 33
    4fee:	40 83       	st	Z, r20
    4ff0:	51 83       	std	Z+1, r21	; 0x01
    4ff2:	62 83       	std	Z+2, r22	; 0x02
    4ff4:	73 83       	std	Z+3, r23	; 0x03
    4ff6:	58 c0       	rjmp	.+176    	; 0x50a8 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    4ff8:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ffa:	08 2f       	mov	r16, r24
    4ffc:	10 e0       	ldi	r17, 0x00	; 0
    4ffe:	2a 85       	ldd	r18, Y+10	; 0x0a
    5000:	3b 85       	ldd	r19, Y+11	; 0x0b
    5002:	c8 01       	movw	r24, r16
    5004:	88 0f       	add	r24, r24
    5006:	99 1f       	adc	r25, r25
    5008:	88 0f       	add	r24, r24
    500a:	99 1f       	adc	r25, r25
    500c:	82 0f       	add	r24, r18
    500e:	93 1f       	adc	r25, r19
    5010:	fc 01       	movw	r30, r24
    5012:	b1 96       	adiw	r30, 0x21	; 33
    5014:	80 81       	ld	r24, Z
    5016:	91 81       	ldd	r25, Z+1	; 0x01
    5018:	a2 81       	ldd	r26, Z+2	; 0x02
    501a:	b3 81       	ldd	r27, Z+3	; 0x03
    501c:	ac 01       	movw	r20, r24
    501e:	bd 01       	movw	r22, r26
    5020:	4f 5f       	subi	r20, 0xFF	; 255
    5022:	5f 4f       	sbci	r21, 0xFF	; 255
    5024:	6f 4f       	sbci	r22, 0xFF	; 255
    5026:	7f 4f       	sbci	r23, 0xFF	; 255
    5028:	2a 85       	ldd	r18, Y+10	; 0x0a
    502a:	3b 85       	ldd	r19, Y+11	; 0x0b
    502c:	c8 01       	movw	r24, r16
    502e:	88 0f       	add	r24, r24
    5030:	99 1f       	adc	r25, r25
    5032:	88 0f       	add	r24, r24
    5034:	99 1f       	adc	r25, r25
    5036:	82 0f       	add	r24, r18
    5038:	93 1f       	adc	r25, r19
    503a:	fc 01       	movw	r30, r24
    503c:	b1 96       	adiw	r30, 0x21	; 33
    503e:	40 83       	st	Z, r20
    5040:	51 83       	std	Z+1, r21	; 0x01
    5042:	62 83       	std	Z+2, r22	; 0x02
    5044:	73 83       	std	Z+3, r23	; 0x03
    5046:	30 c0       	rjmp	.+96     	; 0x50a8 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5048:	8e 85       	ldd	r24, Y+14	; 0x0e
    504a:	88 2f       	mov	r24, r24
    504c:	90 e0       	ldi	r25, 0x00	; 0
    504e:	2a 85       	ldd	r18, Y+10	; 0x0a
    5050:	3b 85       	ldd	r19, Y+11	; 0x0b
    5052:	88 0f       	add	r24, r24
    5054:	99 1f       	adc	r25, r25
    5056:	88 0f       	add	r24, r24
    5058:	99 1f       	adc	r25, r25
    505a:	82 0f       	add	r24, r18
    505c:	93 1f       	adc	r25, r19
    505e:	fc 01       	movw	r30, r24
    5060:	b1 96       	adiw	r30, 0x21	; 33
    5062:	8f 85       	ldd	r24, Y+15	; 0x0f
    5064:	98 89       	ldd	r25, Y+16	; 0x10
    5066:	a9 89       	ldd	r26, Y+17	; 0x11
    5068:	ba 89       	ldd	r27, Y+18	; 0x12
    506a:	80 83       	st	Z, r24
    506c:	91 83       	std	Z+1, r25	; 0x01
    506e:	a2 83       	std	Z+2, r26	; 0x02
    5070:	b3 83       	std	Z+3, r27	; 0x03
    5072:	1a c0       	rjmp	.+52     	; 0x50a8 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5074:	89 85       	ldd	r24, Y+9	; 0x09
    5076:	82 30       	cpi	r24, 0x02	; 2
    5078:	b1 f0       	breq	.+44     	; 0x50a6 <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    507a:	8e 85       	ldd	r24, Y+14	; 0x0e
    507c:	88 2f       	mov	r24, r24
    507e:	90 e0       	ldi	r25, 0x00	; 0
    5080:	2a 85       	ldd	r18, Y+10	; 0x0a
    5082:	3b 85       	ldd	r19, Y+11	; 0x0b
    5084:	88 0f       	add	r24, r24
    5086:	99 1f       	adc	r25, r25
    5088:	88 0f       	add	r24, r24
    508a:	99 1f       	adc	r25, r25
    508c:	82 0f       	add	r24, r18
    508e:	93 1f       	adc	r25, r19
    5090:	fc 01       	movw	r30, r24
    5092:	b1 96       	adiw	r30, 0x21	; 33
    5094:	8f 85       	ldd	r24, Y+15	; 0x0f
    5096:	98 89       	ldd	r25, Y+16	; 0x10
    5098:	a9 89       	ldd	r26, Y+17	; 0x11
    509a:	ba 89       	ldd	r27, Y+18	; 0x12
    509c:	80 83       	st	Z, r24
    509e:	91 83       	std	Z+1, r25	; 0x01
    50a0:	a2 83       	std	Z+2, r26	; 0x02
    50a2:	b3 83       	std	Z+3, r27	; 0x03
    50a4:	01 c0       	rjmp	.+2      	; 0x50a8 <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    50a6:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    50a8:	89 85       	ldd	r24, Y+9	; 0x09
    50aa:	81 30       	cpi	r24, 0x01	; 1
    50ac:	09 f0       	breq	.+2      	; 0x50b0 <xTaskGenericNotifyFromISR+0x202>
    50ae:	ee c0       	rjmp	.+476    	; 0x528c <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    50b0:	80 91 75 06 	lds	r24, 0x0675
    50b4:	88 23       	and	r24, r24
    50b6:	09 f0       	breq	.+2      	; 0x50ba <xTaskGenericNotifyFromISR+0x20c>
    50b8:	a4 c0       	rjmp	.+328    	; 0x5202 <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    50ba:	ea 85       	ldd	r30, Y+10	; 0x0a
    50bc:	fb 85       	ldd	r31, Y+11	; 0x0b
    50be:	82 85       	ldd	r24, Z+10	; 0x0a
    50c0:	93 85       	ldd	r25, Z+11	; 0x0b
    50c2:	9e 83       	std	Y+6, r25	; 0x06
    50c4:	8d 83       	std	Y+5, r24	; 0x05
    50c6:	ea 85       	ldd	r30, Y+10	; 0x0a
    50c8:	fb 85       	ldd	r31, Y+11	; 0x0b
    50ca:	a4 81       	ldd	r26, Z+4	; 0x04
    50cc:	b5 81       	ldd	r27, Z+5	; 0x05
    50ce:	ea 85       	ldd	r30, Y+10	; 0x0a
    50d0:	fb 85       	ldd	r31, Y+11	; 0x0b
    50d2:	86 81       	ldd	r24, Z+6	; 0x06
    50d4:	97 81       	ldd	r25, Z+7	; 0x07
    50d6:	15 96       	adiw	r26, 0x05	; 5
    50d8:	9c 93       	st	X, r25
    50da:	8e 93       	st	-X, r24
    50dc:	14 97       	sbiw	r26, 0x04	; 4
    50de:	ea 85       	ldd	r30, Y+10	; 0x0a
    50e0:	fb 85       	ldd	r31, Y+11	; 0x0b
    50e2:	a6 81       	ldd	r26, Z+6	; 0x06
    50e4:	b7 81       	ldd	r27, Z+7	; 0x07
    50e6:	ea 85       	ldd	r30, Y+10	; 0x0a
    50e8:	fb 85       	ldd	r31, Y+11	; 0x0b
    50ea:	84 81       	ldd	r24, Z+4	; 0x04
    50ec:	95 81       	ldd	r25, Z+5	; 0x05
    50ee:	13 96       	adiw	r26, 0x03	; 3
    50f0:	9c 93       	st	X, r25
    50f2:	8e 93       	st	-X, r24
    50f4:	12 97       	sbiw	r26, 0x02	; 2
    50f6:	ed 81       	ldd	r30, Y+5	; 0x05
    50f8:	fe 81       	ldd	r31, Y+6	; 0x06
    50fa:	21 81       	ldd	r18, Z+1	; 0x01
    50fc:	32 81       	ldd	r19, Z+2	; 0x02
    50fe:	8a 85       	ldd	r24, Y+10	; 0x0a
    5100:	9b 85       	ldd	r25, Y+11	; 0x0b
    5102:	02 96       	adiw	r24, 0x02	; 2
    5104:	28 17       	cp	r18, r24
    5106:	39 07       	cpc	r19, r25
    5108:	41 f4       	brne	.+16     	; 0x511a <xTaskGenericNotifyFromISR+0x26c>
    510a:	ea 85       	ldd	r30, Y+10	; 0x0a
    510c:	fb 85       	ldd	r31, Y+11	; 0x0b
    510e:	86 81       	ldd	r24, Z+6	; 0x06
    5110:	97 81       	ldd	r25, Z+7	; 0x07
    5112:	ed 81       	ldd	r30, Y+5	; 0x05
    5114:	fe 81       	ldd	r31, Y+6	; 0x06
    5116:	92 83       	std	Z+2, r25	; 0x02
    5118:	81 83       	std	Z+1, r24	; 0x01
    511a:	ea 85       	ldd	r30, Y+10	; 0x0a
    511c:	fb 85       	ldd	r31, Y+11	; 0x0b
    511e:	13 86       	std	Z+11, r1	; 0x0b
    5120:	12 86       	std	Z+10, r1	; 0x0a
    5122:	ed 81       	ldd	r30, Y+5	; 0x05
    5124:	fe 81       	ldd	r31, Y+6	; 0x06
    5126:	80 81       	ld	r24, Z
    5128:	81 50       	subi	r24, 0x01	; 1
    512a:	ed 81       	ldd	r30, Y+5	; 0x05
    512c:	fe 81       	ldd	r31, Y+6	; 0x06
    512e:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5130:	ea 85       	ldd	r30, Y+10	; 0x0a
    5132:	fb 85       	ldd	r31, Y+11	; 0x0b
    5134:	96 89       	ldd	r25, Z+22	; 0x16
    5136:	80 91 6a 06 	lds	r24, 0x066A
    513a:	89 17       	cp	r24, r25
    513c:	28 f4       	brcc	.+10     	; 0x5148 <xTaskGenericNotifyFromISR+0x29a>
    513e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5140:	fb 85       	ldd	r31, Y+11	; 0x0b
    5142:	86 89       	ldd	r24, Z+22	; 0x16
    5144:	80 93 6a 06 	sts	0x066A, r24
    5148:	ea 85       	ldd	r30, Y+10	; 0x0a
    514a:	fb 85       	ldd	r31, Y+11	; 0x0b
    514c:	86 89       	ldd	r24, Z+22	; 0x16
    514e:	28 2f       	mov	r18, r24
    5150:	30 e0       	ldi	r19, 0x00	; 0
    5152:	c9 01       	movw	r24, r18
    5154:	88 0f       	add	r24, r24
    5156:	99 1f       	adc	r25, r25
    5158:	88 0f       	add	r24, r24
    515a:	99 1f       	adc	r25, r25
    515c:	88 0f       	add	r24, r24
    515e:	99 1f       	adc	r25, r25
    5160:	82 0f       	add	r24, r18
    5162:	93 1f       	adc	r25, r19
    5164:	fc 01       	movw	r30, r24
    5166:	ea 58       	subi	r30, 0x8A	; 138
    5168:	f9 4f       	sbci	r31, 0xF9	; 249
    516a:	81 81       	ldd	r24, Z+1	; 0x01
    516c:	92 81       	ldd	r25, Z+2	; 0x02
    516e:	9c 83       	std	Y+4, r25	; 0x04
    5170:	8b 83       	std	Y+3, r24	; 0x03
    5172:	ea 85       	ldd	r30, Y+10	; 0x0a
    5174:	fb 85       	ldd	r31, Y+11	; 0x0b
    5176:	8b 81       	ldd	r24, Y+3	; 0x03
    5178:	9c 81       	ldd	r25, Y+4	; 0x04
    517a:	95 83       	std	Z+5, r25	; 0x05
    517c:	84 83       	std	Z+4, r24	; 0x04
    517e:	eb 81       	ldd	r30, Y+3	; 0x03
    5180:	fc 81       	ldd	r31, Y+4	; 0x04
    5182:	84 81       	ldd	r24, Z+4	; 0x04
    5184:	95 81       	ldd	r25, Z+5	; 0x05
    5186:	ea 85       	ldd	r30, Y+10	; 0x0a
    5188:	fb 85       	ldd	r31, Y+11	; 0x0b
    518a:	97 83       	std	Z+7, r25	; 0x07
    518c:	86 83       	std	Z+6, r24	; 0x06
    518e:	eb 81       	ldd	r30, Y+3	; 0x03
    5190:	fc 81       	ldd	r31, Y+4	; 0x04
    5192:	04 80       	ldd	r0, Z+4	; 0x04
    5194:	f5 81       	ldd	r31, Z+5	; 0x05
    5196:	e0 2d       	mov	r30, r0
    5198:	8a 85       	ldd	r24, Y+10	; 0x0a
    519a:	9b 85       	ldd	r25, Y+11	; 0x0b
    519c:	02 96       	adiw	r24, 0x02	; 2
    519e:	93 83       	std	Z+3, r25	; 0x03
    51a0:	82 83       	std	Z+2, r24	; 0x02
    51a2:	8a 85       	ldd	r24, Y+10	; 0x0a
    51a4:	9b 85       	ldd	r25, Y+11	; 0x0b
    51a6:	02 96       	adiw	r24, 0x02	; 2
    51a8:	eb 81       	ldd	r30, Y+3	; 0x03
    51aa:	fc 81       	ldd	r31, Y+4	; 0x04
    51ac:	95 83       	std	Z+5, r25	; 0x05
    51ae:	84 83       	std	Z+4, r24	; 0x04
    51b0:	ea 85       	ldd	r30, Y+10	; 0x0a
    51b2:	fb 85       	ldd	r31, Y+11	; 0x0b
    51b4:	86 89       	ldd	r24, Z+22	; 0x16
    51b6:	28 2f       	mov	r18, r24
    51b8:	30 e0       	ldi	r19, 0x00	; 0
    51ba:	c9 01       	movw	r24, r18
    51bc:	88 0f       	add	r24, r24
    51be:	99 1f       	adc	r25, r25
    51c0:	88 0f       	add	r24, r24
    51c2:	99 1f       	adc	r25, r25
    51c4:	88 0f       	add	r24, r24
    51c6:	99 1f       	adc	r25, r25
    51c8:	82 0f       	add	r24, r18
    51ca:	93 1f       	adc	r25, r19
    51cc:	8a 58       	subi	r24, 0x8A	; 138
    51ce:	99 4f       	sbci	r25, 0xF9	; 249
    51d0:	ea 85       	ldd	r30, Y+10	; 0x0a
    51d2:	fb 85       	ldd	r31, Y+11	; 0x0b
    51d4:	93 87       	std	Z+11, r25	; 0x0b
    51d6:	82 87       	std	Z+10, r24	; 0x0a
    51d8:	ea 85       	ldd	r30, Y+10	; 0x0a
    51da:	fb 85       	ldd	r31, Y+11	; 0x0b
    51dc:	86 89       	ldd	r24, Z+22	; 0x16
    51de:	28 2f       	mov	r18, r24
    51e0:	30 e0       	ldi	r19, 0x00	; 0
    51e2:	c9 01       	movw	r24, r18
    51e4:	88 0f       	add	r24, r24
    51e6:	99 1f       	adc	r25, r25
    51e8:	88 0f       	add	r24, r24
    51ea:	99 1f       	adc	r25, r25
    51ec:	88 0f       	add	r24, r24
    51ee:	99 1f       	adc	r25, r25
    51f0:	82 0f       	add	r24, r18
    51f2:	93 1f       	adc	r25, r19
    51f4:	fc 01       	movw	r30, r24
    51f6:	ea 58       	subi	r30, 0x8A	; 138
    51f8:	f9 4f       	sbci	r31, 0xF9	; 249
    51fa:	80 81       	ld	r24, Z
    51fc:	8f 5f       	subi	r24, 0xFF	; 255
    51fe:	80 83       	st	Z, r24
    5200:	30 c0       	rjmp	.+96     	; 0x5262 <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5202:	80 91 b1 06 	lds	r24, 0x06B1
    5206:	90 91 b2 06 	lds	r25, 0x06B2
    520a:	9a 83       	std	Y+2, r25	; 0x02
    520c:	89 83       	std	Y+1, r24	; 0x01
    520e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5210:	fb 85       	ldd	r31, Y+11	; 0x0b
    5212:	89 81       	ldd	r24, Y+1	; 0x01
    5214:	9a 81       	ldd	r25, Y+2	; 0x02
    5216:	97 87       	std	Z+15, r25	; 0x0f
    5218:	86 87       	std	Z+14, r24	; 0x0e
    521a:	e9 81       	ldd	r30, Y+1	; 0x01
    521c:	fa 81       	ldd	r31, Y+2	; 0x02
    521e:	84 81       	ldd	r24, Z+4	; 0x04
    5220:	95 81       	ldd	r25, Z+5	; 0x05
    5222:	ea 85       	ldd	r30, Y+10	; 0x0a
    5224:	fb 85       	ldd	r31, Y+11	; 0x0b
    5226:	91 8b       	std	Z+17, r25	; 0x11
    5228:	80 8b       	std	Z+16, r24	; 0x10
    522a:	e9 81       	ldd	r30, Y+1	; 0x01
    522c:	fa 81       	ldd	r31, Y+2	; 0x02
    522e:	04 80       	ldd	r0, Z+4	; 0x04
    5230:	f5 81       	ldd	r31, Z+5	; 0x05
    5232:	e0 2d       	mov	r30, r0
    5234:	8a 85       	ldd	r24, Y+10	; 0x0a
    5236:	9b 85       	ldd	r25, Y+11	; 0x0b
    5238:	0c 96       	adiw	r24, 0x0c	; 12
    523a:	93 83       	std	Z+3, r25	; 0x03
    523c:	82 83       	std	Z+2, r24	; 0x02
    523e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5240:	9b 85       	ldd	r25, Y+11	; 0x0b
    5242:	0c 96       	adiw	r24, 0x0c	; 12
    5244:	e9 81       	ldd	r30, Y+1	; 0x01
    5246:	fa 81       	ldd	r31, Y+2	; 0x02
    5248:	95 83       	std	Z+5, r25	; 0x05
    524a:	84 83       	std	Z+4, r24	; 0x04
    524c:	ea 85       	ldd	r30, Y+10	; 0x0a
    524e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5250:	80 eb       	ldi	r24, 0xB0	; 176
    5252:	96 e0       	ldi	r25, 0x06	; 6
    5254:	95 8b       	std	Z+21, r25	; 0x15
    5256:	84 8b       	std	Z+20, r24	; 0x14
    5258:	80 91 b0 06 	lds	r24, 0x06B0
    525c:	8f 5f       	subi	r24, 0xFF	; 255
    525e:	80 93 b0 06 	sts	0x06B0, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5262:	ea 85       	ldd	r30, Y+10	; 0x0a
    5264:	fb 85       	ldd	r31, Y+11	; 0x0b
    5266:	96 89       	ldd	r25, Z+22	; 0x16
    5268:	e0 91 64 06 	lds	r30, 0x0664
    526c:	f0 91 65 06 	lds	r31, 0x0665
    5270:	86 89       	ldd	r24, Z+22	; 0x16
    5272:	89 17       	cp	r24, r25
    5274:	58 f4       	brcc	.+22     	; 0x528c <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5276:	8e 89       	ldd	r24, Y+22	; 0x16
    5278:	9f 89       	ldd	r25, Y+23	; 0x17
    527a:	00 97       	sbiw	r24, 0x00	; 0
    527c:	21 f0       	breq	.+8      	; 0x5286 <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    527e:	ee 89       	ldd	r30, Y+22	; 0x16
    5280:	ff 89       	ldd	r31, Y+23	; 0x17
    5282:	81 e0       	ldi	r24, 0x01	; 1
    5284:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5286:	81 e0       	ldi	r24, 0x01	; 1
    5288:	80 93 6e 06 	sts	0x066E, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    528c:	88 85       	ldd	r24, Y+8	; 0x08
    }
    528e:	69 96       	adiw	r28, 0x19	; 25
    5290:	0f b6       	in	r0, 0x3f	; 63
    5292:	f8 94       	cli
    5294:	de bf       	out	0x3e, r29	; 62
    5296:	0f be       	out	0x3f, r0	; 63
    5298:	cd bf       	out	0x3d, r28	; 61
    529a:	cf 91       	pop	r28
    529c:	df 91       	pop	r29
    529e:	1f 91       	pop	r17
    52a0:	0f 91       	pop	r16
    52a2:	ff 90       	pop	r15
    52a4:	ef 90       	pop	r14
    52a6:	df 90       	pop	r13
    52a8:	cf 90       	pop	r12
    52aa:	08 95       	ret

000052ac <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    52ac:	0f 93       	push	r16
    52ae:	1f 93       	push	r17
    52b0:	df 93       	push	r29
    52b2:	cf 93       	push	r28
    52b4:	cd b7       	in	r28, 0x3d	; 61
    52b6:	de b7       	in	r29, 0x3e	; 62
    52b8:	2f 97       	sbiw	r28, 0x0f	; 15
    52ba:	0f b6       	in	r0, 0x3f	; 63
    52bc:	f8 94       	cli
    52be:	de bf       	out	0x3e, r29	; 62
    52c0:	0f be       	out	0x3f, r0	; 63
    52c2:	cd bf       	out	0x3d, r28	; 61
    52c4:	9c 87       	std	Y+12, r25	; 0x0c
    52c6:	8b 87       	std	Y+11, r24	; 0x0b
    52c8:	6d 87       	std	Y+13, r22	; 0x0d
    52ca:	5f 87       	std	Y+15, r21	; 0x0f
    52cc:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    52ce:	8b 85       	ldd	r24, Y+11	; 0x0b
    52d0:	9c 85       	ldd	r25, Y+12	; 0x0c
    52d2:	9a 87       	std	Y+10, r25	; 0x0a
    52d4:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    52d6:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    52d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    52da:	28 2f       	mov	r18, r24
    52dc:	30 e0       	ldi	r19, 0x00	; 0
    52de:	89 85       	ldd	r24, Y+9	; 0x09
    52e0:	9a 85       	ldd	r25, Y+10	; 0x0a
    52e2:	82 0f       	add	r24, r18
    52e4:	93 1f       	adc	r25, r19
    52e6:	fc 01       	movw	r30, r24
    52e8:	b5 96       	adiw	r30, 0x25	; 37
    52ea:	80 81       	ld	r24, Z
    52ec:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    52ee:	8d 85       	ldd	r24, Y+13	; 0x0d
    52f0:	28 2f       	mov	r18, r24
    52f2:	30 e0       	ldi	r19, 0x00	; 0
    52f4:	89 85       	ldd	r24, Y+9	; 0x09
    52f6:	9a 85       	ldd	r25, Y+10	; 0x0a
    52f8:	82 0f       	add	r24, r18
    52fa:	93 1f       	adc	r25, r19
    52fc:	fc 01       	movw	r30, r24
    52fe:	b5 96       	adiw	r30, 0x25	; 37
    5300:	82 e0       	ldi	r24, 0x02	; 2
    5302:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5304:	8d 85       	ldd	r24, Y+13	; 0x0d
    5306:	08 2f       	mov	r16, r24
    5308:	10 e0       	ldi	r17, 0x00	; 0
    530a:	29 85       	ldd	r18, Y+9	; 0x09
    530c:	3a 85       	ldd	r19, Y+10	; 0x0a
    530e:	c8 01       	movw	r24, r16
    5310:	88 0f       	add	r24, r24
    5312:	99 1f       	adc	r25, r25
    5314:	88 0f       	add	r24, r24
    5316:	99 1f       	adc	r25, r25
    5318:	82 0f       	add	r24, r18
    531a:	93 1f       	adc	r25, r19
    531c:	fc 01       	movw	r30, r24
    531e:	b1 96       	adiw	r30, 0x21	; 33
    5320:	80 81       	ld	r24, Z
    5322:	91 81       	ldd	r25, Z+1	; 0x01
    5324:	a2 81       	ldd	r26, Z+2	; 0x02
    5326:	b3 81       	ldd	r27, Z+3	; 0x03
    5328:	ac 01       	movw	r20, r24
    532a:	bd 01       	movw	r22, r26
    532c:	4f 5f       	subi	r20, 0xFF	; 255
    532e:	5f 4f       	sbci	r21, 0xFF	; 255
    5330:	6f 4f       	sbci	r22, 0xFF	; 255
    5332:	7f 4f       	sbci	r23, 0xFF	; 255
    5334:	29 85       	ldd	r18, Y+9	; 0x09
    5336:	3a 85       	ldd	r19, Y+10	; 0x0a
    5338:	c8 01       	movw	r24, r16
    533a:	88 0f       	add	r24, r24
    533c:	99 1f       	adc	r25, r25
    533e:	88 0f       	add	r24, r24
    5340:	99 1f       	adc	r25, r25
    5342:	82 0f       	add	r24, r18
    5344:	93 1f       	adc	r25, r19
    5346:	fc 01       	movw	r30, r24
    5348:	b1 96       	adiw	r30, 0x21	; 33
    534a:	40 83       	st	Z, r20
    534c:	51 83       	std	Z+1, r21	; 0x01
    534e:	62 83       	std	Z+2, r22	; 0x02
    5350:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5352:	88 85       	ldd	r24, Y+8	; 0x08
    5354:	81 30       	cpi	r24, 0x01	; 1
    5356:	09 f0       	breq	.+2      	; 0x535a <vTaskGenericNotifyGiveFromISR+0xae>
    5358:	ee c0       	rjmp	.+476    	; 0x5536 <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    535a:	80 91 75 06 	lds	r24, 0x0675
    535e:	88 23       	and	r24, r24
    5360:	09 f0       	breq	.+2      	; 0x5364 <vTaskGenericNotifyGiveFromISR+0xb8>
    5362:	a4 c0       	rjmp	.+328    	; 0x54ac <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5364:	e9 85       	ldd	r30, Y+9	; 0x09
    5366:	fa 85       	ldd	r31, Y+10	; 0x0a
    5368:	82 85       	ldd	r24, Z+10	; 0x0a
    536a:	93 85       	ldd	r25, Z+11	; 0x0b
    536c:	9e 83       	std	Y+6, r25	; 0x06
    536e:	8d 83       	std	Y+5, r24	; 0x05
    5370:	e9 85       	ldd	r30, Y+9	; 0x09
    5372:	fa 85       	ldd	r31, Y+10	; 0x0a
    5374:	a4 81       	ldd	r26, Z+4	; 0x04
    5376:	b5 81       	ldd	r27, Z+5	; 0x05
    5378:	e9 85       	ldd	r30, Y+9	; 0x09
    537a:	fa 85       	ldd	r31, Y+10	; 0x0a
    537c:	86 81       	ldd	r24, Z+6	; 0x06
    537e:	97 81       	ldd	r25, Z+7	; 0x07
    5380:	15 96       	adiw	r26, 0x05	; 5
    5382:	9c 93       	st	X, r25
    5384:	8e 93       	st	-X, r24
    5386:	14 97       	sbiw	r26, 0x04	; 4
    5388:	e9 85       	ldd	r30, Y+9	; 0x09
    538a:	fa 85       	ldd	r31, Y+10	; 0x0a
    538c:	a6 81       	ldd	r26, Z+6	; 0x06
    538e:	b7 81       	ldd	r27, Z+7	; 0x07
    5390:	e9 85       	ldd	r30, Y+9	; 0x09
    5392:	fa 85       	ldd	r31, Y+10	; 0x0a
    5394:	84 81       	ldd	r24, Z+4	; 0x04
    5396:	95 81       	ldd	r25, Z+5	; 0x05
    5398:	13 96       	adiw	r26, 0x03	; 3
    539a:	9c 93       	st	X, r25
    539c:	8e 93       	st	-X, r24
    539e:	12 97       	sbiw	r26, 0x02	; 2
    53a0:	ed 81       	ldd	r30, Y+5	; 0x05
    53a2:	fe 81       	ldd	r31, Y+6	; 0x06
    53a4:	21 81       	ldd	r18, Z+1	; 0x01
    53a6:	32 81       	ldd	r19, Z+2	; 0x02
    53a8:	89 85       	ldd	r24, Y+9	; 0x09
    53aa:	9a 85       	ldd	r25, Y+10	; 0x0a
    53ac:	02 96       	adiw	r24, 0x02	; 2
    53ae:	28 17       	cp	r18, r24
    53b0:	39 07       	cpc	r19, r25
    53b2:	41 f4       	brne	.+16     	; 0x53c4 <vTaskGenericNotifyGiveFromISR+0x118>
    53b4:	e9 85       	ldd	r30, Y+9	; 0x09
    53b6:	fa 85       	ldd	r31, Y+10	; 0x0a
    53b8:	86 81       	ldd	r24, Z+6	; 0x06
    53ba:	97 81       	ldd	r25, Z+7	; 0x07
    53bc:	ed 81       	ldd	r30, Y+5	; 0x05
    53be:	fe 81       	ldd	r31, Y+6	; 0x06
    53c0:	92 83       	std	Z+2, r25	; 0x02
    53c2:	81 83       	std	Z+1, r24	; 0x01
    53c4:	e9 85       	ldd	r30, Y+9	; 0x09
    53c6:	fa 85       	ldd	r31, Y+10	; 0x0a
    53c8:	13 86       	std	Z+11, r1	; 0x0b
    53ca:	12 86       	std	Z+10, r1	; 0x0a
    53cc:	ed 81       	ldd	r30, Y+5	; 0x05
    53ce:	fe 81       	ldd	r31, Y+6	; 0x06
    53d0:	80 81       	ld	r24, Z
    53d2:	81 50       	subi	r24, 0x01	; 1
    53d4:	ed 81       	ldd	r30, Y+5	; 0x05
    53d6:	fe 81       	ldd	r31, Y+6	; 0x06
    53d8:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    53da:	e9 85       	ldd	r30, Y+9	; 0x09
    53dc:	fa 85       	ldd	r31, Y+10	; 0x0a
    53de:	96 89       	ldd	r25, Z+22	; 0x16
    53e0:	80 91 6a 06 	lds	r24, 0x066A
    53e4:	89 17       	cp	r24, r25
    53e6:	28 f4       	brcc	.+10     	; 0x53f2 <vTaskGenericNotifyGiveFromISR+0x146>
    53e8:	e9 85       	ldd	r30, Y+9	; 0x09
    53ea:	fa 85       	ldd	r31, Y+10	; 0x0a
    53ec:	86 89       	ldd	r24, Z+22	; 0x16
    53ee:	80 93 6a 06 	sts	0x066A, r24
    53f2:	e9 85       	ldd	r30, Y+9	; 0x09
    53f4:	fa 85       	ldd	r31, Y+10	; 0x0a
    53f6:	86 89       	ldd	r24, Z+22	; 0x16
    53f8:	28 2f       	mov	r18, r24
    53fa:	30 e0       	ldi	r19, 0x00	; 0
    53fc:	c9 01       	movw	r24, r18
    53fe:	88 0f       	add	r24, r24
    5400:	99 1f       	adc	r25, r25
    5402:	88 0f       	add	r24, r24
    5404:	99 1f       	adc	r25, r25
    5406:	88 0f       	add	r24, r24
    5408:	99 1f       	adc	r25, r25
    540a:	82 0f       	add	r24, r18
    540c:	93 1f       	adc	r25, r19
    540e:	fc 01       	movw	r30, r24
    5410:	ea 58       	subi	r30, 0x8A	; 138
    5412:	f9 4f       	sbci	r31, 0xF9	; 249
    5414:	81 81       	ldd	r24, Z+1	; 0x01
    5416:	92 81       	ldd	r25, Z+2	; 0x02
    5418:	9c 83       	std	Y+4, r25	; 0x04
    541a:	8b 83       	std	Y+3, r24	; 0x03
    541c:	e9 85       	ldd	r30, Y+9	; 0x09
    541e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5420:	8b 81       	ldd	r24, Y+3	; 0x03
    5422:	9c 81       	ldd	r25, Y+4	; 0x04
    5424:	95 83       	std	Z+5, r25	; 0x05
    5426:	84 83       	std	Z+4, r24	; 0x04
    5428:	eb 81       	ldd	r30, Y+3	; 0x03
    542a:	fc 81       	ldd	r31, Y+4	; 0x04
    542c:	84 81       	ldd	r24, Z+4	; 0x04
    542e:	95 81       	ldd	r25, Z+5	; 0x05
    5430:	e9 85       	ldd	r30, Y+9	; 0x09
    5432:	fa 85       	ldd	r31, Y+10	; 0x0a
    5434:	97 83       	std	Z+7, r25	; 0x07
    5436:	86 83       	std	Z+6, r24	; 0x06
    5438:	eb 81       	ldd	r30, Y+3	; 0x03
    543a:	fc 81       	ldd	r31, Y+4	; 0x04
    543c:	04 80       	ldd	r0, Z+4	; 0x04
    543e:	f5 81       	ldd	r31, Z+5	; 0x05
    5440:	e0 2d       	mov	r30, r0
    5442:	89 85       	ldd	r24, Y+9	; 0x09
    5444:	9a 85       	ldd	r25, Y+10	; 0x0a
    5446:	02 96       	adiw	r24, 0x02	; 2
    5448:	93 83       	std	Z+3, r25	; 0x03
    544a:	82 83       	std	Z+2, r24	; 0x02
    544c:	89 85       	ldd	r24, Y+9	; 0x09
    544e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5450:	02 96       	adiw	r24, 0x02	; 2
    5452:	eb 81       	ldd	r30, Y+3	; 0x03
    5454:	fc 81       	ldd	r31, Y+4	; 0x04
    5456:	95 83       	std	Z+5, r25	; 0x05
    5458:	84 83       	std	Z+4, r24	; 0x04
    545a:	e9 85       	ldd	r30, Y+9	; 0x09
    545c:	fa 85       	ldd	r31, Y+10	; 0x0a
    545e:	86 89       	ldd	r24, Z+22	; 0x16
    5460:	28 2f       	mov	r18, r24
    5462:	30 e0       	ldi	r19, 0x00	; 0
    5464:	c9 01       	movw	r24, r18
    5466:	88 0f       	add	r24, r24
    5468:	99 1f       	adc	r25, r25
    546a:	88 0f       	add	r24, r24
    546c:	99 1f       	adc	r25, r25
    546e:	88 0f       	add	r24, r24
    5470:	99 1f       	adc	r25, r25
    5472:	82 0f       	add	r24, r18
    5474:	93 1f       	adc	r25, r19
    5476:	8a 58       	subi	r24, 0x8A	; 138
    5478:	99 4f       	sbci	r25, 0xF9	; 249
    547a:	e9 85       	ldd	r30, Y+9	; 0x09
    547c:	fa 85       	ldd	r31, Y+10	; 0x0a
    547e:	93 87       	std	Z+11, r25	; 0x0b
    5480:	82 87       	std	Z+10, r24	; 0x0a
    5482:	e9 85       	ldd	r30, Y+9	; 0x09
    5484:	fa 85       	ldd	r31, Y+10	; 0x0a
    5486:	86 89       	ldd	r24, Z+22	; 0x16
    5488:	28 2f       	mov	r18, r24
    548a:	30 e0       	ldi	r19, 0x00	; 0
    548c:	c9 01       	movw	r24, r18
    548e:	88 0f       	add	r24, r24
    5490:	99 1f       	adc	r25, r25
    5492:	88 0f       	add	r24, r24
    5494:	99 1f       	adc	r25, r25
    5496:	88 0f       	add	r24, r24
    5498:	99 1f       	adc	r25, r25
    549a:	82 0f       	add	r24, r18
    549c:	93 1f       	adc	r25, r19
    549e:	fc 01       	movw	r30, r24
    54a0:	ea 58       	subi	r30, 0x8A	; 138
    54a2:	f9 4f       	sbci	r31, 0xF9	; 249
    54a4:	80 81       	ld	r24, Z
    54a6:	8f 5f       	subi	r24, 0xFF	; 255
    54a8:	80 83       	st	Z, r24
    54aa:	30 c0       	rjmp	.+96     	; 0x550c <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    54ac:	80 91 b1 06 	lds	r24, 0x06B1
    54b0:	90 91 b2 06 	lds	r25, 0x06B2
    54b4:	9a 83       	std	Y+2, r25	; 0x02
    54b6:	89 83       	std	Y+1, r24	; 0x01
    54b8:	e9 85       	ldd	r30, Y+9	; 0x09
    54ba:	fa 85       	ldd	r31, Y+10	; 0x0a
    54bc:	89 81       	ldd	r24, Y+1	; 0x01
    54be:	9a 81       	ldd	r25, Y+2	; 0x02
    54c0:	97 87       	std	Z+15, r25	; 0x0f
    54c2:	86 87       	std	Z+14, r24	; 0x0e
    54c4:	e9 81       	ldd	r30, Y+1	; 0x01
    54c6:	fa 81       	ldd	r31, Y+2	; 0x02
    54c8:	84 81       	ldd	r24, Z+4	; 0x04
    54ca:	95 81       	ldd	r25, Z+5	; 0x05
    54cc:	e9 85       	ldd	r30, Y+9	; 0x09
    54ce:	fa 85       	ldd	r31, Y+10	; 0x0a
    54d0:	91 8b       	std	Z+17, r25	; 0x11
    54d2:	80 8b       	std	Z+16, r24	; 0x10
    54d4:	e9 81       	ldd	r30, Y+1	; 0x01
    54d6:	fa 81       	ldd	r31, Y+2	; 0x02
    54d8:	04 80       	ldd	r0, Z+4	; 0x04
    54da:	f5 81       	ldd	r31, Z+5	; 0x05
    54dc:	e0 2d       	mov	r30, r0
    54de:	89 85       	ldd	r24, Y+9	; 0x09
    54e0:	9a 85       	ldd	r25, Y+10	; 0x0a
    54e2:	0c 96       	adiw	r24, 0x0c	; 12
    54e4:	93 83       	std	Z+3, r25	; 0x03
    54e6:	82 83       	std	Z+2, r24	; 0x02
    54e8:	89 85       	ldd	r24, Y+9	; 0x09
    54ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    54ec:	0c 96       	adiw	r24, 0x0c	; 12
    54ee:	e9 81       	ldd	r30, Y+1	; 0x01
    54f0:	fa 81       	ldd	r31, Y+2	; 0x02
    54f2:	95 83       	std	Z+5, r25	; 0x05
    54f4:	84 83       	std	Z+4, r24	; 0x04
    54f6:	e9 85       	ldd	r30, Y+9	; 0x09
    54f8:	fa 85       	ldd	r31, Y+10	; 0x0a
    54fa:	80 eb       	ldi	r24, 0xB0	; 176
    54fc:	96 e0       	ldi	r25, 0x06	; 6
    54fe:	95 8b       	std	Z+21, r25	; 0x15
    5500:	84 8b       	std	Z+20, r24	; 0x14
    5502:	80 91 b0 06 	lds	r24, 0x06B0
    5506:	8f 5f       	subi	r24, 0xFF	; 255
    5508:	80 93 b0 06 	sts	0x06B0, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    550c:	e9 85       	ldd	r30, Y+9	; 0x09
    550e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5510:	96 89       	ldd	r25, Z+22	; 0x16
    5512:	e0 91 64 06 	lds	r30, 0x0664
    5516:	f0 91 65 06 	lds	r31, 0x0665
    551a:	86 89       	ldd	r24, Z+22	; 0x16
    551c:	89 17       	cp	r24, r25
    551e:	58 f4       	brcc	.+22     	; 0x5536 <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5520:	8e 85       	ldd	r24, Y+14	; 0x0e
    5522:	9f 85       	ldd	r25, Y+15	; 0x0f
    5524:	00 97       	sbiw	r24, 0x00	; 0
    5526:	21 f0       	breq	.+8      	; 0x5530 <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5528:	ee 85       	ldd	r30, Y+14	; 0x0e
    552a:	ff 85       	ldd	r31, Y+15	; 0x0f
    552c:	81 e0       	ldi	r24, 0x01	; 1
    552e:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5530:	81 e0       	ldi	r24, 0x01	; 1
    5532:	80 93 6e 06 	sts	0x066E, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    5536:	2f 96       	adiw	r28, 0x0f	; 15
    5538:	0f b6       	in	r0, 0x3f	; 63
    553a:	f8 94       	cli
    553c:	de bf       	out	0x3e, r29	; 62
    553e:	0f be       	out	0x3f, r0	; 63
    5540:	cd bf       	out	0x3d, r28	; 61
    5542:	cf 91       	pop	r28
    5544:	df 91       	pop	r29
    5546:	1f 91       	pop	r17
    5548:	0f 91       	pop	r16
    554a:	08 95       	ret

0000554c <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    554c:	df 93       	push	r29
    554e:	cf 93       	push	r28
    5550:	cd b7       	in	r28, 0x3d	; 61
    5552:	de b7       	in	r29, 0x3e	; 62
    5554:	28 97       	sbiw	r28, 0x08	; 8
    5556:	0f b6       	in	r0, 0x3f	; 63
    5558:	f8 94       	cli
    555a:	de bf       	out	0x3e, r29	; 62
    555c:	0f be       	out	0x3f, r0	; 63
    555e:	cd bf       	out	0x3d, r28	; 61
    5560:	9d 83       	std	Y+5, r25	; 0x05
    5562:	8c 83       	std	Y+4, r24	; 0x04
    5564:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5566:	8c 81       	ldd	r24, Y+4	; 0x04
    5568:	9d 81       	ldd	r25, Y+5	; 0x05
    556a:	00 97       	sbiw	r24, 0x00	; 0
    556c:	39 f4       	brne	.+14     	; 0x557c <xTaskGenericNotifyStateClear+0x30>
    556e:	80 91 64 06 	lds	r24, 0x0664
    5572:	90 91 65 06 	lds	r25, 0x0665
    5576:	98 87       	std	Y+8, r25	; 0x08
    5578:	8f 83       	std	Y+7, r24	; 0x07
    557a:	04 c0       	rjmp	.+8      	; 0x5584 <xTaskGenericNotifyStateClear+0x38>
    557c:	8c 81       	ldd	r24, Y+4	; 0x04
    557e:	9d 81       	ldd	r25, Y+5	; 0x05
    5580:	98 87       	std	Y+8, r25	; 0x08
    5582:	8f 83       	std	Y+7, r24	; 0x07
    5584:	8f 81       	ldd	r24, Y+7	; 0x07
    5586:	98 85       	ldd	r25, Y+8	; 0x08
    5588:	9b 83       	std	Y+3, r25	; 0x03
    558a:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    558c:	0f b6       	in	r0, 0x3f	; 63
    558e:	f8 94       	cli
    5590:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    5592:	8e 81       	ldd	r24, Y+6	; 0x06
    5594:	28 2f       	mov	r18, r24
    5596:	30 e0       	ldi	r19, 0x00	; 0
    5598:	8a 81       	ldd	r24, Y+2	; 0x02
    559a:	9b 81       	ldd	r25, Y+3	; 0x03
    559c:	82 0f       	add	r24, r18
    559e:	93 1f       	adc	r25, r19
    55a0:	fc 01       	movw	r30, r24
    55a2:	b5 96       	adiw	r30, 0x25	; 37
    55a4:	80 81       	ld	r24, Z
    55a6:	82 30       	cpi	r24, 0x02	; 2
    55a8:	69 f4       	brne	.+26     	; 0x55c4 <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    55aa:	8e 81       	ldd	r24, Y+6	; 0x06
    55ac:	28 2f       	mov	r18, r24
    55ae:	30 e0       	ldi	r19, 0x00	; 0
    55b0:	8a 81       	ldd	r24, Y+2	; 0x02
    55b2:	9b 81       	ldd	r25, Y+3	; 0x03
    55b4:	82 0f       	add	r24, r18
    55b6:	93 1f       	adc	r25, r19
    55b8:	fc 01       	movw	r30, r24
    55ba:	b5 96       	adiw	r30, 0x25	; 37
    55bc:	10 82       	st	Z, r1
                xReturn = pdPASS;
    55be:	81 e0       	ldi	r24, 0x01	; 1
    55c0:	89 83       	std	Y+1, r24	; 0x01
    55c2:	01 c0       	rjmp	.+2      	; 0x55c6 <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    55c4:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    55c6:	0f 90       	pop	r0
    55c8:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    55ca:	89 81       	ldd	r24, Y+1	; 0x01
    }
    55cc:	28 96       	adiw	r28, 0x08	; 8
    55ce:	0f b6       	in	r0, 0x3f	; 63
    55d0:	f8 94       	cli
    55d2:	de bf       	out	0x3e, r29	; 62
    55d4:	0f be       	out	0x3f, r0	; 63
    55d6:	cd bf       	out	0x3d, r28	; 61
    55d8:	cf 91       	pop	r28
    55da:	df 91       	pop	r29
    55dc:	08 95       	ret

000055de <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    55de:	0f 93       	push	r16
    55e0:	1f 93       	push	r17
    55e2:	df 93       	push	r29
    55e4:	cf 93       	push	r28
    55e6:	cd b7       	in	r28, 0x3d	; 61
    55e8:	de b7       	in	r29, 0x3e	; 62
    55ea:	2f 97       	sbiw	r28, 0x0f	; 15
    55ec:	0f b6       	in	r0, 0x3f	; 63
    55ee:	f8 94       	cli
    55f0:	de bf       	out	0x3e, r29	; 62
    55f2:	0f be       	out	0x3f, r0	; 63
    55f4:	cd bf       	out	0x3d, r28	; 61
    55f6:	98 87       	std	Y+8, r25	; 0x08
    55f8:	8f 83       	std	Y+7, r24	; 0x07
    55fa:	69 87       	std	Y+9, r22	; 0x09
    55fc:	2a 87       	std	Y+10, r18	; 0x0a
    55fe:	3b 87       	std	Y+11, r19	; 0x0b
    5600:	4c 87       	std	Y+12, r20	; 0x0c
    5602:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5604:	8f 81       	ldd	r24, Y+7	; 0x07
    5606:	98 85       	ldd	r25, Y+8	; 0x08
    5608:	00 97       	sbiw	r24, 0x00	; 0
    560a:	39 f4       	brne	.+14     	; 0x561a <ulTaskGenericNotifyValueClear+0x3c>
    560c:	80 91 64 06 	lds	r24, 0x0664
    5610:	90 91 65 06 	lds	r25, 0x0665
    5614:	9f 87       	std	Y+15, r25	; 0x0f
    5616:	8e 87       	std	Y+14, r24	; 0x0e
    5618:	04 c0       	rjmp	.+8      	; 0x5622 <ulTaskGenericNotifyValueClear+0x44>
    561a:	8f 81       	ldd	r24, Y+7	; 0x07
    561c:	98 85       	ldd	r25, Y+8	; 0x08
    561e:	9f 87       	std	Y+15, r25	; 0x0f
    5620:	8e 87       	std	Y+14, r24	; 0x0e
    5622:	8e 85       	ldd	r24, Y+14	; 0x0e
    5624:	9f 85       	ldd	r25, Y+15	; 0x0f
    5626:	9e 83       	std	Y+6, r25	; 0x06
    5628:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    562a:	0f b6       	in	r0, 0x3f	; 63
    562c:	f8 94       	cli
    562e:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    5630:	89 85       	ldd	r24, Y+9	; 0x09
    5632:	88 2f       	mov	r24, r24
    5634:	90 e0       	ldi	r25, 0x00	; 0
    5636:	2d 81       	ldd	r18, Y+5	; 0x05
    5638:	3e 81       	ldd	r19, Y+6	; 0x06
    563a:	88 0f       	add	r24, r24
    563c:	99 1f       	adc	r25, r25
    563e:	88 0f       	add	r24, r24
    5640:	99 1f       	adc	r25, r25
    5642:	82 0f       	add	r24, r18
    5644:	93 1f       	adc	r25, r19
    5646:	fc 01       	movw	r30, r24
    5648:	b1 96       	adiw	r30, 0x21	; 33
    564a:	80 81       	ld	r24, Z
    564c:	91 81       	ldd	r25, Z+1	; 0x01
    564e:	a2 81       	ldd	r26, Z+2	; 0x02
    5650:	b3 81       	ldd	r27, Z+3	; 0x03
    5652:	89 83       	std	Y+1, r24	; 0x01
    5654:	9a 83       	std	Y+2, r25	; 0x02
    5656:	ab 83       	std	Y+3, r26	; 0x03
    5658:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    565a:	89 85       	ldd	r24, Y+9	; 0x09
    565c:	08 2f       	mov	r16, r24
    565e:	10 e0       	ldi	r17, 0x00	; 0
    5660:	89 85       	ldd	r24, Y+9	; 0x09
    5662:	88 2f       	mov	r24, r24
    5664:	90 e0       	ldi	r25, 0x00	; 0
    5666:	2d 81       	ldd	r18, Y+5	; 0x05
    5668:	3e 81       	ldd	r19, Y+6	; 0x06
    566a:	88 0f       	add	r24, r24
    566c:	99 1f       	adc	r25, r25
    566e:	88 0f       	add	r24, r24
    5670:	99 1f       	adc	r25, r25
    5672:	82 0f       	add	r24, r18
    5674:	93 1f       	adc	r25, r19
    5676:	fc 01       	movw	r30, r24
    5678:	b1 96       	adiw	r30, 0x21	; 33
    567a:	20 81       	ld	r18, Z
    567c:	31 81       	ldd	r19, Z+1	; 0x01
    567e:	42 81       	ldd	r20, Z+2	; 0x02
    5680:	53 81       	ldd	r21, Z+3	; 0x03
    5682:	8a 85       	ldd	r24, Y+10	; 0x0a
    5684:	9b 85       	ldd	r25, Y+11	; 0x0b
    5686:	ac 85       	ldd	r26, Y+12	; 0x0c
    5688:	bd 85       	ldd	r27, Y+13	; 0x0d
    568a:	80 95       	com	r24
    568c:	90 95       	com	r25
    568e:	a0 95       	com	r26
    5690:	b0 95       	com	r27
    5692:	ba 01       	movw	r22, r20
    5694:	a9 01       	movw	r20, r18
    5696:	48 23       	and	r20, r24
    5698:	59 23       	and	r21, r25
    569a:	6a 23       	and	r22, r26
    569c:	7b 23       	and	r23, r27
    569e:	2d 81       	ldd	r18, Y+5	; 0x05
    56a0:	3e 81       	ldd	r19, Y+6	; 0x06
    56a2:	c8 01       	movw	r24, r16
    56a4:	88 0f       	add	r24, r24
    56a6:	99 1f       	adc	r25, r25
    56a8:	88 0f       	add	r24, r24
    56aa:	99 1f       	adc	r25, r25
    56ac:	82 0f       	add	r24, r18
    56ae:	93 1f       	adc	r25, r19
    56b0:	fc 01       	movw	r30, r24
    56b2:	b1 96       	adiw	r30, 0x21	; 33
    56b4:	40 83       	st	Z, r20
    56b6:	51 83       	std	Z+1, r21	; 0x01
    56b8:	62 83       	std	Z+2, r22	; 0x02
    56ba:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    56bc:	0f 90       	pop	r0
    56be:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    56c0:	89 81       	ldd	r24, Y+1	; 0x01
    56c2:	9a 81       	ldd	r25, Y+2	; 0x02
    56c4:	ab 81       	ldd	r26, Y+3	; 0x03
    56c6:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    56c8:	bc 01       	movw	r22, r24
    56ca:	cd 01       	movw	r24, r26
    56cc:	2f 96       	adiw	r28, 0x0f	; 15
    56ce:	0f b6       	in	r0, 0x3f	; 63
    56d0:	f8 94       	cli
    56d2:	de bf       	out	0x3e, r29	; 62
    56d4:	0f be       	out	0x3f, r0	; 63
    56d6:	cd bf       	out	0x3d, r28	; 61
    56d8:	cf 91       	pop	r28
    56da:	df 91       	pop	r29
    56dc:	1f 91       	pop	r17
    56de:	0f 91       	pop	r16
    56e0:	08 95       	ret

000056e2 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    56e2:	df 93       	push	r29
    56e4:	cf 93       	push	r28
    56e6:	cd b7       	in	r28, 0x3d	; 61
    56e8:	de b7       	in	r29, 0x3e	; 62
    56ea:	27 97       	sbiw	r28, 0x07	; 7
    56ec:	0f b6       	in	r0, 0x3f	; 63
    56ee:	f8 94       	cli
    56f0:	de bf       	out	0x3e, r29	; 62
    56f2:	0f be       	out	0x3f, r0	; 63
    56f4:	cd bf       	out	0x3d, r28	; 61
    56f6:	9e 83       	std	Y+6, r25	; 0x06
    56f8:	8d 83       	std	Y+5, r24	; 0x05
    56fa:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    56fc:	80 91 68 06 	lds	r24, 0x0668
    5700:	90 91 69 06 	lds	r25, 0x0669
    5704:	9a 83       	std	Y+2, r25	; 0x02
    5706:	89 83       	std	Y+1, r24	; 0x01
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5708:	80 91 64 06 	lds	r24, 0x0664
    570c:	90 91 65 06 	lds	r25, 0x0665
    5710:	02 96       	adiw	r24, 0x02	; 2
    5712:	0e 94 cc 07 	call	0xf98	; 0xf98 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
    {
        /* Calculate the time at which the task should be woken if the event
         * does not occur.  This may overflow but this doesn't matter, the kernel
         * will manage it correctly. */
        xTimeToWake = xConstTickCount + xTicksToWait;
    5716:	29 81       	ldd	r18, Y+1	; 0x01
    5718:	3a 81       	ldd	r19, Y+2	; 0x02
    571a:	8d 81       	ldd	r24, Y+5	; 0x05
    571c:	9e 81       	ldd	r25, Y+6	; 0x06
    571e:	82 0f       	add	r24, r18
    5720:	93 1f       	adc	r25, r19
    5722:	9c 83       	std	Y+4, r25	; 0x04
    5724:	8b 83       	std	Y+3, r24	; 0x03

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    5726:	e0 91 64 06 	lds	r30, 0x0664
    572a:	f0 91 65 06 	lds	r31, 0x0665
    572e:	8b 81       	ldd	r24, Y+3	; 0x03
    5730:	9c 81       	ldd	r25, Y+4	; 0x04
    5732:	93 83       	std	Z+3, r25	; 0x03
    5734:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xConstTickCount )
    5736:	2b 81       	ldd	r18, Y+3	; 0x03
    5738:	3c 81       	ldd	r19, Y+4	; 0x04
    573a:	89 81       	ldd	r24, Y+1	; 0x01
    573c:	9a 81       	ldd	r25, Y+2	; 0x02
    573e:	28 17       	cp	r18, r24
    5740:	39 07       	cpc	r19, r25
    5742:	70 f4       	brcc	.+28     	; 0x5760 <prvAddCurrentTaskToDelayedList+0x7e>
        {
            /* Wake time has overflowed.  Place this item in the overflow list. */
            vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5744:	80 91 ae 06 	lds	r24, 0x06AE
    5748:	90 91 af 06 	lds	r25, 0x06AF
    574c:	20 91 64 06 	lds	r18, 0x0664
    5750:	30 91 65 06 	lds	r19, 0x0665
    5754:	2e 5f       	subi	r18, 0xFE	; 254
    5756:	3f 4f       	sbci	r19, 0xFF	; 255
    5758:	b9 01       	movw	r22, r18
    575a:	0e 94 60 07 	call	0xec0	; 0xec0 <vListInsert>
    575e:	1e c0       	rjmp	.+60     	; 0x579c <prvAddCurrentTaskToDelayedList+0xba>
        }
        else
        {
            /* The wake time has not overflowed, so the current block list is used. */
            vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5760:	40 91 ac 06 	lds	r20, 0x06AC
    5764:	50 91 ad 06 	lds	r21, 0x06AD
    5768:	80 91 64 06 	lds	r24, 0x0664
    576c:	90 91 65 06 	lds	r25, 0x0665
    5770:	9c 01       	movw	r18, r24
    5772:	2e 5f       	subi	r18, 0xFE	; 254
    5774:	3f 4f       	sbci	r19, 0xFF	; 255
    5776:	ca 01       	movw	r24, r20
    5778:	b9 01       	movw	r22, r18
    577a:	0e 94 60 07 	call	0xec0	; 0xec0 <vListInsert>

            /* If the task entering the blocked state was placed at the head of the
             * list of blocked tasks then xNextTaskUnblockTime needs to be updated
             * too. */
            if( xTimeToWake < xNextTaskUnblockTime )
    577e:	20 91 71 06 	lds	r18, 0x0671
    5782:	30 91 72 06 	lds	r19, 0x0672
    5786:	8b 81       	ldd	r24, Y+3	; 0x03
    5788:	9c 81       	ldd	r25, Y+4	; 0x04
    578a:	82 17       	cp	r24, r18
    578c:	93 07       	cpc	r25, r19
    578e:	30 f4       	brcc	.+12     	; 0x579c <prvAddCurrentTaskToDelayedList+0xba>
            {
                xNextTaskUnblockTime = xTimeToWake;
    5790:	8b 81       	ldd	r24, Y+3	; 0x03
    5792:	9c 81       	ldd	r25, Y+4	; 0x04
    5794:	90 93 72 06 	sts	0x0672, r25
    5798:	80 93 71 06 	sts	0x0671, r24

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
    579c:	27 96       	adiw	r28, 0x07	; 7
    579e:	0f b6       	in	r0, 0x3f	; 63
    57a0:	f8 94       	cli
    57a2:	de bf       	out	0x3e, r29	; 62
    57a4:	0f be       	out	0x3f, r0	; 63
    57a6:	cd bf       	out	0x3d, r28	; 61
    57a8:	cf 91       	pop	r28
    57aa:	df 91       	pop	r29
    57ac:	08 95       	ret

000057ae <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
    57ae:	ef 92       	push	r14
    57b0:	ff 92       	push	r15
    57b2:	0f 93       	push	r16
    57b4:	df 93       	push	r29
    57b6:	cf 93       	push	r28
    57b8:	0f 92       	push	r0
    57ba:	cd b7       	in	r28, 0x3d	; 61
    57bc:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn = pdFAIL;
    57be:	19 82       	std	Y+1, r1	; 0x01

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
    57c0:	0e 94 a6 30 	call	0x614c	; 0x614c <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
    57c4:	80 91 c2 06 	lds	r24, 0x06C2
    57c8:	90 91 c3 06 	lds	r25, 0x06C3
    57cc:	00 97       	sbiw	r24, 0x00	; 0
    57ce:	81 f0       	breq	.+32     	; 0x57f0 <xTimerCreateTimerTask+0x42>
                    xReturn = pdPASS;
                }
            }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
            {
                xReturn = xTaskCreate( prvTimerTask,
    57d0:	88 e3       	ldi	r24, 0x38	; 56
    57d2:	9e e2       	ldi	r25, 0x2E	; 46
    57d4:	25 e6       	ldi	r18, 0x65	; 101
    57d6:	30 e0       	ldi	r19, 0x00	; 0
    57d8:	e4 ec       	ldi	r30, 0xC4	; 196
    57da:	f6 e0       	ldi	r31, 0x06	; 6
    57dc:	b9 01       	movw	r22, r18
    57de:	45 e5       	ldi	r20, 0x55	; 85
    57e0:	50 e0       	ldi	r21, 0x00	; 0
    57e2:	20 e0       	ldi	r18, 0x00	; 0
    57e4:	30 e0       	ldi	r19, 0x00	; 0
    57e6:	03 e0       	ldi	r16, 0x03	; 3
    57e8:	7f 01       	movw	r14, r30
    57ea:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <xTaskCreate>
    57ee:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
        return xReturn;
    57f0:	89 81       	ldd	r24, Y+1	; 0x01
    }
    57f2:	0f 90       	pop	r0
    57f4:	cf 91       	pop	r28
    57f6:	df 91       	pop	r29
    57f8:	0f 91       	pop	r16
    57fa:	ff 90       	pop	r15
    57fc:	ef 90       	pop	r14
    57fe:	08 95       	ret

00005800 <xTimerCreate>:
        TimerHandle_t xTimerCreate( const char * const pcTimerName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                    const TickType_t xTimerPeriodInTicks,
                                    const BaseType_t xAutoReload,
                                    void * const pvTimerID,
                                    TimerCallbackFunction_t pxCallbackFunction )
        {
    5800:	ef 92       	push	r14
    5802:	ff 92       	push	r15
    5804:	0f 93       	push	r16
    5806:	1f 93       	push	r17
    5808:	df 93       	push	r29
    580a:	cf 93       	push	r28
    580c:	cd b7       	in	r28, 0x3d	; 61
    580e:	de b7       	in	r29, 0x3e	; 62
    5810:	2b 97       	sbiw	r28, 0x0b	; 11
    5812:	0f b6       	in	r0, 0x3f	; 63
    5814:	f8 94       	cli
    5816:	de bf       	out	0x3e, r29	; 62
    5818:	0f be       	out	0x3f, r0	; 63
    581a:	cd bf       	out	0x3d, r28	; 61
    581c:	9c 83       	std	Y+4, r25	; 0x04
    581e:	8b 83       	std	Y+3, r24	; 0x03
    5820:	7e 83       	std	Y+6, r23	; 0x06
    5822:	6d 83       	std	Y+5, r22	; 0x05
    5824:	4f 83       	std	Y+7, r20	; 0x07
    5826:	39 87       	std	Y+9, r19	; 0x09
    5828:	28 87       	std	Y+8, r18	; 0x08
    582a:	1b 87       	std	Y+11, r17	; 0x0b
    582c:	0a 87       	std	Y+10, r16	; 0x0a
            Timer_t * pxNewTimer;

            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
    582e:	83 e1       	ldi	r24, 0x13	; 19
    5830:	90 e0       	ldi	r25, 0x00	; 0
    5832:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    5836:	9a 83       	std	Y+2, r25	; 0x02
    5838:	89 83       	std	Y+1, r24	; 0x01

            if( pxNewTimer != NULL )
    583a:	89 81       	ldd	r24, Y+1	; 0x01
    583c:	9a 81       	ldd	r25, Y+2	; 0x02
    583e:	00 97       	sbiw	r24, 0x00	; 0
    5840:	99 f0       	breq	.+38     	; 0x5868 <xTimerCreate+0x68>
            {
                /* Status is thus far zero as the timer is not created statically
                 * and has not been started.  The auto-reload bit may get set in
                 * prvInitialiseNewTimer. */
                pxNewTimer->ucStatus = 0x00;
    5842:	e9 81       	ldd	r30, Y+1	; 0x01
    5844:	fa 81       	ldd	r31, Y+2	; 0x02
    5846:	12 8a       	std	Z+18, r1	; 0x12
                prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, xAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
    5848:	8b 81       	ldd	r24, Y+3	; 0x03
    584a:	9c 81       	ldd	r25, Y+4	; 0x04
    584c:	2d 81       	ldd	r18, Y+5	; 0x05
    584e:	3e 81       	ldd	r19, Y+6	; 0x06
    5850:	e8 85       	ldd	r30, Y+8	; 0x08
    5852:	f9 85       	ldd	r31, Y+9	; 0x09
    5854:	aa 85       	ldd	r26, Y+10	; 0x0a
    5856:	bb 85       	ldd	r27, Y+11	; 0x0b
    5858:	e9 80       	ldd	r14, Y+1	; 0x01
    585a:	fa 80       	ldd	r15, Y+2	; 0x02
    585c:	b9 01       	movw	r22, r18
    585e:	4f 81       	ldd	r20, Y+7	; 0x07
    5860:	9f 01       	movw	r18, r30
    5862:	8d 01       	movw	r16, r26
    5864:	0e 94 43 2c 	call	0x5886	; 0x5886 <prvInitialiseNewTimer>
            }

            return pxNewTimer;
    5868:	89 81       	ldd	r24, Y+1	; 0x01
    586a:	9a 81       	ldd	r25, Y+2	; 0x02
        }
    586c:	2b 96       	adiw	r28, 0x0b	; 11
    586e:	0f b6       	in	r0, 0x3f	; 63
    5870:	f8 94       	cli
    5872:	de bf       	out	0x3e, r29	; 62
    5874:	0f be       	out	0x3f, r0	; 63
    5876:	cd bf       	out	0x3d, r28	; 61
    5878:	cf 91       	pop	r28
    587a:	df 91       	pop	r29
    587c:	1f 91       	pop	r17
    587e:	0f 91       	pop	r16
    5880:	ff 90       	pop	r15
    5882:	ef 90       	pop	r14
    5884:	08 95       	ret

00005886 <prvInitialiseNewTimer>:
                                       const TickType_t xTimerPeriodInTicks,
                                       const BaseType_t xAutoReload,
                                       void * const pvTimerID,
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer )
    {
    5886:	ef 92       	push	r14
    5888:	ff 92       	push	r15
    588a:	0f 93       	push	r16
    588c:	1f 93       	push	r17
    588e:	df 93       	push	r29
    5890:	cf 93       	push	r28
    5892:	cd b7       	in	r28, 0x3d	; 61
    5894:	de b7       	in	r29, 0x3e	; 62
    5896:	2b 97       	sbiw	r28, 0x0b	; 11
    5898:	0f b6       	in	r0, 0x3f	; 63
    589a:	f8 94       	cli
    589c:	de bf       	out	0x3e, r29	; 62
    589e:	0f be       	out	0x3f, r0	; 63
    58a0:	cd bf       	out	0x3d, r28	; 61
    58a2:	9a 83       	std	Y+2, r25	; 0x02
    58a4:	89 83       	std	Y+1, r24	; 0x01
    58a6:	7c 83       	std	Y+4, r23	; 0x04
    58a8:	6b 83       	std	Y+3, r22	; 0x03
    58aa:	4d 83       	std	Y+5, r20	; 0x05
    58ac:	3f 83       	std	Y+7, r19	; 0x07
    58ae:	2e 83       	std	Y+6, r18	; 0x06
    58b0:	19 87       	std	Y+9, r17	; 0x09
    58b2:	08 87       	std	Y+8, r16	; 0x08
    58b4:	fb 86       	std	Y+11, r15	; 0x0b
    58b6:	ea 86       	std	Y+10, r14	; 0x0a
        /* 0 is not a valid value for xTimerPeriodInTicks. */
        configASSERT( ( xTimerPeriodInTicks > 0 ) );

        /* Ensure the infrastructure used by the timer service task has been
         * created/initialised. */
        prvCheckForValidListAndQueue();
    58b8:	0e 94 a6 30 	call	0x614c	; 0x614c <prvCheckForValidListAndQueue>

        /* Initialise the timer structure members using the function
         * parameters. */
        pxNewTimer->pcTimerName = pcTimerName;
    58bc:	ea 85       	ldd	r30, Y+10	; 0x0a
    58be:	fb 85       	ldd	r31, Y+11	; 0x0b
    58c0:	89 81       	ldd	r24, Y+1	; 0x01
    58c2:	9a 81       	ldd	r25, Y+2	; 0x02
    58c4:	91 83       	std	Z+1, r25	; 0x01
    58c6:	80 83       	st	Z, r24
        pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    58c8:	ea 85       	ldd	r30, Y+10	; 0x0a
    58ca:	fb 85       	ldd	r31, Y+11	; 0x0b
    58cc:	8b 81       	ldd	r24, Y+3	; 0x03
    58ce:	9c 81       	ldd	r25, Y+4	; 0x04
    58d0:	95 87       	std	Z+13, r25	; 0x0d
    58d2:	84 87       	std	Z+12, r24	; 0x0c
        pxNewTimer->pvTimerID = pvTimerID;
    58d4:	ea 85       	ldd	r30, Y+10	; 0x0a
    58d6:	fb 85       	ldd	r31, Y+11	; 0x0b
    58d8:	8e 81       	ldd	r24, Y+6	; 0x06
    58da:	9f 81       	ldd	r25, Y+7	; 0x07
    58dc:	97 87       	std	Z+15, r25	; 0x0f
    58de:	86 87       	std	Z+14, r24	; 0x0e
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    58e0:	ea 85       	ldd	r30, Y+10	; 0x0a
    58e2:	fb 85       	ldd	r31, Y+11	; 0x0b
    58e4:	88 85       	ldd	r24, Y+8	; 0x08
    58e6:	99 85       	ldd	r25, Y+9	; 0x09
    58e8:	91 8b       	std	Z+17, r25	; 0x11
    58ea:	80 8b       	std	Z+16, r24	; 0x10
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    58ec:	8a 85       	ldd	r24, Y+10	; 0x0a
    58ee:	9b 85       	ldd	r25, Y+11	; 0x0b
    58f0:	02 96       	adiw	r24, 0x02	; 2
    58f2:	0e 94 0c 07 	call	0xe18	; 0xe18 <vListInitialiseItem>

        if( xAutoReload != pdFALSE )
    58f6:	8d 81       	ldd	r24, Y+5	; 0x05
    58f8:	88 23       	and	r24, r24
    58fa:	39 f0       	breq	.+14     	; 0x590a <prvInitialiseNewTimer+0x84>
        {
            pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    58fc:	ea 85       	ldd	r30, Y+10	; 0x0a
    58fe:	fb 85       	ldd	r31, Y+11	; 0x0b
    5900:	82 89       	ldd	r24, Z+18	; 0x12
    5902:	84 60       	ori	r24, 0x04	; 4
    5904:	ea 85       	ldd	r30, Y+10	; 0x0a
    5906:	fb 85       	ldd	r31, Y+11	; 0x0b
    5908:	82 8b       	std	Z+18, r24	; 0x12
        }

        traceTIMER_CREATE( pxNewTimer );
    }
    590a:	2b 96       	adiw	r28, 0x0b	; 11
    590c:	0f b6       	in	r0, 0x3f	; 63
    590e:	f8 94       	cli
    5910:	de bf       	out	0x3e, r29	; 62
    5912:	0f be       	out	0x3f, r0	; 63
    5914:	cd bf       	out	0x3d, r28	; 61
    5916:	cf 91       	pop	r28
    5918:	df 91       	pop	r29
    591a:	1f 91       	pop	r17
    591c:	0f 91       	pop	r16
    591e:	ff 90       	pop	r15
    5920:	ef 90       	pop	r14
    5922:	08 95       	ret

00005924 <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
    5924:	0f 93       	push	r16
    5926:	1f 93       	push	r17
    5928:	df 93       	push	r29
    592a:	cf 93       	push	r28
    592c:	cd b7       	in	r28, 0x3d	; 61
    592e:	de b7       	in	r29, 0x3e	; 62
    5930:	2f 97       	sbiw	r28, 0x0f	; 15
    5932:	0f b6       	in	r0, 0x3f	; 63
    5934:	f8 94       	cli
    5936:	de bf       	out	0x3e, r29	; 62
    5938:	0f be       	out	0x3f, r0	; 63
    593a:	cd bf       	out	0x3d, r28	; 61
    593c:	98 87       	std	Y+8, r25	; 0x08
    593e:	8f 83       	std	Y+7, r24	; 0x07
    5940:	69 87       	std	Y+9, r22	; 0x09
    5942:	5b 87       	std	Y+11, r21	; 0x0b
    5944:	4a 87       	std	Y+10, r20	; 0x0a
    5946:	3d 87       	std	Y+13, r19	; 0x0d
    5948:	2c 87       	std	Y+12, r18	; 0x0c
    594a:	1f 87       	std	Y+15, r17	; 0x0f
    594c:	0e 87       	std	Y+14, r16	; 0x0e
        BaseType_t xReturn = pdFAIL;
    594e:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTimer );

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
    5950:	80 91 c2 06 	lds	r24, 0x06C2
    5954:	90 91 c3 06 	lds	r25, 0x06C3
    5958:	00 97       	sbiw	r24, 0x00	; 0
    595a:	e9 f1       	breq	.+122    	; 0x59d6 <xTimerGenericCommand+0xb2>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
    595c:	89 85       	ldd	r24, Y+9	; 0x09
    595e:	8a 83       	std	Y+2, r24	; 0x02
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    5960:	8a 85       	ldd	r24, Y+10	; 0x0a
    5962:	9b 85       	ldd	r25, Y+11	; 0x0b
    5964:	9c 83       	std	Y+4, r25	; 0x04
    5966:	8b 83       	std	Y+3, r24	; 0x03
            xMessage.u.xTimerParameters.pxTimer = xTimer;
    5968:	8f 81       	ldd	r24, Y+7	; 0x07
    596a:	98 85       	ldd	r25, Y+8	; 0x08
    596c:	9e 83       	std	Y+6, r25	; 0x06
    596e:	8d 83       	std	Y+5, r24	; 0x05

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    5970:	89 85       	ldd	r24, Y+9	; 0x09
    5972:	86 30       	cpi	r24, 0x06	; 6
    5974:	14 f5       	brge	.+68     	; 0x59ba <xTimerGenericCommand+0x96>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    5976:	0e 94 ac 23 	call	0x4758	; 0x4758 <xTaskGetSchedulerState>
    597a:	82 30       	cpi	r24, 0x02	; 2
    597c:	79 f4       	brne	.+30     	; 0x599c <xTimerGenericCommand+0x78>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    597e:	80 91 c2 06 	lds	r24, 0x06C2
    5982:	90 91 c3 06 	lds	r25, 0x06C3
    5986:	9e 01       	movw	r18, r28
    5988:	2e 5f       	subi	r18, 0xFE	; 254
    598a:	3f 4f       	sbci	r19, 0xFF	; 255
    598c:	4e 85       	ldd	r20, Y+14	; 0x0e
    598e:	5f 85       	ldd	r21, Y+15	; 0x0f
    5990:	b9 01       	movw	r22, r18
    5992:	20 e0       	ldi	r18, 0x00	; 0
    5994:	0e 94 72 09 	call	0x12e4	; 0x12e4 <xQueueGenericSend>
    5998:	89 83       	std	Y+1, r24	; 0x01
    599a:	1d c0       	rjmp	.+58     	; 0x59d6 <xTimerGenericCommand+0xb2>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    599c:	80 91 c2 06 	lds	r24, 0x06C2
    59a0:	90 91 c3 06 	lds	r25, 0x06C3
    59a4:	9e 01       	movw	r18, r28
    59a6:	2e 5f       	subi	r18, 0xFE	; 254
    59a8:	3f 4f       	sbci	r19, 0xFF	; 255
    59aa:	b9 01       	movw	r22, r18
    59ac:	40 e0       	ldi	r20, 0x00	; 0
    59ae:	50 e0       	ldi	r21, 0x00	; 0
    59b0:	20 e0       	ldi	r18, 0x00	; 0
    59b2:	0e 94 72 09 	call	0x12e4	; 0x12e4 <xQueueGenericSend>
    59b6:	89 83       	std	Y+1, r24	; 0x01
    59b8:	0e c0       	rjmp	.+28     	; 0x59d6 <xTimerGenericCommand+0xb2>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    59ba:	80 91 c2 06 	lds	r24, 0x06C2
    59be:	90 91 c3 06 	lds	r25, 0x06C3
    59c2:	9e 01       	movw	r18, r28
    59c4:	2e 5f       	subi	r18, 0xFE	; 254
    59c6:	3f 4f       	sbci	r19, 0xFF	; 255
    59c8:	4c 85       	ldd	r20, Y+12	; 0x0c
    59ca:	5d 85       	ldd	r21, Y+13	; 0x0d
    59cc:	b9 01       	movw	r22, r18
    59ce:	20 e0       	ldi	r18, 0x00	; 0
    59d0:	0e 94 1e 0a 	call	0x143c	; 0x143c <xQueueGenericSendFromISR>
    59d4:	89 83       	std	Y+1, r24	; 0x01
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    59d6:	89 81       	ldd	r24, Y+1	; 0x01
    }
    59d8:	2f 96       	adiw	r28, 0x0f	; 15
    59da:	0f b6       	in	r0, 0x3f	; 63
    59dc:	f8 94       	cli
    59de:	de bf       	out	0x3e, r29	; 62
    59e0:	0f be       	out	0x3f, r0	; 63
    59e2:	cd bf       	out	0x3d, r28	; 61
    59e4:	cf 91       	pop	r28
    59e6:	df 91       	pop	r29
    59e8:	1f 91       	pop	r17
    59ea:	0f 91       	pop	r16
    59ec:	08 95       	ret

000059ee <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    {
    59ee:	df 93       	push	r29
    59f0:	cf 93       	push	r28
    59f2:	cd b7       	in	r28, 0x3d	; 61
    59f4:	de b7       	in	r29, 0x3e	; 62
        /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
         * started, then xTimerTaskHandle will be NULL. */
        configASSERT( ( xTimerTaskHandle != NULL ) );
        return xTimerTaskHandle;
    59f6:	80 91 c4 06 	lds	r24, 0x06C4
    59fa:	90 91 c5 06 	lds	r25, 0x06C5
    }
    59fe:	cf 91       	pop	r28
    5a00:	df 91       	pop	r29
    5a02:	08 95       	ret

00005a04 <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
    {
    5a04:	df 93       	push	r29
    5a06:	cf 93       	push	r28
    5a08:	00 d0       	rcall	.+0      	; 0x5a0a <xTimerGetPeriod+0x6>
    5a0a:	00 d0       	rcall	.+0      	; 0x5a0c <xTimerGetPeriod+0x8>
    5a0c:	cd b7       	in	r28, 0x3d	; 61
    5a0e:	de b7       	in	r29, 0x3e	; 62
    5a10:	9c 83       	std	Y+4, r25	; 0x04
    5a12:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    5a14:	8b 81       	ldd	r24, Y+3	; 0x03
    5a16:	9c 81       	ldd	r25, Y+4	; 0x04
    5a18:	9a 83       	std	Y+2, r25	; 0x02
    5a1a:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->xTimerPeriodInTicks;
    5a1c:	e9 81       	ldd	r30, Y+1	; 0x01
    5a1e:	fa 81       	ldd	r31, Y+2	; 0x02
    5a20:	84 85       	ldd	r24, Z+12	; 0x0c
    5a22:	95 85       	ldd	r25, Z+13	; 0x0d
    }
    5a24:	0f 90       	pop	r0
    5a26:	0f 90       	pop	r0
    5a28:	0f 90       	pop	r0
    5a2a:	0f 90       	pop	r0
    5a2c:	cf 91       	pop	r28
    5a2e:	df 91       	pop	r29
    5a30:	08 95       	ret

00005a32 <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

    void vTimerSetReloadMode( TimerHandle_t xTimer,
                              const BaseType_t xAutoReload )
    {
    5a32:	df 93       	push	r29
    5a34:	cf 93       	push	r28
    5a36:	00 d0       	rcall	.+0      	; 0x5a38 <vTimerSetReloadMode+0x6>
    5a38:	00 d0       	rcall	.+0      	; 0x5a3a <vTimerSetReloadMode+0x8>
    5a3a:	0f 92       	push	r0
    5a3c:	cd b7       	in	r28, 0x3d	; 61
    5a3e:	de b7       	in	r29, 0x3e	; 62
    5a40:	9c 83       	std	Y+4, r25	; 0x04
    5a42:	8b 83       	std	Y+3, r24	; 0x03
    5a44:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * pxTimer = xTimer;
    5a46:	8b 81       	ldd	r24, Y+3	; 0x03
    5a48:	9c 81       	ldd	r25, Y+4	; 0x04
    5a4a:	9a 83       	std	Y+2, r25	; 0x02
    5a4c:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    5a4e:	0f b6       	in	r0, 0x3f	; 63
    5a50:	f8 94       	cli
    5a52:	0f 92       	push	r0
        {
            if( xAutoReload != pdFALSE )
    5a54:	8d 81       	ldd	r24, Y+5	; 0x05
    5a56:	88 23       	and	r24, r24
    5a58:	41 f0       	breq	.+16     	; 0x5a6a <vTimerSetReloadMode+0x38>
            {
                pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    5a5a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a5c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a5e:	82 89       	ldd	r24, Z+18	; 0x12
    5a60:	84 60       	ori	r24, 0x04	; 4
    5a62:	e9 81       	ldd	r30, Y+1	; 0x01
    5a64:	fa 81       	ldd	r31, Y+2	; 0x02
    5a66:	82 8b       	std	Z+18, r24	; 0x12
    5a68:	07 c0       	rjmp	.+14     	; 0x5a78 <vTimerSetReloadMode+0x46>
            }
            else
            {
                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD );
    5a6a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a6c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a6e:	82 89       	ldd	r24, Z+18	; 0x12
    5a70:	8b 7f       	andi	r24, 0xFB	; 251
    5a72:	e9 81       	ldd	r30, Y+1	; 0x01
    5a74:	fa 81       	ldd	r31, Y+2	; 0x02
    5a76:	82 8b       	std	Z+18, r24	; 0x12
            }
        }
        taskEXIT_CRITICAL();
    5a78:	0f 90       	pop	r0
    5a7a:	0f be       	out	0x3f, r0	; 63
    }
    5a7c:	0f 90       	pop	r0
    5a7e:	0f 90       	pop	r0
    5a80:	0f 90       	pop	r0
    5a82:	0f 90       	pop	r0
    5a84:	0f 90       	pop	r0
    5a86:	cf 91       	pop	r28
    5a88:	df 91       	pop	r29
    5a8a:	08 95       	ret

00005a8c <xTimerGetReloadMode>:
/*-----------------------------------------------------------*/

    BaseType_t xTimerGetReloadMode( TimerHandle_t xTimer )
    {
    5a8c:	df 93       	push	r29
    5a8e:	cf 93       	push	r28
    5a90:	00 d0       	rcall	.+0      	; 0x5a92 <xTimerGetReloadMode+0x6>
    5a92:	00 d0       	rcall	.+0      	; 0x5a94 <xTimerGetReloadMode+0x8>
    5a94:	0f 92       	push	r0
    5a96:	cd b7       	in	r28, 0x3d	; 61
    5a98:	de b7       	in	r29, 0x3e	; 62
    5a9a:	9d 83       	std	Y+5, r25	; 0x05
    5a9c:	8c 83       	std	Y+4, r24	; 0x04
        Timer_t * pxTimer = xTimer;
    5a9e:	8c 81       	ldd	r24, Y+4	; 0x04
    5aa0:	9d 81       	ldd	r25, Y+5	; 0x05
    5aa2:	9b 83       	std	Y+3, r25	; 0x03
    5aa4:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xReturn;

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    5aa6:	0f b6       	in	r0, 0x3f	; 63
    5aa8:	f8 94       	cli
    5aaa:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
    5aac:	ea 81       	ldd	r30, Y+2	; 0x02
    5aae:	fb 81       	ldd	r31, Y+3	; 0x03
    5ab0:	82 89       	ldd	r24, Z+18	; 0x12
    5ab2:	88 2f       	mov	r24, r24
    5ab4:	90 e0       	ldi	r25, 0x00	; 0
    5ab6:	84 70       	andi	r24, 0x04	; 4
    5ab8:	90 70       	andi	r25, 0x00	; 0
    5aba:	00 97       	sbiw	r24, 0x00	; 0
    5abc:	11 f4       	brne	.+4      	; 0x5ac2 <xTimerGetReloadMode+0x36>
            {
                /* Not an auto-reload timer. */
                xReturn = pdFALSE;
    5abe:	19 82       	std	Y+1, r1	; 0x01
    5ac0:	02 c0       	rjmp	.+4      	; 0x5ac6 <xTimerGetReloadMode+0x3a>
            }
            else
            {
                /* Is an auto-reload timer. */
                xReturn = pdTRUE;
    5ac2:	81 e0       	ldi	r24, 0x01	; 1
    5ac4:	89 83       	std	Y+1, r24	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    5ac6:	0f 90       	pop	r0
    5ac8:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5aca:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5acc:	0f 90       	pop	r0
    5ace:	0f 90       	pop	r0
    5ad0:	0f 90       	pop	r0
    5ad2:	0f 90       	pop	r0
    5ad4:	0f 90       	pop	r0
    5ad6:	cf 91       	pop	r28
    5ad8:	df 91       	pop	r29
    5ada:	08 95       	ret

00005adc <uxTimerGetReloadMode>:

    UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
    {
    5adc:	df 93       	push	r29
    5ade:	cf 93       	push	r28
    5ae0:	00 d0       	rcall	.+0      	; 0x5ae2 <uxTimerGetReloadMode+0x6>
    5ae2:	cd b7       	in	r28, 0x3d	; 61
    5ae4:	de b7       	in	r29, 0x3e	; 62
    5ae6:	9a 83       	std	Y+2, r25	; 0x02
    5ae8:	89 83       	std	Y+1, r24	; 0x01
        return ( UBaseType_t ) xTimerGetReloadMode( xTimer );
    5aea:	89 81       	ldd	r24, Y+1	; 0x01
    5aec:	9a 81       	ldd	r25, Y+2	; 0x02
    5aee:	0e 94 46 2d 	call	0x5a8c	; 0x5a8c <xTimerGetReloadMode>
    }
    5af2:	0f 90       	pop	r0
    5af4:	0f 90       	pop	r0
    5af6:	cf 91       	pop	r28
    5af8:	df 91       	pop	r29
    5afa:	08 95       	ret

00005afc <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
    {
    5afc:	df 93       	push	r29
    5afe:	cf 93       	push	r28
    5b00:	00 d0       	rcall	.+0      	; 0x5b02 <xTimerGetExpiryTime+0x6>
    5b02:	00 d0       	rcall	.+0      	; 0x5b04 <xTimerGetExpiryTime+0x8>
    5b04:	00 d0       	rcall	.+0      	; 0x5b06 <xTimerGetExpiryTime+0xa>
    5b06:	cd b7       	in	r28, 0x3d	; 61
    5b08:	de b7       	in	r29, 0x3e	; 62
    5b0a:	9e 83       	std	Y+6, r25	; 0x06
    5b0c:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * pxTimer = xTimer;
    5b0e:	8d 81       	ldd	r24, Y+5	; 0x05
    5b10:	9e 81       	ldd	r25, Y+6	; 0x06
    5b12:	9c 83       	std	Y+4, r25	; 0x04
    5b14:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xReturn;

        configASSERT( xTimer );
        xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
    5b16:	eb 81       	ldd	r30, Y+3	; 0x03
    5b18:	fc 81       	ldd	r31, Y+4	; 0x04
    5b1a:	82 81       	ldd	r24, Z+2	; 0x02
    5b1c:	93 81       	ldd	r25, Z+3	; 0x03
    5b1e:	9a 83       	std	Y+2, r25	; 0x02
    5b20:	89 83       	std	Y+1, r24	; 0x01
        return xReturn;
    5b22:	89 81       	ldd	r24, Y+1	; 0x01
    5b24:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5b26:	26 96       	adiw	r28, 0x06	; 6
    5b28:	0f b6       	in	r0, 0x3f	; 63
    5b2a:	f8 94       	cli
    5b2c:	de bf       	out	0x3e, r29	; 62
    5b2e:	0f be       	out	0x3f, r0	; 63
    5b30:	cd bf       	out	0x3d, r28	; 61
    5b32:	cf 91       	pop	r28
    5b34:	df 91       	pop	r29
    5b36:	08 95       	ret

00005b38 <pcTimerGetName>:
/*-----------------------------------------------------------*/

    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
    5b38:	df 93       	push	r29
    5b3a:	cf 93       	push	r28
    5b3c:	00 d0       	rcall	.+0      	; 0x5b3e <pcTimerGetName+0x6>
    5b3e:	00 d0       	rcall	.+0      	; 0x5b40 <pcTimerGetName+0x8>
    5b40:	cd b7       	in	r28, 0x3d	; 61
    5b42:	de b7       	in	r29, 0x3e	; 62
    5b44:	9c 83       	std	Y+4, r25	; 0x04
    5b46:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    5b48:	8b 81       	ldd	r24, Y+3	; 0x03
    5b4a:	9c 81       	ldd	r25, Y+4	; 0x04
    5b4c:	9a 83       	std	Y+2, r25	; 0x02
    5b4e:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->pcTimerName;
    5b50:	e9 81       	ldd	r30, Y+1	; 0x01
    5b52:	fa 81       	ldd	r31, Y+2	; 0x02
    5b54:	80 81       	ld	r24, Z
    5b56:	91 81       	ldd	r25, Z+1	; 0x01
    }
    5b58:	0f 90       	pop	r0
    5b5a:	0f 90       	pop	r0
    5b5c:	0f 90       	pop	r0
    5b5e:	0f 90       	pop	r0
    5b60:	cf 91       	pop	r28
    5b62:	df 91       	pop	r29
    5b64:	08 95       	ret

00005b66 <prvReloadTimer>:
/*-----------------------------------------------------------*/

    static void prvReloadTimer( Timer_t * const pxTimer,
                                TickType_t xExpiredTime,
                                const TickType_t xTimeNow )
    {
    5b66:	df 93       	push	r29
    5b68:	cf 93       	push	r28
    5b6a:	00 d0       	rcall	.+0      	; 0x5b6c <prvReloadTimer+0x6>
    5b6c:	00 d0       	rcall	.+0      	; 0x5b6e <prvReloadTimer+0x8>
    5b6e:	00 d0       	rcall	.+0      	; 0x5b70 <prvReloadTimer+0xa>
    5b70:	cd b7       	in	r28, 0x3d	; 61
    5b72:	de b7       	in	r29, 0x3e	; 62
    5b74:	9a 83       	std	Y+2, r25	; 0x02
    5b76:	89 83       	std	Y+1, r24	; 0x01
    5b78:	7c 83       	std	Y+4, r23	; 0x04
    5b7a:	6b 83       	std	Y+3, r22	; 0x03
    5b7c:	5e 83       	std	Y+6, r21	; 0x06
    5b7e:	4d 83       	std	Y+5, r20	; 0x05
    5b80:	12 c0       	rjmp	.+36     	; 0x5ba6 <prvReloadTimer+0x40>
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
        {
            /* Advance the expiry time. */
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
    5b82:	e9 81       	ldd	r30, Y+1	; 0x01
    5b84:	fa 81       	ldd	r31, Y+2	; 0x02
    5b86:	24 85       	ldd	r18, Z+12	; 0x0c
    5b88:	35 85       	ldd	r19, Z+13	; 0x0d
    5b8a:	8b 81       	ldd	r24, Y+3	; 0x03
    5b8c:	9c 81       	ldd	r25, Y+4	; 0x04
    5b8e:	82 0f       	add	r24, r18
    5b90:	93 1f       	adc	r25, r19
    5b92:	9c 83       	std	Y+4, r25	; 0x04
    5b94:	8b 83       	std	Y+3, r24	; 0x03

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    5b96:	e9 81       	ldd	r30, Y+1	; 0x01
    5b98:	fa 81       	ldd	r31, Y+2	; 0x02
    5b9a:	00 88       	ldd	r0, Z+16	; 0x10
    5b9c:	f1 89       	ldd	r31, Z+17	; 0x11
    5b9e:	e0 2d       	mov	r30, r0
    5ba0:	89 81       	ldd	r24, Y+1	; 0x01
    5ba2:	9a 81       	ldd	r25, Y+2	; 0x02
    5ba4:	09 95       	icall
                                const TickType_t xTimeNow )
    {
        /* Insert the timer into the appropriate list for the next expiry time.
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
    5ba6:	e9 81       	ldd	r30, Y+1	; 0x01
    5ba8:	fa 81       	ldd	r31, Y+2	; 0x02
    5baa:	24 85       	ldd	r18, Z+12	; 0x0c
    5bac:	35 85       	ldd	r19, Z+13	; 0x0d
    5bae:	8b 81       	ldd	r24, Y+3	; 0x03
    5bb0:	9c 81       	ldd	r25, Y+4	; 0x04
    5bb2:	a9 01       	movw	r20, r18
    5bb4:	48 0f       	add	r20, r24
    5bb6:	59 1f       	adc	r21, r25
    5bb8:	89 81       	ldd	r24, Y+1	; 0x01
    5bba:	9a 81       	ldd	r25, Y+2	; 0x02
    5bbc:	2d 81       	ldd	r18, Y+5	; 0x05
    5bbe:	3e 81       	ldd	r19, Y+6	; 0x06
    5bc0:	eb 81       	ldd	r30, Y+3	; 0x03
    5bc2:	fc 81       	ldd	r31, Y+4	; 0x04
    5bc4:	ba 01       	movw	r22, r20
    5bc6:	a9 01       	movw	r20, r18
    5bc8:	9f 01       	movw	r18, r30
    5bca:	0e 94 09 2f 	call	0x5e12	; 0x5e12 <prvInsertTimerInActiveList>
    5bce:	88 23       	and	r24, r24
    5bd0:	c1 f6       	brne	.-80     	; 0x5b82 <prvReloadTimer+0x1c>

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
        }
    }
    5bd2:	26 96       	adiw	r28, 0x06	; 6
    5bd4:	0f b6       	in	r0, 0x3f	; 63
    5bd6:	f8 94       	cli
    5bd8:	de bf       	out	0x3e, r29	; 62
    5bda:	0f be       	out	0x3f, r0	; 63
    5bdc:	cd bf       	out	0x3d, r28	; 61
    5bde:	cf 91       	pop	r28
    5be0:	df 91       	pop	r29
    5be2:	08 95       	ret

00005be4 <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
    5be4:	df 93       	push	r29
    5be6:	cf 93       	push	r28
    5be8:	00 d0       	rcall	.+0      	; 0x5bea <prvProcessExpiredTimer+0x6>
    5bea:	00 d0       	rcall	.+0      	; 0x5bec <prvProcessExpiredTimer+0x8>
    5bec:	00 d0       	rcall	.+0      	; 0x5bee <prvProcessExpiredTimer+0xa>
    5bee:	cd b7       	in	r28, 0x3d	; 61
    5bf0:	de b7       	in	r29, 0x3e	; 62
    5bf2:	9c 83       	std	Y+4, r25	; 0x04
    5bf4:	8b 83       	std	Y+3, r24	; 0x03
    5bf6:	7e 83       	std	Y+6, r23	; 0x06
    5bf8:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5bfa:	e0 91 da 06 	lds	r30, 0x06DA
    5bfe:	f0 91 db 06 	lds	r31, 0x06DB
    5c02:	05 80       	ldd	r0, Z+5	; 0x05
    5c04:	f6 81       	ldd	r31, Z+6	; 0x06
    5c06:	e0 2d       	mov	r30, r0
    5c08:	86 81       	ldd	r24, Z+6	; 0x06
    5c0a:	97 81       	ldd	r25, Z+7	; 0x07
    5c0c:	9a 83       	std	Y+2, r25	; 0x02
    5c0e:	89 83       	std	Y+1, r24	; 0x01

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    5c10:	89 81       	ldd	r24, Y+1	; 0x01
    5c12:	9a 81       	ldd	r25, Y+2	; 0x02
    5c14:	02 96       	adiw	r24, 0x02	; 2
    5c16:	0e 94 cc 07 	call	0xf98	; 0xf98 <uxListRemove>

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    5c1a:	e9 81       	ldd	r30, Y+1	; 0x01
    5c1c:	fa 81       	ldd	r31, Y+2	; 0x02
    5c1e:	82 89       	ldd	r24, Z+18	; 0x12
    5c20:	88 2f       	mov	r24, r24
    5c22:	90 e0       	ldi	r25, 0x00	; 0
    5c24:	84 70       	andi	r24, 0x04	; 4
    5c26:	90 70       	andi	r25, 0x00	; 0
    5c28:	00 97       	sbiw	r24, 0x00	; 0
    5c2a:	51 f0       	breq	.+20     	; 0x5c40 <prvProcessExpiredTimer+0x5c>
        {
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
    5c2c:	89 81       	ldd	r24, Y+1	; 0x01
    5c2e:	9a 81       	ldd	r25, Y+2	; 0x02
    5c30:	2b 81       	ldd	r18, Y+3	; 0x03
    5c32:	3c 81       	ldd	r19, Y+4	; 0x04
    5c34:	4d 81       	ldd	r20, Y+5	; 0x05
    5c36:	5e 81       	ldd	r21, Y+6	; 0x06
    5c38:	b9 01       	movw	r22, r18
    5c3a:	0e 94 b3 2d 	call	0x5b66	; 0x5b66 <prvReloadTimer>
    5c3e:	07 c0       	rjmp	.+14     	; 0x5c4e <prvProcessExpiredTimer+0x6a>
        }
        else
        {
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    5c40:	e9 81       	ldd	r30, Y+1	; 0x01
    5c42:	fa 81       	ldd	r31, Y+2	; 0x02
    5c44:	82 89       	ldd	r24, Z+18	; 0x12
    5c46:	8e 7f       	andi	r24, 0xFE	; 254
    5c48:	e9 81       	ldd	r30, Y+1	; 0x01
    5c4a:	fa 81       	ldd	r31, Y+2	; 0x02
    5c4c:	82 8b       	std	Z+18, r24	; 0x12
        }

        /* Call the timer callback. */
        traceTIMER_EXPIRED( pxTimer );
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    5c4e:	e9 81       	ldd	r30, Y+1	; 0x01
    5c50:	fa 81       	ldd	r31, Y+2	; 0x02
    5c52:	00 88       	ldd	r0, Z+16	; 0x10
    5c54:	f1 89       	ldd	r31, Z+17	; 0x11
    5c56:	e0 2d       	mov	r30, r0
    5c58:	89 81       	ldd	r24, Y+1	; 0x01
    5c5a:	9a 81       	ldd	r25, Y+2	; 0x02
    5c5c:	09 95       	icall
    }
    5c5e:	26 96       	adiw	r28, 0x06	; 6
    5c60:	0f b6       	in	r0, 0x3f	; 63
    5c62:	f8 94       	cli
    5c64:	de bf       	out	0x3e, r29	; 62
    5c66:	0f be       	out	0x3f, r0	; 63
    5c68:	cd bf       	out	0x3d, r28	; 61
    5c6a:	cf 91       	pop	r28
    5c6c:	df 91       	pop	r29
    5c6e:	08 95       	ret

00005c70 <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
    5c70:	df 93       	push	r29
    5c72:	cf 93       	push	r28
    5c74:	00 d0       	rcall	.+0      	; 0x5c76 <prvTimerTask+0x6>
    5c76:	00 d0       	rcall	.+0      	; 0x5c78 <prvTimerTask+0x8>
    5c78:	0f 92       	push	r0
    5c7a:	cd b7       	in	r28, 0x3d	; 61
    5c7c:	de b7       	in	r29, 0x3e	; 62
    5c7e:	9d 83       	std	Y+5, r25	; 0x05
    5c80:	8c 83       	std	Y+4, r24	; 0x04

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    5c82:	ce 01       	movw	r24, r28
    5c84:	03 96       	adiw	r24, 0x03	; 3
    5c86:	0e 94 a7 2e 	call	0x5d4e	; 0x5d4e <prvGetNextExpireTime>
    5c8a:	9a 83       	std	Y+2, r25	; 0x02
    5c8c:	89 83       	std	Y+1, r24	; 0x01

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    5c8e:	2b 81       	ldd	r18, Y+3	; 0x03
    5c90:	89 81       	ldd	r24, Y+1	; 0x01
    5c92:	9a 81       	ldd	r25, Y+2	; 0x02
    5c94:	62 2f       	mov	r22, r18
    5c96:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
    5c9a:	0e 94 71 2f 	call	0x5ee2	; 0x5ee2 <prvProcessReceivedCommands>
    5c9e:	f1 cf       	rjmp	.-30     	; 0x5c82 <prvTimerTask+0x12>

00005ca0 <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
    5ca0:	df 93       	push	r29
    5ca2:	cf 93       	push	r28
    5ca4:	00 d0       	rcall	.+0      	; 0x5ca6 <prvProcessTimerOrBlockTask+0x6>
    5ca6:	00 d0       	rcall	.+0      	; 0x5ca8 <prvProcessTimerOrBlockTask+0x8>
    5ca8:	00 d0       	rcall	.+0      	; 0x5caa <prvProcessTimerOrBlockTask+0xa>
    5caa:	cd b7       	in	r28, 0x3d	; 61
    5cac:	de b7       	in	r29, 0x3e	; 62
    5cae:	9d 83       	std	Y+5, r25	; 0x05
    5cb0:	8c 83       	std	Y+4, r24	; 0x04
    5cb2:	6e 83       	std	Y+6, r22	; 0x06
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
    5cb4:	0e 94 21 1b 	call	0x3642	; 0x3642 <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    5cb8:	ce 01       	movw	r24, r28
    5cba:	03 96       	adiw	r24, 0x03	; 3
    5cbc:	0e 94 db 2e 	call	0x5db6	; 0x5db6 <prvSampleTimeNow>
    5cc0:	9a 83       	std	Y+2, r25	; 0x02
    5cc2:	89 83       	std	Y+1, r24	; 0x01

            if( xTimerListsWereSwitched == pdFALSE )
    5cc4:	8b 81       	ldd	r24, Y+3	; 0x03
    5cc6:	88 23       	and	r24, r24
    5cc8:	b9 f5       	brne	.+110    	; 0x5d38 <prvProcessTimerOrBlockTask+0x98>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    5cca:	8e 81       	ldd	r24, Y+6	; 0x06
    5ccc:	88 23       	and	r24, r24
    5cce:	89 f4       	brne	.+34     	; 0x5cf2 <prvProcessTimerOrBlockTask+0x52>
    5cd0:	2c 81       	ldd	r18, Y+4	; 0x04
    5cd2:	3d 81       	ldd	r19, Y+5	; 0x05
    5cd4:	89 81       	ldd	r24, Y+1	; 0x01
    5cd6:	9a 81       	ldd	r25, Y+2	; 0x02
    5cd8:	82 17       	cp	r24, r18
    5cda:	93 07       	cpc	r25, r19
    5cdc:	50 f0       	brcs	.+20     	; 0x5cf2 <prvProcessTimerOrBlockTask+0x52>
                {
                    ( void ) xTaskResumeAll();
    5cde:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    5ce2:	8c 81       	ldd	r24, Y+4	; 0x04
    5ce4:	9d 81       	ldd	r25, Y+5	; 0x05
    5ce6:	29 81       	ldd	r18, Y+1	; 0x01
    5ce8:	3a 81       	ldd	r19, Y+2	; 0x02
    5cea:	b9 01       	movw	r22, r18
    5cec:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <prvProcessExpiredTimer>
    5cf0:	25 c0       	rjmp	.+74     	; 0x5d3c <prvProcessTimerOrBlockTask+0x9c>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
    5cf2:	8e 81       	ldd	r24, Y+6	; 0x06
    5cf4:	88 23       	and	r24, r24
    5cf6:	51 f0       	breq	.+20     	; 0x5d0c <prvProcessTimerOrBlockTask+0x6c>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    5cf8:	e0 91 dc 06 	lds	r30, 0x06DC
    5cfc:	f0 91 dd 06 	lds	r31, 0x06DD
    5d00:	80 81       	ld	r24, Z
    5d02:	1e 82       	std	Y+6, r1	; 0x06
    5d04:	88 23       	and	r24, r24
    5d06:	11 f4       	brne	.+4      	; 0x5d0c <prvProcessTimerOrBlockTask+0x6c>
    5d08:	81 e0       	ldi	r24, 0x01	; 1
    5d0a:	8e 83       	std	Y+6, r24	; 0x06
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    5d0c:	40 91 c2 06 	lds	r20, 0x06C2
    5d10:	50 91 c3 06 	lds	r21, 0x06C3
    5d14:	2c 81       	ldd	r18, Y+4	; 0x04
    5d16:	3d 81       	ldd	r19, Y+5	; 0x05
    5d18:	89 81       	ldd	r24, Y+1	; 0x01
    5d1a:	9a 81       	ldd	r25, Y+2	; 0x02
    5d1c:	28 1b       	sub	r18, r24
    5d1e:	39 0b       	sbc	r19, r25
    5d20:	ca 01       	movw	r24, r20
    5d22:	b9 01       	movw	r22, r18
    5d24:	4e 81       	ldd	r20, Y+6	; 0x06
    5d26:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
    5d2a:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
    5d2e:	88 23       	and	r24, r24
    5d30:	29 f4       	brne	.+10     	; 0x5d3c <prvProcessTimerOrBlockTask+0x9c>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
    5d32:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    5d36:	02 c0       	rjmp	.+4      	; 0x5d3c <prvProcessTimerOrBlockTask+0x9c>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
    5d38:	0e 94 2d 1b 	call	0x365a	; 0x365a <xTaskResumeAll>
            }
        }
    }
    5d3c:	26 96       	adiw	r28, 0x06	; 6
    5d3e:	0f b6       	in	r0, 0x3f	; 63
    5d40:	f8 94       	cli
    5d42:	de bf       	out	0x3e, r29	; 62
    5d44:	0f be       	out	0x3f, r0	; 63
    5d46:	cd bf       	out	0x3d, r28	; 61
    5d48:	cf 91       	pop	r28
    5d4a:	df 91       	pop	r29
    5d4c:	08 95       	ret

00005d4e <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
    5d4e:	df 93       	push	r29
    5d50:	cf 93       	push	r28
    5d52:	00 d0       	rcall	.+0      	; 0x5d54 <prvGetNextExpireTime+0x6>
    5d54:	00 d0       	rcall	.+0      	; 0x5d56 <prvGetNextExpireTime+0x8>
    5d56:	0f 92       	push	r0
    5d58:	cd b7       	in	r28, 0x3d	; 61
    5d5a:	de b7       	in	r29, 0x3e	; 62
    5d5c:	9c 83       	std	Y+4, r25	; 0x04
    5d5e:	8b 83       	std	Y+3, r24	; 0x03
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    5d60:	e0 91 da 06 	lds	r30, 0x06DA
    5d64:	f0 91 db 06 	lds	r31, 0x06DB
    5d68:	80 81       	ld	r24, Z
    5d6a:	1d 82       	std	Y+5, r1	; 0x05
    5d6c:	88 23       	and	r24, r24
    5d6e:	11 f4       	brne	.+4      	; 0x5d74 <prvGetNextExpireTime+0x26>
    5d70:	81 e0       	ldi	r24, 0x01	; 1
    5d72:	8d 83       	std	Y+5, r24	; 0x05
    5d74:	eb 81       	ldd	r30, Y+3	; 0x03
    5d76:	fc 81       	ldd	r31, Y+4	; 0x04
    5d78:	8d 81       	ldd	r24, Y+5	; 0x05
    5d7a:	80 83       	st	Z, r24

        if( *pxListWasEmpty == pdFALSE )
    5d7c:	eb 81       	ldd	r30, Y+3	; 0x03
    5d7e:	fc 81       	ldd	r31, Y+4	; 0x04
    5d80:	80 81       	ld	r24, Z
    5d82:	88 23       	and	r24, r24
    5d84:	61 f4       	brne	.+24     	; 0x5d9e <prvGetNextExpireTime+0x50>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    5d86:	e0 91 da 06 	lds	r30, 0x06DA
    5d8a:	f0 91 db 06 	lds	r31, 0x06DB
    5d8e:	05 80       	ldd	r0, Z+5	; 0x05
    5d90:	f6 81       	ldd	r31, Z+6	; 0x06
    5d92:	e0 2d       	mov	r30, r0
    5d94:	80 81       	ld	r24, Z
    5d96:	91 81       	ldd	r25, Z+1	; 0x01
    5d98:	9a 83       	std	Y+2, r25	; 0x02
    5d9a:	89 83       	std	Y+1, r24	; 0x01
    5d9c:	02 c0       	rjmp	.+4      	; 0x5da2 <prvGetNextExpireTime+0x54>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
    5d9e:	1a 82       	std	Y+2, r1	; 0x02
    5da0:	19 82       	std	Y+1, r1	; 0x01
        }

        return xNextExpireTime;
    5da2:	89 81       	ldd	r24, Y+1	; 0x01
    5da4:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5da6:	0f 90       	pop	r0
    5da8:	0f 90       	pop	r0
    5daa:	0f 90       	pop	r0
    5dac:	0f 90       	pop	r0
    5dae:	0f 90       	pop	r0
    5db0:	cf 91       	pop	r28
    5db2:	df 91       	pop	r29
    5db4:	08 95       	ret

00005db6 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
    5db6:	df 93       	push	r29
    5db8:	cf 93       	push	r28
    5dba:	00 d0       	rcall	.+0      	; 0x5dbc <prvSampleTimeNow+0x6>
    5dbc:	00 d0       	rcall	.+0      	; 0x5dbe <prvSampleTimeNow+0x8>
    5dbe:	cd b7       	in	r28, 0x3d	; 61
    5dc0:	de b7       	in	r29, 0x3e	; 62
    5dc2:	9c 83       	std	Y+4, r25	; 0x04
    5dc4:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
    5dc6:	0e 94 7d 1c 	call	0x38fa	; 0x38fa <xTaskGetTickCount>
    5dca:	9a 83       	std	Y+2, r25	; 0x02
    5dcc:	89 83       	std	Y+1, r24	; 0x01

        if( xTimeNow < xLastTime )
    5dce:	20 91 c6 06 	lds	r18, 0x06C6
    5dd2:	30 91 c7 06 	lds	r19, 0x06C7
    5dd6:	89 81       	ldd	r24, Y+1	; 0x01
    5dd8:	9a 81       	ldd	r25, Y+2	; 0x02
    5dda:	82 17       	cp	r24, r18
    5ddc:	93 07       	cpc	r25, r19
    5dde:	38 f4       	brcc	.+14     	; 0x5dee <prvSampleTimeNow+0x38>
        {
            prvSwitchTimerLists();
    5de0:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
    5de4:	eb 81       	ldd	r30, Y+3	; 0x03
    5de6:	fc 81       	ldd	r31, Y+4	; 0x04
    5de8:	81 e0       	ldi	r24, 0x01	; 1
    5dea:	80 83       	st	Z, r24
    5dec:	03 c0       	rjmp	.+6      	; 0x5df4 <prvSampleTimeNow+0x3e>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
    5dee:	eb 81       	ldd	r30, Y+3	; 0x03
    5df0:	fc 81       	ldd	r31, Y+4	; 0x04
    5df2:	10 82       	st	Z, r1
        }

        xLastTime = xTimeNow;
    5df4:	89 81       	ldd	r24, Y+1	; 0x01
    5df6:	9a 81       	ldd	r25, Y+2	; 0x02
    5df8:	90 93 c7 06 	sts	0x06C7, r25
    5dfc:	80 93 c6 06 	sts	0x06C6, r24

        return xTimeNow;
    5e00:	89 81       	ldd	r24, Y+1	; 0x01
    5e02:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5e04:	0f 90       	pop	r0
    5e06:	0f 90       	pop	r0
    5e08:	0f 90       	pop	r0
    5e0a:	0f 90       	pop	r0
    5e0c:	cf 91       	pop	r28
    5e0e:	df 91       	pop	r29
    5e10:	08 95       	ret

00005e12 <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
    5e12:	df 93       	push	r29
    5e14:	cf 93       	push	r28
    5e16:	cd b7       	in	r28, 0x3d	; 61
    5e18:	de b7       	in	r29, 0x3e	; 62
    5e1a:	29 97       	sbiw	r28, 0x09	; 9
    5e1c:	0f b6       	in	r0, 0x3f	; 63
    5e1e:	f8 94       	cli
    5e20:	de bf       	out	0x3e, r29	; 62
    5e22:	0f be       	out	0x3f, r0	; 63
    5e24:	cd bf       	out	0x3d, r28	; 61
    5e26:	9b 83       	std	Y+3, r25	; 0x03
    5e28:	8a 83       	std	Y+2, r24	; 0x02
    5e2a:	7d 83       	std	Y+5, r23	; 0x05
    5e2c:	6c 83       	std	Y+4, r22	; 0x04
    5e2e:	5f 83       	std	Y+7, r21	; 0x07
    5e30:	4e 83       	std	Y+6, r20	; 0x06
    5e32:	39 87       	std	Y+9, r19	; 0x09
    5e34:	28 87       	std	Y+8, r18	; 0x08
        BaseType_t xProcessTimerNow = pdFALSE;
    5e36:	19 82       	std	Y+1, r1	; 0x01

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    5e38:	ea 81       	ldd	r30, Y+2	; 0x02
    5e3a:	fb 81       	ldd	r31, Y+3	; 0x03
    5e3c:	8c 81       	ldd	r24, Y+4	; 0x04
    5e3e:	9d 81       	ldd	r25, Y+5	; 0x05
    5e40:	93 83       	std	Z+3, r25	; 0x03
    5e42:	82 83       	std	Z+2, r24	; 0x02
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    5e44:	ea 81       	ldd	r30, Y+2	; 0x02
    5e46:	fb 81       	ldd	r31, Y+3	; 0x03
    5e48:	8a 81       	ldd	r24, Y+2	; 0x02
    5e4a:	9b 81       	ldd	r25, Y+3	; 0x03
    5e4c:	91 87       	std	Z+9, r25	; 0x09
    5e4e:	80 87       	std	Z+8, r24	; 0x08

        if( xNextExpiryTime <= xTimeNow )
    5e50:	2c 81       	ldd	r18, Y+4	; 0x04
    5e52:	3d 81       	ldd	r19, Y+5	; 0x05
    5e54:	8e 81       	ldd	r24, Y+6	; 0x06
    5e56:	9f 81       	ldd	r25, Y+7	; 0x07
    5e58:	82 17       	cp	r24, r18
    5e5a:	93 07       	cpc	r25, r19
    5e5c:	e0 f0       	brcs	.+56     	; 0x5e96 <prvInsertTimerInActiveList+0x84>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5e5e:	2e 81       	ldd	r18, Y+6	; 0x06
    5e60:	3f 81       	ldd	r19, Y+7	; 0x07
    5e62:	88 85       	ldd	r24, Y+8	; 0x08
    5e64:	99 85       	ldd	r25, Y+9	; 0x09
    5e66:	28 1b       	sub	r18, r24
    5e68:	39 0b       	sbc	r19, r25
    5e6a:	ea 81       	ldd	r30, Y+2	; 0x02
    5e6c:	fb 81       	ldd	r31, Y+3	; 0x03
    5e6e:	84 85       	ldd	r24, Z+12	; 0x0c
    5e70:	95 85       	ldd	r25, Z+13	; 0x0d
    5e72:	28 17       	cp	r18, r24
    5e74:	39 07       	cpc	r19, r25
    5e76:	18 f0       	brcs	.+6      	; 0x5e7e <prvInsertTimerInActiveList+0x6c>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
    5e78:	81 e0       	ldi	r24, 0x01	; 1
    5e7a:	89 83       	std	Y+1, r24	; 0x01
    5e7c:	28 c0       	rjmp	.+80     	; 0x5ece <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    5e7e:	80 91 dc 06 	lds	r24, 0x06DC
    5e82:	90 91 dd 06 	lds	r25, 0x06DD
    5e86:	2a 81       	ldd	r18, Y+2	; 0x02
    5e88:	3b 81       	ldd	r19, Y+3	; 0x03
    5e8a:	2e 5f       	subi	r18, 0xFE	; 254
    5e8c:	3f 4f       	sbci	r19, 0xFF	; 255
    5e8e:	b9 01       	movw	r22, r18
    5e90:	0e 94 60 07 	call	0xec0	; 0xec0 <vListInsert>
    5e94:	1c c0       	rjmp	.+56     	; 0x5ece <prvInsertTimerInActiveList+0xbc>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    5e96:	2e 81       	ldd	r18, Y+6	; 0x06
    5e98:	3f 81       	ldd	r19, Y+7	; 0x07
    5e9a:	88 85       	ldd	r24, Y+8	; 0x08
    5e9c:	99 85       	ldd	r25, Y+9	; 0x09
    5e9e:	28 17       	cp	r18, r24
    5ea0:	39 07       	cpc	r19, r25
    5ea2:	50 f4       	brcc	.+20     	; 0x5eb8 <prvInsertTimerInActiveList+0xa6>
    5ea4:	2c 81       	ldd	r18, Y+4	; 0x04
    5ea6:	3d 81       	ldd	r19, Y+5	; 0x05
    5ea8:	88 85       	ldd	r24, Y+8	; 0x08
    5eaa:	99 85       	ldd	r25, Y+9	; 0x09
    5eac:	28 17       	cp	r18, r24
    5eae:	39 07       	cpc	r19, r25
    5eb0:	18 f0       	brcs	.+6      	; 0x5eb8 <prvInsertTimerInActiveList+0xa6>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
    5eb2:	81 e0       	ldi	r24, 0x01	; 1
    5eb4:	89 83       	std	Y+1, r24	; 0x01
    5eb6:	0b c0       	rjmp	.+22     	; 0x5ece <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    5eb8:	80 91 da 06 	lds	r24, 0x06DA
    5ebc:	90 91 db 06 	lds	r25, 0x06DB
    5ec0:	2a 81       	ldd	r18, Y+2	; 0x02
    5ec2:	3b 81       	ldd	r19, Y+3	; 0x03
    5ec4:	2e 5f       	subi	r18, 0xFE	; 254
    5ec6:	3f 4f       	sbci	r19, 0xFF	; 255
    5ec8:	b9 01       	movw	r22, r18
    5eca:	0e 94 60 07 	call	0xec0	; 0xec0 <vListInsert>
            }
        }

        return xProcessTimerNow;
    5ece:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5ed0:	29 96       	adiw	r28, 0x09	; 9
    5ed2:	0f b6       	in	r0, 0x3f	; 63
    5ed4:	f8 94       	cli
    5ed6:	de bf       	out	0x3e, r29	; 62
    5ed8:	0f be       	out	0x3f, r0	; 63
    5eda:	cd bf       	out	0x3d, r28	; 61
    5edc:	cf 91       	pop	r28
    5ede:	df 91       	pop	r29
    5ee0:	08 95       	ret

00005ee2 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
    5ee2:	df 93       	push	r29
    5ee4:	cf 93       	push	r28
    5ee6:	cd b7       	in	r28, 0x3d	; 61
    5ee8:	de b7       	in	r29, 0x3e	; 62
    5eea:	2c 97       	sbiw	r28, 0x0c	; 12
    5eec:	0f b6       	in	r0, 0x3f	; 63
    5eee:	f8 94       	cli
    5ef0:	de bf       	out	0x3e, r29	; 62
    5ef2:	0f be       	out	0x3f, r0	; 63
    5ef4:	cd bf       	out	0x3d, r28	; 61
    5ef6:	d8 c0       	rjmp	.+432    	; 0x60a8 <prvProcessReceivedCommands+0x1c6>
            }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    5ef8:	8d 81       	ldd	r24, Y+5	; 0x05
    5efa:	88 23       	and	r24, r24
    5efc:	0c f4       	brge	.+2      	; 0x5f00 <prvProcessReceivedCommands+0x1e>
    5efe:	d4 c0       	rjmp	.+424    	; 0x60a8 <prvProcessReceivedCommands+0x1c6>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
    5f00:	88 85       	ldd	r24, Y+8	; 0x08
    5f02:	99 85       	ldd	r25, Y+9	; 0x09
    5f04:	9c 83       	std	Y+4, r25	; 0x04
    5f06:	8b 83       	std	Y+3, r24	; 0x03

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    5f08:	eb 81       	ldd	r30, Y+3	; 0x03
    5f0a:	fc 81       	ldd	r31, Y+4	; 0x04
    5f0c:	82 85       	ldd	r24, Z+10	; 0x0a
    5f0e:	93 85       	ldd	r25, Z+11	; 0x0b
    5f10:	00 97       	sbiw	r24, 0x00	; 0
    5f12:	29 f0       	breq	.+10     	; 0x5f1e <prvProcessReceivedCommands+0x3c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    5f14:	8b 81       	ldd	r24, Y+3	; 0x03
    5f16:	9c 81       	ldd	r25, Y+4	; 0x04
    5f18:	02 96       	adiw	r24, 0x02	; 2
    5f1a:	0e 94 cc 07 	call	0xf98	; 0xf98 <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    5f1e:	ce 01       	movw	r24, r28
    5f20:	0a 96       	adiw	r24, 0x0a	; 10
    5f22:	0e 94 db 2e 	call	0x5db6	; 0x5db6 <prvSampleTimeNow>
    5f26:	9a 83       	std	Y+2, r25	; 0x02
    5f28:	89 83       	std	Y+1, r24	; 0x01

                switch( xMessage.xMessageID )
    5f2a:	8d 81       	ldd	r24, Y+5	; 0x05
    5f2c:	28 2f       	mov	r18, r24
    5f2e:	33 27       	eor	r19, r19
    5f30:	27 fd       	sbrc	r18, 7
    5f32:	30 95       	com	r19
    5f34:	3c 87       	std	Y+12, r19	; 0x0c
    5f36:	2b 87       	std	Y+11, r18	; 0x0b
    5f38:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f3a:	9c 85       	ldd	r25, Y+12	; 0x0c
    5f3c:	85 30       	cpi	r24, 0x05	; 5
    5f3e:	91 05       	cpc	r25, r1
    5f40:	09 f4       	brne	.+2      	; 0x5f44 <prvProcessReceivedCommands+0x62>
    5f42:	9d c0       	rjmp	.+314    	; 0x607e <prvProcessReceivedCommands+0x19c>
    5f44:	2b 85       	ldd	r18, Y+11	; 0x0b
    5f46:	3c 85       	ldd	r19, Y+12	; 0x0c
    5f48:	26 30       	cpi	r18, 0x06	; 6
    5f4a:	31 05       	cpc	r19, r1
    5f4c:	9c f4       	brge	.+38     	; 0x5f74 <prvProcessReceivedCommands+0x92>
    5f4e:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f50:	9c 85       	ldd	r25, Y+12	; 0x0c
    5f52:	83 30       	cpi	r24, 0x03	; 3
    5f54:	91 05       	cpc	r25, r1
    5f56:	09 f4       	brne	.+2      	; 0x5f5a <prvProcessReceivedCommands+0x78>
    5f58:	68 c0       	rjmp	.+208    	; 0x602a <prvProcessReceivedCommands+0x148>
    5f5a:	2b 85       	ldd	r18, Y+11	; 0x0b
    5f5c:	3c 85       	ldd	r19, Y+12	; 0x0c
    5f5e:	24 30       	cpi	r18, 0x04	; 4
    5f60:	31 05       	cpc	r19, r1
    5f62:	0c f0       	brlt	.+2      	; 0x5f66 <prvProcessReceivedCommands+0x84>
    5f64:	6a c0       	rjmp	.+212    	; 0x603a <prvProcessReceivedCommands+0x158>
    5f66:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f68:	9c 85       	ldd	r25, Y+12	; 0x0c
    5f6a:	81 30       	cpi	r24, 0x01	; 1
    5f6c:	91 05       	cpc	r25, r1
    5f6e:	0c f4       	brge	.+2      	; 0x5f72 <prvProcessReceivedCommands+0x90>
    5f70:	9b c0       	rjmp	.+310    	; 0x60a8 <prvProcessReceivedCommands+0x1c6>
    5f72:	12 c0       	rjmp	.+36     	; 0x5f98 <prvProcessReceivedCommands+0xb6>
    5f74:	2b 85       	ldd	r18, Y+11	; 0x0b
    5f76:	3c 85       	ldd	r19, Y+12	; 0x0c
    5f78:	28 30       	cpi	r18, 0x08	; 8
    5f7a:	31 05       	cpc	r19, r1
    5f7c:	09 f4       	brne	.+2      	; 0x5f80 <prvProcessReceivedCommands+0x9e>
    5f7e:	55 c0       	rjmp	.+170    	; 0x602a <prvProcessReceivedCommands+0x148>
    5f80:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f82:	9c 85       	ldd	r25, Y+12	; 0x0c
    5f84:	88 30       	cpi	r24, 0x08	; 8
    5f86:	91 05       	cpc	r25, r1
    5f88:	3c f0       	brlt	.+14     	; 0x5f98 <prvProcessReceivedCommands+0xb6>
    5f8a:	2b 85       	ldd	r18, Y+11	; 0x0b
    5f8c:	3c 85       	ldd	r19, Y+12	; 0x0c
    5f8e:	29 30       	cpi	r18, 0x09	; 9
    5f90:	31 05       	cpc	r19, r1
    5f92:	09 f4       	brne	.+2      	; 0x5f96 <prvProcessReceivedCommands+0xb4>
    5f94:	52 c0       	rjmp	.+164    	; 0x603a <prvProcessReceivedCommands+0x158>
    5f96:	88 c0       	rjmp	.+272    	; 0x60a8 <prvProcessReceivedCommands+0x1c6>
                    case tmrCOMMAND_START:
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    5f98:	eb 81       	ldd	r30, Y+3	; 0x03
    5f9a:	fc 81       	ldd	r31, Y+4	; 0x04
    5f9c:	82 89       	ldd	r24, Z+18	; 0x12
    5f9e:	81 60       	ori	r24, 0x01	; 1
    5fa0:	eb 81       	ldd	r30, Y+3	; 0x03
    5fa2:	fc 81       	ldd	r31, Y+4	; 0x04
    5fa4:	82 8b       	std	Z+18, r24	; 0x12

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    5fa6:	2e 81       	ldd	r18, Y+6	; 0x06
    5fa8:	3f 81       	ldd	r19, Y+7	; 0x07
    5faa:	eb 81       	ldd	r30, Y+3	; 0x03
    5fac:	fc 81       	ldd	r31, Y+4	; 0x04
    5fae:	84 85       	ldd	r24, Z+12	; 0x0c
    5fb0:	95 85       	ldd	r25, Z+13	; 0x0d
    5fb2:	a9 01       	movw	r20, r18
    5fb4:	48 0f       	add	r20, r24
    5fb6:	59 1f       	adc	r21, r25
    5fb8:	ee 81       	ldd	r30, Y+6	; 0x06
    5fba:	ff 81       	ldd	r31, Y+7	; 0x07
    5fbc:	8b 81       	ldd	r24, Y+3	; 0x03
    5fbe:	9c 81       	ldd	r25, Y+4	; 0x04
    5fc0:	29 81       	ldd	r18, Y+1	; 0x01
    5fc2:	3a 81       	ldd	r19, Y+2	; 0x02
    5fc4:	ba 01       	movw	r22, r20
    5fc6:	a9 01       	movw	r20, r18
    5fc8:	9f 01       	movw	r18, r30
    5fca:	0e 94 09 2f 	call	0x5e12	; 0x5e12 <prvInsertTimerInActiveList>
    5fce:	88 23       	and	r24, r24
    5fd0:	09 f4       	brne	.+2      	; 0x5fd4 <prvProcessReceivedCommands+0xf2>
    5fd2:	6a c0       	rjmp	.+212    	; 0x60a8 <prvProcessReceivedCommands+0x1c6>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    5fd4:	eb 81       	ldd	r30, Y+3	; 0x03
    5fd6:	fc 81       	ldd	r31, Y+4	; 0x04
    5fd8:	82 89       	ldd	r24, Z+18	; 0x12
    5fda:	88 2f       	mov	r24, r24
    5fdc:	90 e0       	ldi	r25, 0x00	; 0
    5fde:	84 70       	andi	r24, 0x04	; 4
    5fe0:	90 70       	andi	r25, 0x00	; 0
    5fe2:	00 97       	sbiw	r24, 0x00	; 0
    5fe4:	91 f0       	breq	.+36     	; 0x600a <prvProcessReceivedCommands+0x128>
                            {
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
    5fe6:	2e 81       	ldd	r18, Y+6	; 0x06
    5fe8:	3f 81       	ldd	r19, Y+7	; 0x07
    5fea:	eb 81       	ldd	r30, Y+3	; 0x03
    5fec:	fc 81       	ldd	r31, Y+4	; 0x04
    5fee:	84 85       	ldd	r24, Z+12	; 0x0c
    5ff0:	95 85       	ldd	r25, Z+13	; 0x0d
    5ff2:	a9 01       	movw	r20, r18
    5ff4:	48 0f       	add	r20, r24
    5ff6:	59 1f       	adc	r21, r25
    5ff8:	8b 81       	ldd	r24, Y+3	; 0x03
    5ffa:	9c 81       	ldd	r25, Y+4	; 0x04
    5ffc:	29 81       	ldd	r18, Y+1	; 0x01
    5ffe:	3a 81       	ldd	r19, Y+2	; 0x02
    6000:	ba 01       	movw	r22, r20
    6002:	a9 01       	movw	r20, r18
    6004:	0e 94 b3 2d 	call	0x5b66	; 0x5b66 <prvReloadTimer>
    6008:	07 c0       	rjmp	.+14     	; 0x6018 <prvProcessReceivedCommands+0x136>
                            }
                            else
                            {
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    600a:	eb 81       	ldd	r30, Y+3	; 0x03
    600c:	fc 81       	ldd	r31, Y+4	; 0x04
    600e:	82 89       	ldd	r24, Z+18	; 0x12
    6010:	8e 7f       	andi	r24, 0xFE	; 254
    6012:	eb 81       	ldd	r30, Y+3	; 0x03
    6014:	fc 81       	ldd	r31, Y+4	; 0x04
    6016:	82 8b       	std	Z+18, r24	; 0x12
                            }

                            /* Call the timer callback. */
                            traceTIMER_EXPIRED( pxTimer );
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    6018:	eb 81       	ldd	r30, Y+3	; 0x03
    601a:	fc 81       	ldd	r31, Y+4	; 0x04
    601c:	00 88       	ldd	r0, Z+16	; 0x10
    601e:	f1 89       	ldd	r31, Z+17	; 0x11
    6020:	e0 2d       	mov	r30, r0
    6022:	8b 81       	ldd	r24, Y+3	; 0x03
    6024:	9c 81       	ldd	r25, Y+4	; 0x04
    6026:	09 95       	icall
    6028:	3f c0       	rjmp	.+126    	; 0x60a8 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    602a:	eb 81       	ldd	r30, Y+3	; 0x03
    602c:	fc 81       	ldd	r31, Y+4	; 0x04
    602e:	82 89       	ldd	r24, Z+18	; 0x12
    6030:	8e 7f       	andi	r24, 0xFE	; 254
    6032:	eb 81       	ldd	r30, Y+3	; 0x03
    6034:	fc 81       	ldd	r31, Y+4	; 0x04
    6036:	82 8b       	std	Z+18, r24	; 0x12
    6038:	37 c0       	rjmp	.+110    	; 0x60a8 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    603a:	eb 81       	ldd	r30, Y+3	; 0x03
    603c:	fc 81       	ldd	r31, Y+4	; 0x04
    603e:	82 89       	ldd	r24, Z+18	; 0x12
    6040:	81 60       	ori	r24, 0x01	; 1
    6042:	eb 81       	ldd	r30, Y+3	; 0x03
    6044:	fc 81       	ldd	r31, Y+4	; 0x04
    6046:	82 8b       	std	Z+18, r24	; 0x12
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    6048:	8e 81       	ldd	r24, Y+6	; 0x06
    604a:	9f 81       	ldd	r25, Y+7	; 0x07
    604c:	eb 81       	ldd	r30, Y+3	; 0x03
    604e:	fc 81       	ldd	r31, Y+4	; 0x04
    6050:	95 87       	std	Z+13, r25	; 0x0d
    6052:	84 87       	std	Z+12, r24	; 0x0c
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    6054:	eb 81       	ldd	r30, Y+3	; 0x03
    6056:	fc 81       	ldd	r31, Y+4	; 0x04
    6058:	24 85       	ldd	r18, Z+12	; 0x0c
    605a:	35 85       	ldd	r19, Z+13	; 0x0d
    605c:	89 81       	ldd	r24, Y+1	; 0x01
    605e:	9a 81       	ldd	r25, Y+2	; 0x02
    6060:	a9 01       	movw	r20, r18
    6062:	48 0f       	add	r20, r24
    6064:	59 1f       	adc	r21, r25
    6066:	8b 81       	ldd	r24, Y+3	; 0x03
    6068:	9c 81       	ldd	r25, Y+4	; 0x04
    606a:	29 81       	ldd	r18, Y+1	; 0x01
    606c:	3a 81       	ldd	r19, Y+2	; 0x02
    606e:	e9 81       	ldd	r30, Y+1	; 0x01
    6070:	fa 81       	ldd	r31, Y+2	; 0x02
    6072:	ba 01       	movw	r22, r20
    6074:	a9 01       	movw	r20, r18
    6076:	9f 01       	movw	r18, r30
    6078:	0e 94 09 2f 	call	0x5e12	; 0x5e12 <prvInsertTimerInActiveList>
    607c:	15 c0       	rjmp	.+42     	; 0x60a8 <prvProcessReceivedCommands+0x1c6>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                        {
                            /* The timer has already been removed from the active list,
                             * just free up the memory if the memory was dynamically
                             * allocated. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    607e:	eb 81       	ldd	r30, Y+3	; 0x03
    6080:	fc 81       	ldd	r31, Y+4	; 0x04
    6082:	82 89       	ldd	r24, Z+18	; 0x12
    6084:	88 2f       	mov	r24, r24
    6086:	90 e0       	ldi	r25, 0x00	; 0
    6088:	82 70       	andi	r24, 0x02	; 2
    608a:	90 70       	andi	r25, 0x00	; 0
    608c:	00 97       	sbiw	r24, 0x00	; 0
    608e:	29 f4       	brne	.+10     	; 0x609a <prvProcessReceivedCommands+0x1b8>
                            {
                                vPortFree( pxTimer );
    6090:	8b 81       	ldd	r24, Y+3	; 0x03
    6092:	9c 81       	ldd	r25, Y+4	; 0x04
    6094:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
    6098:	07 c0       	rjmp	.+14     	; 0x60a8 <prvProcessReceivedCommands+0x1c6>
                            }
                            else
                            {
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    609a:	eb 81       	ldd	r30, Y+3	; 0x03
    609c:	fc 81       	ldd	r31, Y+4	; 0x04
    609e:	82 89       	ldd	r24, Z+18	; 0x12
    60a0:	8e 7f       	andi	r24, 0xFE	; 254
    60a2:	eb 81       	ldd	r30, Y+3	; 0x03
    60a4:	fc 81       	ldd	r31, Y+4	; 0x04
    60a6:	82 8b       	std	Z+18, r24	; 0x12
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    60a8:	80 91 c2 06 	lds	r24, 0x06C2
    60ac:	90 91 c3 06 	lds	r25, 0x06C3
    60b0:	9e 01       	movw	r18, r28
    60b2:	2b 5f       	subi	r18, 0xFB	; 251
    60b4:	3f 4f       	sbci	r19, 0xFF	; 255
    60b6:	b9 01       	movw	r22, r18
    60b8:	40 e0       	ldi	r20, 0x00	; 0
    60ba:	50 e0       	ldi	r21, 0x00	; 0
    60bc:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <xQueueReceive>
    60c0:	88 23       	and	r24, r24
    60c2:	09 f0       	breq	.+2      	; 0x60c6 <prvProcessReceivedCommands+0x1e4>
    60c4:	19 cf       	rjmp	.-462    	; 0x5ef8 <prvProcessReceivedCommands+0x16>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
    60c6:	2c 96       	adiw	r28, 0x0c	; 12
    60c8:	0f b6       	in	r0, 0x3f	; 63
    60ca:	f8 94       	cli
    60cc:	de bf       	out	0x3e, r29	; 62
    60ce:	0f be       	out	0x3f, r0	; 63
    60d0:	cd bf       	out	0x3d, r28	; 61
    60d2:	cf 91       	pop	r28
    60d4:	df 91       	pop	r29
    60d6:	08 95       	ret

000060d8 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
    60d8:	df 93       	push	r29
    60da:	cf 93       	push	r28
    60dc:	00 d0       	rcall	.+0      	; 0x60de <prvSwitchTimerLists+0x6>
    60de:	00 d0       	rcall	.+0      	; 0x60e0 <prvSwitchTimerLists+0x8>
    60e0:	cd b7       	in	r28, 0x3d	; 61
    60e2:	de b7       	in	r29, 0x3e	; 62
    60e4:	11 c0       	rjmp	.+34     	; 0x6108 <prvSwitchTimerLists+0x30>
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    60e6:	e0 91 da 06 	lds	r30, 0x06DA
    60ea:	f0 91 db 06 	lds	r31, 0x06DB
    60ee:	05 80       	ldd	r0, Z+5	; 0x05
    60f0:	f6 81       	ldd	r31, Z+6	; 0x06
    60f2:	e0 2d       	mov	r30, r0
    60f4:	80 81       	ld	r24, Z
    60f6:	91 81       	ldd	r25, Z+1	; 0x01
    60f8:	9c 83       	std	Y+4, r25	; 0x04
    60fa:	8b 83       	std	Y+3, r24	; 0x03

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
    60fc:	8b 81       	ldd	r24, Y+3	; 0x03
    60fe:	9c 81       	ldd	r25, Y+4	; 0x04
    6100:	6f ef       	ldi	r22, 0xFF	; 255
    6102:	7f ef       	ldi	r23, 0xFF	; 255
    6104:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <prvProcessExpiredTimer>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    6108:	e0 91 da 06 	lds	r30, 0x06DA
    610c:	f0 91 db 06 	lds	r31, 0x06DB
    6110:	80 81       	ld	r24, Z
    6112:	88 23       	and	r24, r24
    6114:	41 f7       	brne	.-48     	; 0x60e6 <prvSwitchTimerLists+0xe>
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
        }

        pxTemp = pxCurrentTimerList;
    6116:	80 91 da 06 	lds	r24, 0x06DA
    611a:	90 91 db 06 	lds	r25, 0x06DB
    611e:	9a 83       	std	Y+2, r25	; 0x02
    6120:	89 83       	std	Y+1, r24	; 0x01
        pxCurrentTimerList = pxOverflowTimerList;
    6122:	80 91 dc 06 	lds	r24, 0x06DC
    6126:	90 91 dd 06 	lds	r25, 0x06DD
    612a:	90 93 db 06 	sts	0x06DB, r25
    612e:	80 93 da 06 	sts	0x06DA, r24
        pxOverflowTimerList = pxTemp;
    6132:	89 81       	ldd	r24, Y+1	; 0x01
    6134:	9a 81       	ldd	r25, Y+2	; 0x02
    6136:	90 93 dd 06 	sts	0x06DD, r25
    613a:	80 93 dc 06 	sts	0x06DC, r24
    }
    613e:	0f 90       	pop	r0
    6140:	0f 90       	pop	r0
    6142:	0f 90       	pop	r0
    6144:	0f 90       	pop	r0
    6146:	cf 91       	pop	r28
    6148:	df 91       	pop	r29
    614a:	08 95       	ret

0000614c <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
    614c:	df 93       	push	r29
    614e:	cf 93       	push	r28
    6150:	cd b7       	in	r28, 0x3d	; 61
    6152:	de b7       	in	r29, 0x3e	; 62
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
    6154:	0f b6       	in	r0, 0x3f	; 63
    6156:	f8 94       	cli
    6158:	0f 92       	push	r0
        {
            if( xTimerQueue == NULL )
    615a:	80 91 c2 06 	lds	r24, 0x06C2
    615e:	90 91 c3 06 	lds	r25, 0x06C3
    6162:	00 97       	sbiw	r24, 0x00	; 0
    6164:	e9 f4       	brne	.+58     	; 0x61a0 <prvCheckForValidListAndQueue+0x54>
            {
                vListInitialise( &xActiveTimerList1 );
    6166:	88 ec       	ldi	r24, 0xC8	; 200
    6168:	96 e0       	ldi	r25, 0x06	; 6
    616a:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
    616e:	81 ed       	ldi	r24, 0xD1	; 209
    6170:	96 e0       	ldi	r25, 0x06	; 6
    6172:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
    6176:	88 ec       	ldi	r24, 0xC8	; 200
    6178:	96 e0       	ldi	r25, 0x06	; 6
    617a:	90 93 db 06 	sts	0x06DB, r25
    617e:	80 93 da 06 	sts	0x06DA, r24
                pxOverflowTimerList = &xActiveTimerList2;
    6182:	81 ed       	ldi	r24, 0xD1	; 209
    6184:	96 e0       	ldi	r25, 0x06	; 6
    6186:	90 93 dd 06 	sts	0x06DD, r25
    618a:	80 93 dc 06 	sts	0x06DC, r24

                    xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                }
                #else
                {
                    xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    618e:	8a e0       	ldi	r24, 0x0A	; 10
    6190:	65 e0       	ldi	r22, 0x05	; 5
    6192:	40 e0       	ldi	r20, 0x00	; 0
    6194:	0e 94 c3 08 	call	0x1186	; 0x1186 <xQueueGenericCreate>
    6198:	90 93 c3 06 	sts	0x06C3, r25
    619c:	80 93 c2 06 	sts	0x06C2, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    61a0:	0f 90       	pop	r0
    61a2:	0f be       	out	0x3f, r0	; 63
    }
    61a4:	cf 91       	pop	r28
    61a6:	df 91       	pop	r29
    61a8:	08 95       	ret

000061aa <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    {
    61aa:	df 93       	push	r29
    61ac:	cf 93       	push	r28
    61ae:	00 d0       	rcall	.+0      	; 0x61b0 <xTimerIsTimerActive+0x6>
    61b0:	00 d0       	rcall	.+0      	; 0x61b2 <xTimerIsTimerActive+0x8>
    61b2:	0f 92       	push	r0
    61b4:	cd b7       	in	r28, 0x3d	; 61
    61b6:	de b7       	in	r29, 0x3e	; 62
    61b8:	9d 83       	std	Y+5, r25	; 0x05
    61ba:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;
        Timer_t * pxTimer = xTimer;
    61bc:	8c 81       	ldd	r24, Y+4	; 0x04
    61be:	9d 81       	ldd	r25, Y+5	; 0x05
    61c0:	9a 83       	std	Y+2, r25	; 0x02
    61c2:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        /* Is the timer in the list of active timers? */
        taskENTER_CRITICAL();
    61c4:	0f b6       	in	r0, 0x3f	; 63
    61c6:	f8 94       	cli
    61c8:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
    61ca:	e9 81       	ldd	r30, Y+1	; 0x01
    61cc:	fa 81       	ldd	r31, Y+2	; 0x02
    61ce:	82 89       	ldd	r24, Z+18	; 0x12
    61d0:	88 2f       	mov	r24, r24
    61d2:	90 e0       	ldi	r25, 0x00	; 0
    61d4:	81 70       	andi	r24, 0x01	; 1
    61d6:	90 70       	andi	r25, 0x00	; 0
    61d8:	00 97       	sbiw	r24, 0x00	; 0
    61da:	11 f4       	brne	.+4      	; 0x61e0 <xTimerIsTimerActive+0x36>
            {
                xReturn = pdFALSE;
    61dc:	1b 82       	std	Y+3, r1	; 0x03
    61de:	02 c0       	rjmp	.+4      	; 0x61e4 <xTimerIsTimerActive+0x3a>
            }
            else
            {
                xReturn = pdTRUE;
    61e0:	81 e0       	ldi	r24, 0x01	; 1
    61e2:	8b 83       	std	Y+3, r24	; 0x03
            }
        }
        taskEXIT_CRITICAL();
    61e4:	0f 90       	pop	r0
    61e6:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    61e8:	8b 81       	ldd	r24, Y+3	; 0x03
    } /*lint !e818 Can't be pointer to const due to the typedef. */
    61ea:	0f 90       	pop	r0
    61ec:	0f 90       	pop	r0
    61ee:	0f 90       	pop	r0
    61f0:	0f 90       	pop	r0
    61f2:	0f 90       	pop	r0
    61f4:	cf 91       	pop	r28
    61f6:	df 91       	pop	r29
    61f8:	08 95       	ret

000061fa <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

    void * pvTimerGetTimerID( const TimerHandle_t xTimer )
    {
    61fa:	df 93       	push	r29
    61fc:	cf 93       	push	r28
    61fe:	00 d0       	rcall	.+0      	; 0x6200 <pvTimerGetTimerID+0x6>
    6200:	00 d0       	rcall	.+0      	; 0x6202 <pvTimerGetTimerID+0x8>
    6202:	00 d0       	rcall	.+0      	; 0x6204 <pvTimerGetTimerID+0xa>
    6204:	cd b7       	in	r28, 0x3d	; 61
    6206:	de b7       	in	r29, 0x3e	; 62
    6208:	9e 83       	std	Y+6, r25	; 0x06
    620a:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * const pxTimer = xTimer;
    620c:	8d 81       	ldd	r24, Y+5	; 0x05
    620e:	9e 81       	ldd	r25, Y+6	; 0x06
    6210:	9c 83       	std	Y+4, r25	; 0x04
    6212:	8b 83       	std	Y+3, r24	; 0x03
        void * pvReturn;

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    6214:	0f b6       	in	r0, 0x3f	; 63
    6216:	f8 94       	cli
    6218:	0f 92       	push	r0
        {
            pvReturn = pxTimer->pvTimerID;
    621a:	eb 81       	ldd	r30, Y+3	; 0x03
    621c:	fc 81       	ldd	r31, Y+4	; 0x04
    621e:	86 85       	ldd	r24, Z+14	; 0x0e
    6220:	97 85       	ldd	r25, Z+15	; 0x0f
    6222:	9a 83       	std	Y+2, r25	; 0x02
    6224:	89 83       	std	Y+1, r24	; 0x01
        }
        taskEXIT_CRITICAL();
    6226:	0f 90       	pop	r0
    6228:	0f be       	out	0x3f, r0	; 63

        return pvReturn;
    622a:	89 81       	ldd	r24, Y+1	; 0x01
    622c:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    622e:	26 96       	adiw	r28, 0x06	; 6
    6230:	0f b6       	in	r0, 0x3f	; 63
    6232:	f8 94       	cli
    6234:	de bf       	out	0x3e, r29	; 62
    6236:	0f be       	out	0x3f, r0	; 63
    6238:	cd bf       	out	0x3d, r28	; 61
    623a:	cf 91       	pop	r28
    623c:	df 91       	pop	r29
    623e:	08 95       	ret

00006240 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

    void vTimerSetTimerID( TimerHandle_t xTimer,
                           void * pvNewID )
    {
    6240:	df 93       	push	r29
    6242:	cf 93       	push	r28
    6244:	00 d0       	rcall	.+0      	; 0x6246 <vTimerSetTimerID+0x6>
    6246:	00 d0       	rcall	.+0      	; 0x6248 <vTimerSetTimerID+0x8>
    6248:	00 d0       	rcall	.+0      	; 0x624a <vTimerSetTimerID+0xa>
    624a:	cd b7       	in	r28, 0x3d	; 61
    624c:	de b7       	in	r29, 0x3e	; 62
    624e:	9c 83       	std	Y+4, r25	; 0x04
    6250:	8b 83       	std	Y+3, r24	; 0x03
    6252:	7e 83       	std	Y+6, r23	; 0x06
    6254:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = xTimer;
    6256:	8b 81       	ldd	r24, Y+3	; 0x03
    6258:	9c 81       	ldd	r25, Y+4	; 0x04
    625a:	9a 83       	std	Y+2, r25	; 0x02
    625c:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    625e:	0f b6       	in	r0, 0x3f	; 63
    6260:	f8 94       	cli
    6262:	0f 92       	push	r0
        {
            pxTimer->pvTimerID = pvNewID;
    6264:	e9 81       	ldd	r30, Y+1	; 0x01
    6266:	fa 81       	ldd	r31, Y+2	; 0x02
    6268:	8d 81       	ldd	r24, Y+5	; 0x05
    626a:	9e 81       	ldd	r25, Y+6	; 0x06
    626c:	97 87       	std	Z+15, r25	; 0x0f
    626e:	86 87       	std	Z+14, r24	; 0x0e
        }
        taskEXIT_CRITICAL();
    6270:	0f 90       	pop	r0
    6272:	0f be       	out	0x3f, r0	; 63
    }
    6274:	26 96       	adiw	r28, 0x06	; 6
    6276:	0f b6       	in	r0, 0x3f	; 63
    6278:	f8 94       	cli
    627a:	de bf       	out	0x3e, r29	; 62
    627c:	0f be       	out	0x3f, r0	; 63
    627e:	cd bf       	out	0x3d, r28	; 61
    6280:	cf 91       	pop	r28
    6282:	df 91       	pop	r29
    6284:	08 95       	ret

00006286 <main>:
void Task3_Func(void);
TaskHandle_t task3ptr;


int main(void)
{
    6286:	0f 93       	push	r16
    6288:	1f 93       	push	r17
    628a:	df 93       	push	r29
    628c:	cf 93       	push	r28
    628e:	cd b7       	in	r28, 0x3d	; 61
    6290:	de b7       	in	r29, 0x3e	; 62
	DDRC  = 0xFF;	// Configure all PORTC pins as output pins
    6292:	e4 e3       	ldi	r30, 0x34	; 52
    6294:	f0 e0       	ldi	r31, 0x00	; 0
    6296:	8f ef       	ldi	r24, 0xFF	; 255
    6298:	80 83       	st	Z, r24

	/*########################### SOFTWARE TIMER ###############################*/

	 xTimers[ 0 ] = xTimerCreate( "Timer1", pdMS_TO_TICKS( 100 ), pdTRUE, ( void * ) 0, Task1_Func);
    629a:	e0 eb       	ldi	r30, 0xB0	; 176
    629c:	f1 e3       	ldi	r31, 0x31	; 49
    629e:	8d e6       	ldi	r24, 0x6D	; 109
    62a0:	90 e0       	ldi	r25, 0x00	; 0
    62a2:	62 e2       	ldi	r22, 0x22	; 34
    62a4:	70 e0       	ldi	r23, 0x00	; 0
    62a6:	41 e0       	ldi	r20, 0x01	; 1
    62a8:	20 e0       	ldi	r18, 0x00	; 0
    62aa:	30 e0       	ldi	r19, 0x00	; 0
    62ac:	8f 01       	movw	r16, r30
    62ae:	0e 94 00 2c 	call	0x5800	; 0x5800 <xTimerCreate>
    62b2:	90 93 e3 06 	sts	0x06E3, r25
    62b6:	80 93 e2 06 	sts	0x06E2, r24
	 xTimers[ 1 ] = xTimerCreate( "Timer2", pdMS_TO_TICKS( 50 ), pdTRUE, ( void * ) 0, Task2_Func);
    62ba:	ed ec       	ldi	r30, 0xCD	; 205
    62bc:	f1 e3       	ldi	r31, 0x31	; 49
    62be:	84 e7       	ldi	r24, 0x74	; 116
    62c0:	90 e0       	ldi	r25, 0x00	; 0
    62c2:	62 e3       	ldi	r22, 0x32	; 50
    62c4:	70 e0       	ldi	r23, 0x00	; 0
    62c6:	41 e0       	ldi	r20, 0x01	; 1
    62c8:	20 e0       	ldi	r18, 0x00	; 0
    62ca:	30 e0       	ldi	r19, 0x00	; 0
    62cc:	8f 01       	movw	r16, r30
    62ce:	0e 94 00 2c 	call	0x5800	; 0x5800 <xTimerCreate>
    62d2:	90 93 e5 06 	sts	0x06E5, r25
    62d6:	80 93 e4 06 	sts	0x06E4, r24
	 xTimers[ 2 ] = xTimerCreate( "Timer3", pdMS_TO_TICKS( 20 ), pdTRUE, ( void * ) 0, Task3_Func);
    62da:	ea ee       	ldi	r30, 0xEA	; 234
    62dc:	f1 e3       	ldi	r31, 0x31	; 49
    62de:	8b e7       	ldi	r24, 0x7B	; 123
    62e0:	90 e0       	ldi	r25, 0x00	; 0
    62e2:	64 e1       	ldi	r22, 0x14	; 20
    62e4:	70 e0       	ldi	r23, 0x00	; 0
    62e6:	41 e0       	ldi	r20, 0x01	; 1
    62e8:	20 e0       	ldi	r18, 0x00	; 0
    62ea:	30 e0       	ldi	r19, 0x00	; 0
    62ec:	8f 01       	movw	r16, r30
    62ee:	0e 94 00 2c 	call	0x5800	; 0x5800 <xTimerCreate>
    62f2:	90 93 e7 06 	sts	0x06E7, r25
    62f6:	80 93 e6 06 	sts	0x06E6, r24

	 xTimerStart( xTimers[ 0 ], pdMS_TO_TICKS( 100 ) );
    62fa:	00 91 e2 06 	lds	r16, 0x06E2
    62fe:	10 91 e3 06 	lds	r17, 0x06E3
    6302:	0e 94 7d 1c 	call	0x38fa	; 0x38fa <xTaskGetTickCount>
    6306:	9c 01       	movw	r18, r24
    6308:	c8 01       	movw	r24, r16
    630a:	61 e0       	ldi	r22, 0x01	; 1
    630c:	a9 01       	movw	r20, r18
    630e:	20 e0       	ldi	r18, 0x00	; 0
    6310:	30 e0       	ldi	r19, 0x00	; 0
    6312:	02 e2       	ldi	r16, 0x22	; 34
    6314:	10 e0       	ldi	r17, 0x00	; 0
    6316:	0e 94 92 2c 	call	0x5924	; 0x5924 <xTimerGenericCommand>
	 xTimerStart( xTimers[ 1 ], pdMS_TO_TICKS( 50 ) );
    631a:	00 91 e4 06 	lds	r16, 0x06E4
    631e:	10 91 e5 06 	lds	r17, 0x06E5
    6322:	0e 94 7d 1c 	call	0x38fa	; 0x38fa <xTaskGetTickCount>
    6326:	9c 01       	movw	r18, r24
    6328:	c8 01       	movw	r24, r16
    632a:	61 e0       	ldi	r22, 0x01	; 1
    632c:	a9 01       	movw	r20, r18
    632e:	20 e0       	ldi	r18, 0x00	; 0
    6330:	30 e0       	ldi	r19, 0x00	; 0
    6332:	02 e3       	ldi	r16, 0x32	; 50
    6334:	10 e0       	ldi	r17, 0x00	; 0
    6336:	0e 94 92 2c 	call	0x5924	; 0x5924 <xTimerGenericCommand>
	 xTimerStart( xTimers[ 2 ], pdMS_TO_TICKS( 20 ) );
    633a:	00 91 e6 06 	lds	r16, 0x06E6
    633e:	10 91 e7 06 	lds	r17, 0x06E7
    6342:	0e 94 7d 1c 	call	0x38fa	; 0x38fa <xTaskGetTickCount>
    6346:	9c 01       	movw	r18, r24
    6348:	c8 01       	movw	r24, r16
    634a:	61 e0       	ldi	r22, 0x01	; 1
    634c:	a9 01       	movw	r20, r18
    634e:	20 e0       	ldi	r18, 0x00	; 0
    6350:	30 e0       	ldi	r19, 0x00	; 0
    6352:	04 e1       	ldi	r16, 0x14	; 20
    6354:	10 e0       	ldi	r17, 0x00	; 0
    6356:	0e 94 92 2c 	call	0x5924	; 0x5924 <xTimerGenericCommand>
//	xTaskCreate(Task2_Func,"second",configMINIMAL_STACK_SIZE,NULL,0,&task2ptr);
//	xTaskCreate(Task3_Func,"third",configMINIMAL_STACK_SIZE,NULL,0,&task3ptr);

	 /*##########################################################################*/

	vTaskStartScheduler();
    635a:	0e 94 da 1a 	call	0x35b4	; 0x35b4 <vTaskStartScheduler>
    635e:	ff cf       	rjmp	.-2      	; 0x635e <main+0xd8>

00006360 <Task1_Func>:
	while(1){}
}


void Task1_Func(void)
{
    6360:	df 93       	push	r29
    6362:	cf 93       	push	r28
    6364:	00 d0       	rcall	.+0      	; 0x6366 <Task1_Func+0x6>
    6366:	00 d0       	rcall	.+0      	; 0x6368 <Task1_Func+0x8>
    6368:	cd b7       	in	r28, 0x3d	; 61
    636a:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime;
	const TickType_t xPeriod = pdMS_TO_TICKS( 100 );
    636c:	82 e2       	ldi	r24, 0x22	; 34
    636e:	90 e0       	ldi	r25, 0x00	; 0
    6370:	9a 83       	std	Y+2, r25	; 0x02
    6372:	89 83       	std	Y+1, r24	; 0x01
	xLastWakeTime = xTaskGetTickCount();
    6374:	0e 94 7d 1c 	call	0x38fa	; 0x38fa <xTaskGetTickCount>
    6378:	9c 83       	std	Y+4, r25	; 0x04
    637a:	8b 83       	std	Y+3, r24	; 0x03
//	while(1)
//	{
		PORTC ^= (1u<<5);
    637c:	a5 e3       	ldi	r26, 0x35	; 53
    637e:	b0 e0       	ldi	r27, 0x00	; 0
    6380:	e5 e3       	ldi	r30, 0x35	; 53
    6382:	f0 e0       	ldi	r31, 0x00	; 0
    6384:	90 81       	ld	r25, Z
    6386:	80 e2       	ldi	r24, 0x20	; 32
    6388:	89 27       	eor	r24, r25
    638a:	8c 93       	st	X, r24
//		vTaskDelayUntil( &xLastWakeTime, xPeriod );
//		vTaskDelay( 100 );
//	}
//		xTimerStop( xTimers[ 0 ], pdMS_TO_TICKS( 100 ) );
}
    638c:	0f 90       	pop	r0
    638e:	0f 90       	pop	r0
    6390:	0f 90       	pop	r0
    6392:	0f 90       	pop	r0
    6394:	cf 91       	pop	r28
    6396:	df 91       	pop	r29
    6398:	08 95       	ret

0000639a <Task2_Func>:



void Task2_Func(void)
{
    639a:	df 93       	push	r29
    639c:	cf 93       	push	r28
    639e:	00 d0       	rcall	.+0      	; 0x63a0 <Task2_Func+0x6>
    63a0:	00 d0       	rcall	.+0      	; 0x63a2 <Task2_Func+0x8>
    63a2:	cd b7       	in	r28, 0x3d	; 61
    63a4:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime;
	const TickType_t xPeriod = pdMS_TO_TICKS( 50 );
    63a6:	82 e3       	ldi	r24, 0x32	; 50
    63a8:	90 e0       	ldi	r25, 0x00	; 0
    63aa:	9a 83       	std	Y+2, r25	; 0x02
    63ac:	89 83       	std	Y+1, r24	; 0x01
	xLastWakeTime = xTaskGetTickCount();
    63ae:	0e 94 7d 1c 	call	0x38fa	; 0x38fa <xTaskGetTickCount>
    63b2:	9c 83       	std	Y+4, r25	; 0x04
    63b4:	8b 83       	std	Y+3, r24	; 0x03
//	while(1)
//	{
		PORTC ^= (1u<<3);
    63b6:	a5 e3       	ldi	r26, 0x35	; 53
    63b8:	b0 e0       	ldi	r27, 0x00	; 0
    63ba:	e5 e3       	ldi	r30, 0x35	; 53
    63bc:	f0 e0       	ldi	r31, 0x00	; 0
    63be:	90 81       	ld	r25, Z
    63c0:	88 e0       	ldi	r24, 0x08	; 8
    63c2:	89 27       	eor	r24, r25
    63c4:	8c 93       	st	X, r24
//		vTaskDelayUntil( &xLastWakeTime, xPeriod );
//	}
//		xTimerStop( xTimers[ 1 ], pdMS_TO_TICKS( 50 ) );
}
    63c6:	0f 90       	pop	r0
    63c8:	0f 90       	pop	r0
    63ca:	0f 90       	pop	r0
    63cc:	0f 90       	pop	r0
    63ce:	cf 91       	pop	r28
    63d0:	df 91       	pop	r29
    63d2:	08 95       	ret

000063d4 <Task3_Func>:

void Task3_Func(void)
{
    63d4:	df 93       	push	r29
    63d6:	cf 93       	push	r28
    63d8:	00 d0       	rcall	.+0      	; 0x63da <Task3_Func+0x6>
    63da:	00 d0       	rcall	.+0      	; 0x63dc <Task3_Func+0x8>
    63dc:	cd b7       	in	r28, 0x3d	; 61
    63de:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime;
	const TickType_t xPeriod = pdMS_TO_TICKS( 20 );
    63e0:	84 e1       	ldi	r24, 0x14	; 20
    63e2:	90 e0       	ldi	r25, 0x00	; 0
    63e4:	9a 83       	std	Y+2, r25	; 0x02
    63e6:	89 83       	std	Y+1, r24	; 0x01
	xLastWakeTime = xTaskGetTickCount();
    63e8:	0e 94 7d 1c 	call	0x38fa	; 0x38fa <xTaskGetTickCount>
    63ec:	9c 83       	std	Y+4, r25	; 0x04
    63ee:	8b 83       	std	Y+3, r24	; 0x03
//	while(1)
//	{
		PORTC ^= (1u<<1);
    63f0:	a5 e3       	ldi	r26, 0x35	; 53
    63f2:	b0 e0       	ldi	r27, 0x00	; 0
    63f4:	e5 e3       	ldi	r30, 0x35	; 53
    63f6:	f0 e0       	ldi	r31, 0x00	; 0
    63f8:	90 81       	ld	r25, Z
    63fa:	82 e0       	ldi	r24, 0x02	; 2
    63fc:	89 27       	eor	r24, r25
    63fe:	8c 93       	st	X, r24
//		vTaskDelayUntil( &xLastWakeTime, xPeriod );
//	}
//		xTimerStop( xTimers[ 2 ], pdMS_TO_TICKS( 20 ) );
}
    6400:	0f 90       	pop	r0
    6402:	0f 90       	pop	r0
    6404:	0f 90       	pop	r0
    6406:	0f 90       	pop	r0
    6408:	cf 91       	pop	r28
    640a:	df 91       	pop	r29
    640c:	08 95       	ret

0000640e <__udivmodhi4>:
    640e:	aa 1b       	sub	r26, r26
    6410:	bb 1b       	sub	r27, r27
    6412:	51 e1       	ldi	r21, 0x11	; 17
    6414:	07 c0       	rjmp	.+14     	; 0x6424 <__udivmodhi4_ep>

00006416 <__udivmodhi4_loop>:
    6416:	aa 1f       	adc	r26, r26
    6418:	bb 1f       	adc	r27, r27
    641a:	a6 17       	cp	r26, r22
    641c:	b7 07       	cpc	r27, r23
    641e:	10 f0       	brcs	.+4      	; 0x6424 <__udivmodhi4_ep>
    6420:	a6 1b       	sub	r26, r22
    6422:	b7 0b       	sbc	r27, r23

00006424 <__udivmodhi4_ep>:
    6424:	88 1f       	adc	r24, r24
    6426:	99 1f       	adc	r25, r25
    6428:	5a 95       	dec	r21
    642a:	a9 f7       	brne	.-22     	; 0x6416 <__udivmodhi4_loop>
    642c:	80 95       	com	r24
    642e:	90 95       	com	r25
    6430:	bc 01       	movw	r22, r24
    6432:	cd 01       	movw	r24, r26
    6434:	08 95       	ret

00006436 <memcpy>:
    6436:	fb 01       	movw	r30, r22
    6438:	dc 01       	movw	r26, r24
    643a:	02 c0       	rjmp	.+4      	; 0x6440 <memcpy+0xa>
    643c:	01 90       	ld	r0, Z+
    643e:	0d 92       	st	X+, r0
    6440:	41 50       	subi	r20, 0x01	; 1
    6442:	50 40       	sbci	r21, 0x00	; 0
    6444:	d8 f7       	brcc	.-10     	; 0x643c <memcpy+0x6>
    6446:	08 95       	ret

00006448 <memset>:
    6448:	dc 01       	movw	r26, r24
    644a:	01 c0       	rjmp	.+2      	; 0x644e <memset+0x6>
    644c:	6d 93       	st	X+, r22
    644e:	41 50       	subi	r20, 0x01	; 1
    6450:	50 40       	sbci	r21, 0x00	; 0
    6452:	e0 f7       	brcc	.-8      	; 0x644c <memset+0x4>
    6454:	08 95       	ret

00006456 <_exit>:
    6456:	f8 94       	cli

00006458 <__stop_program>:
    6458:	ff cf       	rjmp	.-2      	; 0x6458 <__stop_program>
